<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸€å‰¯ä¸‰è§’å°º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        
        #canvas {
            display: block;
            cursor: grab;
            background: white;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        .info {
            display: none; /* éšè—æ–‡å­—æç¤º */
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
        
        .snap-indicator {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ff4444;
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .snap-indicator.active {
            opacity: 1;
        }
        
        .random-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .random-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        .random-button:active {
            transform: scale(0.95);
        }
        
        .random-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="snapIndicator" class="snap-indicator"></div>
    <button id="randomButton" class="random-button" title="éšæœºæ‹¼æ¥ä¸‰è§’å°º">ğŸ²</button>

    <script>
        class Triangle {
            constructor(x, y, size, angle = 0, type = '30-60-90') {
                this.x = x;
                this.y = y;
                this.size = size;
                this.angle = angle;
                this.type = type;
                this.selected = false;
                this.dragging = false;
                this.rotating = false;
                this.dragOffset = { x: 0, y: 0 };
                this.rotationStart = 0;
                this.angleStart = 0;
                // è®°å½•å½“å‰æ—‹è½¬ä½¿ç”¨çš„å±€éƒ¨æ¢è½´ï¼ˆé¡¶ç‚¹æˆ–é‡å¿ƒï¼‰
                this.rotationPivotLocal = null;
                // è®°å½•å½“å‰æ—‹è½¬ä½¿ç”¨çš„ä¸–ç•Œæ¢è½´åæ ‡ï¼ˆå¸é™„é¡¶ç‚¹æˆ–é‡å¿ƒï¼‰
                this.rotationCenterWorldX = null;
                this.rotationCenterWorldY = null;
                
                // æ—‹è½¬æŒ‰é’®çš„ç›¸å¯¹ä½ç½®ï¼ˆç›¸å¯¹äºä¸‰è§’å½¢ä¸­å¿ƒçš„åç§»ï¼‰
                this.rotationButtonOffsetX = null;
                this.rotationButtonOffsetY = null;
                this.rotationButtonNeedsRecalc = true;  // æ ‡è®°æ˜¯å¦éœ€è¦é‡æ–°è®¡ç®—æŒ‰é’®ä½ç½®
                
                // è§’åº¦æ ‡è®°æ˜¾ç¤ºçŠ¶æ€
                this.angleMarkVisible = {
                    angle0: false,  // ç¬¬ä¸€ä¸ªè§’ï¼ˆ30Â°æˆ–45Â°ï¼‰
                    angle1: false,  // ç¬¬äºŒä¸ªè§’ï¼ˆ90Â°ï¼‰
                    angle2: false   // ç¬¬ä¸‰ä¸ªè§’ï¼ˆ60Â°æˆ–45Â°ï¼‰
                };
                
                // æ ¹æ®ç±»å‹è®¾ç½®é¡¶ç‚¹
                this.updateVertices();
            }
            
            updateVertices() {
                const cos = Math.cos(this.angle);
                const sin = Math.sin(this.angle);
                
                if (this.type === '30-60-90') {
                    // 30-60-90åº¦ç›´è§’ä¸‰è§’å½¢ï¼š90Â°è§’åœ¨å·¦ä¸‹ï¼Œ30Â°è§’åœ¨é¡¶éƒ¨ï¼Œ60Â°è§’åœ¨å³ä¸‹
                    // åœ¨30-60-90ä¸‰è§’å½¢ä¸­ï¼Œè¾¹é•¿æ¯”ä¾‹ä¸º 1 : âˆš3 : 2
                    // è®¾ç½®ç›´è§’è¾¹é•¿åº¦ï¼Œç¡®ä¿90Â°è§’åœ¨å·¦ä¸‹è§’
                    const shortSide = this.size;           // çŸ­ç›´è§’è¾¹ï¼ˆæ°´å¹³å‘å³ï¼‰
                    const longSide = this.size * Math.sqrt(3);  // é•¿ç›´è§’è¾¹ï¼ˆå‚ç›´å‘ä¸Šï¼‰
                    
                    const vertices = [
                        { x: 0, y: -longSide },               // é¡¶éƒ¨ (30Â°è§’) - é•¿è¾¹é¡¶ç«¯
                        { x: 0, y: 0 },                       // å·¦ä¸‹ (90Â°è§’) - ç›´è§’é¡¶ç‚¹
                        { x: shortSide, y: 0 }                // å³ä¸‹ (60Â°è§’) - çŸ­è¾¹é¡¶ç«¯
                    ];
                    
                    this.vertices = vertices.map(v => ({
                        x: this.x + v.x * cos - v.y * sin,
                        y: this.y + v.x * sin + v.y * cos
                    }));
                    // è®¡ç®—å¹¶å­˜å‚¨å½“å‰ä¸‰è§’å½¢ä¸­å¿ƒç‚¹ï¼ˆé‡å¿ƒï¼‰
                    this.centerX = (this.vertices[0].x + this.vertices[1].x + this.vertices[2].x) / 3;
                    this.centerY = (this.vertices[0].y + this.vertices[1].y + this.vertices[2].y) / 3;
                } else if (this.type === '45-45-90') {
                    // 45-45-90åº¦ç›´è§’ä¸‰è§’å½¢ï¼š90Â°è§’åœ¨å·¦ä¸‹ï¼Œä¸¤ä¸ª45Â°è§’åˆ†åˆ«åœ¨é¡¶éƒ¨å’Œå³ä¸‹
                    // åœ¨45-45-90ä¸‰è§’å½¢ä¸­ï¼Œä¸¤æ¡ç›´è§’è¾¹ç›¸ç­‰ï¼Œæ–œè¾¹ä¸ºç›´è§’è¾¹çš„âˆš2å€
                    const leg = this.size;                     // ç›´è§’è¾¹é•¿åº¦
                    
                    const vertices = [
                        { x: 0, y: -leg },                     // é¡¶éƒ¨ (45Â°è§’) - å‚ç›´è¾¹é¡¶ç«¯
                        { x: 0, y: 0 },                       // å·¦ä¸‹ (90Â°è§’) - ç›´è§’é¡¶ç‚¹
                        { x: leg, y: 0 }                      // å³ä¸‹ (45Â°è§’) - æ°´å¹³è¾¹é¡¶ç«¯
                    ];
                    
                    this.vertices = vertices.map(v => ({
                        x: this.x + v.x * cos - v.y * sin,
                        y: this.y + v.x * sin + v.y * cos
                    }));
                    // è®¡ç®—å¹¶å­˜å‚¨å½“å‰ä¸‰è§’å½¢ä¸­å¿ƒç‚¹ï¼ˆé‡å¿ƒï¼‰
                    this.centerX = (this.vertices[0].x + this.vertices[1].x + this.vertices[2].x) / 3;
                    this.centerY = (this.vertices[0].y + this.vertices[1].y + this.vertices[2].y) / 3;
                }
            }
            
            draw(ctx) {
                ctx.save();
                
                // å¯ç”¨æŠ—é”¯é½¿å’Œå›¾åƒå¹³æ»‘
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                // ç»˜åˆ¶ä¸‰è§’å½¢
                ctx.beginPath();
                ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
                for (let i = 1; i < this.vertices.length; i++) {
                    ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
                }
                ctx.closePath();
                
                // å¡«å……å’Œæè¾¹
                ctx.fillStyle = this.selected ? 'rgba(173, 216, 230, 0.8)' : 'rgba(173, 216, 230, 0.7)';
                ctx.fill();
                ctx.strokeStyle = this.selected ? '#4080ff' : '#666';
                ctx.lineWidth = this.selected ? 3 : 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
                
                // ç»˜åˆ¶é¡¶ç‚¹
                if (this.selected) {
                    this.vertices.forEach((vertex, index) => {
                        ctx.beginPath();
                        ctx.arc(vertex.x, vertex.y, 5, 0, Math.PI * 2);
                        ctx.fillStyle = '#ff4444';
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    });
                    
                    // ç»˜åˆ¶æ—‹è½¬æŒ‰é’®ï¼ˆåœ¨ä¸‰è§’å½¢é¡¶éƒ¨ï¼‰
                    this.drawRotationButton(ctx);
                }
                
                // ç»˜åˆ¶è§’åº¦æ ‡è®°
                this.drawAngleMarks(ctx);
                
                ctx.restore();
            }
            
            drawAngleMarks(ctx) {
                const fontSize = 20;
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (this.type === '30-60-90') {
                    // ç»˜åˆ¶30Â°è§’çš„å¼§çº¿ï¼ˆå§‹ç»ˆæ˜¾ç¤ºï¼‰
                    this.drawAngleArcOnly(ctx, this.vertices[0], this.vertices[1], this.vertices[2], 20);
                    // ç»˜åˆ¶30Â°è§’çš„æ–‡å­—æ ‡è®°ï¼ˆä»…åœ¨å¯è§æ—¶æ˜¾ç¤ºï¼‰
                    if (this.angleMarkVisible.angle0) {
                        this.drawAngleLabel(ctx, this.vertices[0], this.vertices[1], this.vertices[2], 20, '30Â°');
                    }
                    
                    // ç»˜åˆ¶90Â°è§’çš„ç›´è§’ç¬¦å·ï¼ˆå§‹ç»ˆæ˜¾ç¤ºï¼‰
                    this.drawRightAngleSymbol(ctx, this.vertices[1], this.vertices[0], this.vertices[2], 15);
                    // ç»˜åˆ¶90Â°è§’çš„æ–‡å­—æ ‡è®°ï¼ˆä»…åœ¨å¯è§æ—¶æ˜¾ç¤ºï¼‰
                    if (this.angleMarkVisible.angle1) {
                        this.drawRightAngleLabel(ctx, this.vertices[1], this.vertices[0], this.vertices[2], '90Â°');
                    }
                    
                    // ç»˜åˆ¶60Â°è§’çš„å¼§çº¿ï¼ˆå§‹ç»ˆæ˜¾ç¤ºï¼‰
                    this.drawAngleArcOnly(ctx, this.vertices[2], this.vertices[0], this.vertices[1], 25);
                    // ç»˜åˆ¶60Â°è§’çš„æ–‡å­—æ ‡è®°ï¼ˆä»…åœ¨å¯è§æ—¶æ˜¾ç¤ºï¼‰
                    if (this.angleMarkVisible.angle2) {
                        this.drawAngleLabel(ctx, this.vertices[2], this.vertices[0], this.vertices[1], 25, '60Â°');
                    }
                } else if (this.type === '45-45-90') {
                    // ç»˜åˆ¶45Â°è§’çš„å¼§çº¿ï¼ˆå§‹ç»ˆæ˜¾ç¤ºï¼‰
                    this.drawAngleArcOnly(ctx, this.vertices[0], this.vertices[1], this.vertices[2], 20);
                    // ç»˜åˆ¶45Â°è§’çš„æ–‡å­—æ ‡è®°ï¼ˆä»…åœ¨å¯è§æ—¶æ˜¾ç¤ºï¼‰
                    if (this.angleMarkVisible.angle0) {
                        this.drawAngleLabel(ctx, this.vertices[0], this.vertices[1], this.vertices[2], 20, '45Â°');
                    }
                    
                    // ç»˜åˆ¶90Â°è§’çš„ç›´è§’ç¬¦å·ï¼ˆå§‹ç»ˆæ˜¾ç¤ºï¼‰
                    this.drawRightAngleSymbol(ctx, this.vertices[1], this.vertices[0], this.vertices[2], 15);
                    // ç»˜åˆ¶90Â°è§’çš„æ–‡å­—æ ‡è®°ï¼ˆä»…åœ¨å¯è§æ—¶æ˜¾ç¤ºï¼‰
                    if (this.angleMarkVisible.angle1) {
                        this.drawRightAngleLabel(ctx, this.vertices[1], this.vertices[0], this.vertices[2], '90Â°');
                    }
                    
                    // ç»˜åˆ¶45Â°è§’çš„å¼§çº¿ï¼ˆå§‹ç»ˆæ˜¾ç¤ºï¼‰
                    this.drawAngleArcOnly(ctx, this.vertices[2], this.vertices[0], this.vertices[1], 20);
                    // ç»˜åˆ¶45Â°è§’çš„æ–‡å­—æ ‡è®°ï¼ˆä»…åœ¨å¯è§æ—¶æ˜¾ç¤ºï¼‰
                    if (this.angleMarkVisible.angle2) {
                        this.drawAngleLabel(ctx, this.vertices[2], this.vertices[0], this.vertices[1], 20, '45Â°');
                    }
                }
            }
            
            drawRightAngleSymbol(ctx, vertex, point1, point2, size) {
                // è®¡ç®—ä¸¤æ¡è¾¹çš„å•ä½å‘é‡
                const vec1 = { x: point1.x - vertex.x, y: point1.y - vertex.y };
                const vec2 = { x: point2.x - vertex.x, y: point2.y - vertex.y };
                
                const len1 = Math.sqrt(vec1.x * vec1.x + vec1.y * vec1.y);
                const len2 = Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
                
                const unit1 = { x: vec1.x / len1, y: vec1.y / len1 };
                const unit2 = { x: vec2.x / len2, y: vec2.y / len2 };
                
                // ç»˜åˆ¶ç›´è§’ç¬¦å·
                const corner1 = { x: vertex.x + unit1.x * size, y: vertex.y + unit1.y * size };
                const corner2 = { x: vertex.x + unit2.x * size, y: vertex.y + unit2.y * size };
                const corner3 = { x: corner1.x + unit2.x * size, y: corner1.y + unit2.y * size };
                
                ctx.beginPath();
                ctx.moveTo(corner1.x, corner1.y);
                ctx.lineTo(corner3.x, corner3.y);
                ctx.lineTo(corner2.x, corner2.y);
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            drawRightAngleLabel(ctx, vertex, point1, point2, label) {
                // è®¡ç®—ä¸¤æ¡è¾¹çš„å•ä½å‘é‡
                const vec1 = { x: point1.x - vertex.x, y: point1.y - vertex.y };
                const vec2 = { x: point2.x - vertex.x, y: point2.y - vertex.y };
                
                const len1 = Math.sqrt(vec1.x * vec1.x + vec1.y * vec1.y);
                const len2 = Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
                
                const unit1 = { x: vec1.x / len1, y: vec1.y / len1 };
                const unit2 = { x: vec2.x / len2, y: vec2.y / len2 };
                
                // è®¡ç®—è§’å¹³åˆ†çº¿æ–¹å‘ï¼ˆå‘ä¸‰è§’å½¢å†…éƒ¨ï¼‰
                const bisector = { 
                    x: (unit1.x + unit2.x) / 2, 
                    y: (unit1.y + unit2.y) / 2 
                };
                
                // æ ‡å‡†åŒ–è§’å¹³åˆ†çº¿å‘é‡
                const bisectorLen = Math.sqrt(bisector.x * bisector.x + bisector.y * bisector.y);
                if (bisectorLen > 0) {
                    bisector.x /= bisectorLen;
                    bisector.y /= bisectorLen;
                }
                
                // åœ¨è§’å¹³åˆ†çº¿ä¸Šæ”¾ç½®æ ‡ç­¾ï¼Œè·ç¦»é¡¶ç‚¹50åƒç´ 
                const labelDistance = 50;
                const labelX = vertex.x + bisector.x * labelDistance;
                const labelY = vertex.y + bisector.y * labelDistance;
                
                // ç»˜åˆ¶90Â°æ ‡ç­¾
                ctx.fillStyle = '#333';
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, labelX, labelY);
            }
            
            drawAngleArcOnly(ctx, vertex, point1, point2, radius) {
                // è®¡ç®—ä¸¤æ¡è¾¹çš„å‘é‡
                const vec1 = { x: point1.x - vertex.x, y: point1.y - vertex.y };
                const vec2 = { x: point2.x - vertex.x, y: point2.y - vertex.y };
                
                // è®¡ç®—è§’åº¦
                const angle1 = Math.atan2(vec1.y, vec1.x);
                const angle2 = Math.atan2(vec2.y, vec2.x);
                
                // ç¡®ä¿å¼§çº¿åœ¨ä¸‰è§’å½¢å†…éƒ¨
                let startAngle = angle1;
                let endAngle = angle2;
                
                // è®¡ç®—è§’åº¦å·®ï¼Œç¡®ä¿é€‰æ‹©è¾ƒå°çš„å†…è§’
                let angleDiff = endAngle - startAngle;
                if (angleDiff > Math.PI) {
                    angleDiff -= 2 * Math.PI;
                } else if (angleDiff < -Math.PI) {
                    angleDiff += 2 * Math.PI;
                }
                
                if (angleDiff < 0) {
                    [startAngle, endAngle] = [endAngle, startAngle];
                    angleDiff = -angleDiff;
                }
                
                // ç»˜åˆ¶å¼§çº¿
                ctx.beginPath();
                ctx.arc(vertex.x, vertex.y, radius, startAngle, endAngle);
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            drawAngleLabel(ctx, vertex, point1, point2, radius, label) {
                // è®¡ç®—ä¸‰è§’å½¢çš„é‡å¿ƒï¼Œç”¨äºç¡®å®šå†…éƒ¨æ–¹å‘
                const centroidX = (this.vertices[0].x + this.vertices[1].x + this.vertices[2].x) / 3;
                const centroidY = (this.vertices[0].y + this.vertices[1].y + this.vertices[2].y) / 3;
                
                // ä»é¡¶ç‚¹åˆ°é‡å¿ƒçš„å‘é‡
                const toCentroid = {
                    x: centroidX - vertex.x,
                    y: centroidY - vertex.y
                };
                
                // æ ‡å‡†åŒ–å‘é‡å¿ƒçš„å‘é‡
                const toCentroidLen = Math.sqrt(toCentroid.x * toCentroid.x + toCentroid.y * toCentroid.y);
                if (toCentroidLen > 0) {
                    toCentroid.x /= toCentroidLen;
                    toCentroid.y /= toCentroidLen;
                }
                
                // ä½¿ç”¨å‘é‡å¿ƒæ–¹å‘çš„åç§»æ¥ç¡®ä¿æ ‡ç­¾åœ¨ä¸‰è§’å½¢å†…éƒ¨
                const labelRadius = radius + 50; // åœ¨å¼§çº¿å¤–ä¾§50åƒç´ 
                const labelX = vertex.x + toCentroid.x * labelRadius;
                const labelY = vertex.y + toCentroid.y * labelRadius;
                
                // ç»˜åˆ¶è§’åº¦æ ‡ç­¾
                ctx.fillStyle = '#333';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, labelX, labelY);
            }
            
            drawRotationButton(ctx) {
                // å¦‚æœæ­£åœ¨æ—‹è½¬ï¼Œéšè—æ—‹è½¬æŒ‰é’®
                if (this.rotating) {
                    return;
                }
                
                // è®¡ç®—ä¸‰è§’å½¢ä¸­å¿ƒç‚¹
                const centerX = (this.vertices[0].x + this.vertices[1].x + this.vertices[2].x) / 3;
                const centerY = (this.vertices[0].y + this.vertices[1].y + this.vertices[2].y) / 3;
                
                // å¦‚æœéœ€è¦é‡æ–°è®¡ç®—æŒ‰é’®ä½ç½®ï¼ˆé¦–æ¬¡é€‰ä¸­æˆ–é‡æ–°é€‰ä¸­ï¼‰
                if (this.rotationButtonNeedsRecalc) {
                    // è®¡ç®—ä¸‰è§’å½¢çš„è¾¹ç•ŒçŸ©å½¢
                    let minX = this.vertices[0].x;
                    let maxX = this.vertices[0].x;
                    let minY = this.vertices[0].y;
                    let maxY = this.vertices[0].y;
                    
                    for (let vertex of this.vertices) {
                        minX = Math.min(minX, vertex.x);
                        maxX = Math.max(maxX, vertex.x);
                        minY = Math.min(minY, vertex.y);
                        maxY = Math.max(maxY, vertex.y);
                    }
                    
                    // è®¡ç®—æŒ‰é’®åœ¨çŸ©å½¢é¡¶éƒ¨ä¸­é—´çš„ä½ç½®
                    const buttonX = (minX + maxX) / 2;
                    const buttonY = minY - 30;
                    
                    // å­˜å‚¨ç›¸å¯¹äºä¸‰è§’å½¢ä¸­å¿ƒçš„åç§»
                    this.rotationButtonOffsetX = buttonX - centerX;
                    this.rotationButtonOffsetY = buttonY - centerY;
                    
                    // æ ‡è®°ä¸å†éœ€è¦é‡æ–°è®¡ç®—
                    this.rotationButtonNeedsRecalc = false;
                }
                
                // ä½¿ç”¨å­˜å‚¨çš„åç§»è®¡ç®—å½“å‰æŒ‰é’®ä½ç½®ï¼ˆè·Ÿéšä¸‰è§’å½¢æ—‹è½¬ï¼‰
                this.rotationButtonX = centerX + this.rotationButtonOffsetX;
                this.rotationButtonY = centerY + this.rotationButtonOffsetY;
                this.rotationButtonRadius = 15;            // æŒ‰é’®åŠå¾„
                
                // å­˜å‚¨ä¸‰è§’å½¢ä¸­å¿ƒç‚¹ç”¨äºæ—‹è½¬
                this.centerX = centerX;
                this.centerY = centerY;
                
                // ç»˜åˆ¶æ—‹è½¬æŒ‰é’®
                ctx.beginPath();
                ctx.arc(this.rotationButtonX, this.rotationButtonY, this.rotationButtonRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#fefefe';
                ctx.fill();
                ctx.strokeStyle = '#4080ff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ç»˜åˆ¶æ—‹è½¬å›¾æ ‡ï¼ˆå°åœ†åœˆï¼‰
                ctx.save();
                ctx.translate(this.rotationButtonX, this.rotationButtonY);
                ctx.strokeStyle = '#4080ff';
                ctx.lineWidth = 2;
                
                // ç»˜åˆ¶å°åœ†åœˆ
                ctx.beginPath();
                ctx.arc(0, 0, 16, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            }
            
            isPointInRotationButton(x, y) {
                if (!this.selected || !this.rotationButtonX) return false;
                
                const dx = x - this.rotationButtonX;
                const dy = y - this.rotationButtonY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                return distance <= this.rotationButtonRadius;
            }
            
            containsPoint(x, y) {
                // ä½¿ç”¨å°„çº¿æ³•åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…
                let inside = false;
                const vertices = this.vertices;
                
                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    if (((vertices[i].y > y) !== (vertices[j].y > y)) &&
                        (x < (vertices[j].x - vertices[i].x) * (y - vertices[i].y) / (vertices[j].y - vertices[i].y) + vertices[i].x)) {
                        inside = !inside;
                    }
                }
                
                return inside;
            }
            
            getClosestVertex(x, y, threshold = 20) {
                let closest = null;
                let minDistance = threshold;
                
                this.vertices.forEach((vertex, index) => {
                    const distance = Math.sqrt((x - vertex.x) ** 2 + (y - vertex.y) ** 2);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = { index, vertex, distance };
                    }
                });
                
                return closest;
            }
            
            getClosestEdge(x, y, threshold = 15) {
                let closest = null;
                let minDistance = threshold;
                
                for (let i = 0; i < this.vertices.length; i++) {
                    const v1 = this.vertices[i];
                    const v2 = this.vertices[(i + 1) % this.vertices.length];
                    
                    const distance = this.pointToLineDistance(x, y, v1.x, v1.y, v2.x, v2.y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = { 
                            index: i, 
                            v1, 
                            v2, 
                            distance,
                            closestPoint: this.getClosestPointOnLine(x, y, v1.x, v1.y, v2.x, v2.y)
                        };
                    }
                }
                
                return closest;
            }
            
            pointToLineDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                
                if (lenSq === 0) return Math.sqrt(A * A + B * B);
                
                let param = dot / lenSq;
                param = Math.max(0, Math.min(1, param));
                
                const xx = x1 + param * C;
                const yy = y1 + param * D;
                
                return Math.sqrt((px - xx) ** 2 + (py - yy) ** 2);
            }
            
            getClosestPointOnLine(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                
                if (lenSq === 0) return { x: x1, y: y1 };
                
                let param = dot / lenSq;
                param = Math.max(0, Math.min(1, param));
                
                return {
                    x: x1 + param * C,
                    y: y1 + param * D
                };
            }
            
            // æ£€æµ‹ç‚¹å‡»æ˜¯å¦åœ¨è§’åº¦åŒºåŸŸå†…
            isPointInAngleArea(x, y, angleIndex, threshold = 130) {
                const vertex = this.vertices[angleIndex];
                const distance = Math.sqrt((x - vertex.x) ** 2 + (y - vertex.y) ** 2);
                
                // é¦–å…ˆæ£€æŸ¥ç‚¹æ˜¯å¦åœ¨é˜ˆå€¼è·ç¦»å†…
                if (distance > threshold) {
                    return false;
                }
                
                // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…éƒ¨
                if (!this.containsPoint(x, y)) {
                    return false;
                }
                
                // è¿›ä¸€æ­¥æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨è§’åº¦æ‰‡å½¢åŒºåŸŸå†…
                const otherVertices = this.vertices.filter((_, index) => index !== angleIndex);
                const point1 = otherVertices[0];
                const point2 = otherVertices[1];
                
                // è®¡ç®—ä»é¡¶ç‚¹åˆ°å…¶ä»–ä¸¤ä¸ªé¡¶ç‚¹çš„å‘é‡
                const vec1 = { x: point1.x - vertex.x, y: point1.y - vertex.y };
                const vec2 = { x: point2.x - vertex.x, y: point2.y - vertex.y };
                
                // è®¡ç®—ä»é¡¶ç‚¹åˆ°ç‚¹å‡»ç‚¹çš„å‘é‡
                const vecClick = { x: x - vertex.x, y: y - vertex.y };
                
                // ä½¿ç”¨å‰ç§¯åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨è§’åº¦æ‰‡å½¢å†…
                // è®¡ç®—ä¸¤ä¸ªè¾¹å‘é‡çš„å‰ç§¯ï¼Œåˆ¤æ–­è§’åº¦æ–¹å‘
                const cross1 = vec1.x * vecClick.y - vec1.y * vecClick.x;
                const cross2 = vec2.x * vecClick.y - vec2.y * vecClick.x;
                
                // è®¡ç®—ä¸¤ä¸ªè¾¹å‘é‡ä¹‹é—´çš„å‰ç§¯ï¼Œåˆ¤æ–­è§’åº¦æ˜¯å¦ä¸ºå‡¸è§’
                const edgeCross = vec1.x * vec2.y - vec1.y * vec2.x;
                
                // å¦‚æœæ˜¯å‡¸è§’ï¼ˆå‰ç§¯åŒå·ï¼‰ï¼Œç‚¹å‡»ç‚¹åº”è¯¥åœ¨ä¸¤ä¸ªè¾¹å‘é‡ä¹‹é—´
                // å¦‚æœæ˜¯å‡¹è§’ï¼ˆå‰ç§¯å¼‚å·ï¼‰ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
                if (edgeCross >= 0) {
                    // å‡¸è§’ï¼šç‚¹å‡»ç‚¹åº”è¯¥åœ¨ä¸¤ä¸ªè¾¹å‘é‡ä¹‹é—´
                    return (cross1 >= 0 && cross2 <= 0) || (cross1 <= 0 && cross2 >= 0);
                } else {
                    // å‡¹è§’ï¼šç‚¹å‡»ç‚¹ä¸åº”è¯¥åœ¨ä¸¤ä¸ªè¾¹å‘é‡çš„å¤–ä¾§
                    return !(cross1 < 0 && cross2 < 0) && !(cross1 > 0 && cross2 > 0);
                }
            }
            
            // åˆ‡æ¢è§’åº¦æ ‡è®°çš„æ˜¾ç¤ºçŠ¶æ€
            toggleAngleMark(angleIndex) {
                const angleKey = `angle${angleIndex}`;
                this.angleMarkVisible[angleKey] = !this.angleMarkVisible[angleKey];
            }
            
        }
        
        class CanvasApp {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.snapIndicator = document.getElementById('snapIndicator');
                
                this.triangles = [];
                this.selectedTriangle = null;
                this.snapThreshold = 20;
                this.currentSnap = null;
                this.sharedVertex = null; // å­˜å‚¨å…±äº«é¡¶ç‚¹ä¿¡æ¯
                this.persistentSharedVertices = []; // å­˜å‚¨æŒä¹…åŒ–çš„é‡åˆé¡¶ç‚¹ä¿¡æ¯
                
                // è§’åº¦å¸é™„é…ç½®
                this.angleSnapThreshold = 5; // è§’åº¦å¸é™„é˜ˆå€¼ï¼ˆåº¦ï¼‰
                this.snapAngles = [0, 15,30, 45, 60,75, 90, 105,120, 135, 150,165, 180,195, 210, 225, 240,255, 270,285, 300, 315, 330,345]; // ç‰¹æ®Šè§’åº¦
                
                this.setupCanvas();
                this.createTriangles();
                this.setupEventListeners();
                this.animate();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                // è·å–è®¾å¤‡åƒç´ æ¯”ï¼Œæ”¯æŒé«˜DPIæ˜¾ç¤º
                const dpr = window.devicePixelRatio || 1;
                
                // è®¾ç½®ç”»å¸ƒçš„å®é™…å°ºå¯¸
                this.canvas.width = window.innerWidth * dpr;
                this.canvas.height = window.innerHeight * dpr;
                
                // è®¾ç½®ç”»å¸ƒçš„æ˜¾ç¤ºå°ºå¯¸
                this.canvas.style.width = window.innerWidth + 'px';
                this.canvas.style.height = window.innerHeight + 'px';
                
                // ç¼©æ”¾ç”»å¸ƒä¸Šä¸‹æ–‡ä»¥åŒ¹é…è®¾å¤‡åƒç´ æ¯”
                this.ctx.scale(dpr, dpr);
            }
            
            createTriangles() {
                // è·å–æ˜¾ç¤ºå°ºå¯¸ï¼ˆè€Œéå®é™…ç”»å¸ƒå°ºå¯¸ï¼Œé¿å…devicePixelRatioå½±å“ï¼‰
                const displayWidth = window.innerWidth;
                const displayHeight = window.innerHeight;
                
                // è®¡ç®—åˆé€‚çš„ä¸‰è§’å½¢å¤§å°ï¼Œå……åˆ†åˆ©ç”¨çª—å£ç©ºé—´
                const windowSize = Math.min(displayWidth, displayHeight);
                const triangleSize = windowSize * 0.3; // 30-60-90ä¸‰è§’å½¢ä¿æŒåŸå¤§å°
                const rightTriangleSize = windowSize * 0.34; // 45-45-90ä¸‰è§’å½¢å¢å¤§åˆ°35%
                
                // è®¡ç®—ä¸‰è§’å½¢é—´è·ï¼Œä½¿ä¸¤ä¸ªä¸‰è§’å½¢çš„é‡å¿ƒåœ¨æ°´å¹³å±…ä¸­ä¸¤ä¾§
                const spacing = windowSize * 0.55; // ä¸¤ä¸ªä¸‰è§’å½¢é‡å¿ƒä¹‹é—´çš„è·ç¦»
                const centerX = displayWidth * 0.4; // çª—å£æ°´å¹³ä¸­å¿ƒ
                const centerY = displayHeight * 0.75; // çª—å£å‚ç›´ä¸­å¿ƒ
                
                // åˆ›å»º30-60-90åº¦ä¸‰è§’å½¢ï¼Œé‡å¿ƒä½äºå·¦ä¾§
                const triangle1 = new Triangle(
                    centerX - spacing / 2,
                    centerY,
                    triangleSize,
                    0,
                    '30-60-90'
                );
                
                // åˆ›å»º45-45-90åº¦ä¸‰è§’å½¢ï¼Œé‡å¿ƒä½äºå³ä¾§
                const triangle2 = new Triangle(
                    centerX + spacing / 2,
                    centerY,
                    rightTriangleSize,
                    0,
                    '45-45-90'
                );
                
                this.triangles = [triangle1, triangle2];
            }
            
            setupEventListeners() {
                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // è§¦æ‘¸å±äº‹ä»¶
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                
                // é˜²æ­¢è§¦æ‘¸æ—¶çš„é»˜è®¤è¡Œä¸ºï¼ˆå¦‚æ»šåŠ¨ï¼‰
                this.canvas.addEventListener('touchstart', (e) => e.preventDefault());
                this.canvas.addEventListener('touchmove', (e) => e.preventDefault());
                this.canvas.addEventListener('touchend', (e) => e.preventDefault());
                
                // éšæœºæŒ‰é’®äº‹ä»¶
                const randomButton = document.getElementById('randomButton');
                randomButton.addEventListener('click', () => this.randomSnap());
            }
            
            // æ£€æµ‹è§’åº¦å¸é™„
            checkAngleSnapping(angle) {
                // å°†è§’åº¦è½¬æ¢ä¸ºåº¦æ•°å¹¶æ ‡å‡†åŒ–åˆ°0-360èŒƒå›´
                let angleDegrees = (angle * 180 / Math.PI) % 360;
                if (angleDegrees < 0) angleDegrees += 360;
                
                // æ£€æŸ¥æ˜¯å¦æ¥è¿‘ä»»ä½•ç‰¹æ®Šè§’åº¦
                for (let snapAngle of this.snapAngles) {
                    let diff = Math.abs(angleDegrees - snapAngle);
                    // å¤„ç†è·¨è¶Š0åº¦çš„æƒ…å†µ
                    if (diff > 180) diff = 360 - diff;
                    
                    if (diff <= this.angleSnapThreshold) {
                        return snapAngle * Math.PI / 180; // è¿”å›å¼§åº¦å€¼
                    }
                }
                
                return null; // æ²¡æœ‰æ‰¾åˆ°å¸é™„è§’åº¦
            }
            
            // æ£€æµ‹ä¸¤ä¸ªä¸‰è§’å½¢æ˜¯å¦æœ‰å…±äº«é¡¶ç‚¹
            findSharedVertex() {
                if (this.triangles.length < 2) return null;
                
                const threshold = 5; // é¡¶ç‚¹é‡åˆçš„é˜ˆå€¼è·ç¦»
                
                for (let i = 0; i < this.triangles.length; i++) {
                    for (let j = i + 1; j < this.triangles.length; j++) {
                        const triangle1 = this.triangles[i];
                        const triangle2 = this.triangles[j];
                        
                        // æ£€æŸ¥æ¯ä¸ªé¡¶ç‚¹æ˜¯å¦ä¸å¦ä¸€ä¸ªä¸‰è§’å½¢çš„é¡¶ç‚¹é‡åˆ
                        for (let v1 = 0; v1 < triangle1.vertices.length; v1++) {
                            for (let v2 = 0; v2 < triangle2.vertices.length; v2++) {
                                const vertex1 = triangle1.vertices[v1];
                                const vertex2 = triangle2.vertices[v2];
                                
                                const distance = Math.sqrt(
                                    (vertex1.x - vertex2.x) ** 2 + 
                                    (vertex1.y - vertex2.y) ** 2
                                );
                                
                                if (distance <= threshold) {
                                    return {
                                        triangle1: triangle1,
                                        triangle2: triangle2,
                                        vertex1Index: v1,
                                        vertex2Index: v2,
                                        sharedPoint: {
                                            x: (vertex1.x + vertex2.x) / 2,
                                            y: (vertex1.y + vertex2.y) / 2
                                        }
                                    };
                                }
                            }
                        }
                    }
                }
                
                return null;
            }
            
            // æ›´æ–°æŒä¹…åŒ–çš„é‡åˆé¡¶ç‚¹åˆ—è¡¨
            updatePersistentSharedVertices() {
                this.persistentSharedVertices = [];
                const threshold = 5; // é¡¶ç‚¹é‡åˆçš„é˜ˆå€¼è·ç¦»
                
                for (let i = 0; i < this.triangles.length; i++) {
                    for (let j = i + 1; j < this.triangles.length; j++) {
                        const triangle1 = this.triangles[i];
                        const triangle2 = this.triangles[j];
                        
                        // æ£€æŸ¥æ¯ä¸ªé¡¶ç‚¹æ˜¯å¦ä¸å¦ä¸€ä¸ªä¸‰è§’å½¢çš„é¡¶ç‚¹é‡åˆ
                        for (let v1 = 0; v1 < triangle1.vertices.length; v1++) {
                            for (let v2 = 0; v2 < triangle2.vertices.length; v2++) {
                                const vertex1 = triangle1.vertices[v1];
                                const vertex2 = triangle2.vertices[v2];
                                
                                const distance = Math.sqrt(
                                    (vertex1.x - vertex2.x) ** 2 + 
                                    (vertex1.y - vertex2.y) ** 2
                                );
                                
                                if (distance <= threshold) {
                                    this.persistentSharedVertices.push({
                                        triangle1: triangle1,
                                        triangle2: triangle2,
                                        vertex1Index: v1,
                                        vertex2Index: v2,
                                        sharedPoint: {
                                            x: (vertex1.x + vertex2.x) / 2,
                                            y: (vertex1.y + vertex2.y) / 2
                                        }
                                    });
                                }
                            }
                        }
                    }
                }
            }
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            getTouchPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const touch = e.touches[0] || e.changedTouches[0];
                return {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
            }
            
            handleMouseDown(e) {
                const pos = this.getMousePos(e);
                const isShiftPressed = e.shiftKey;
                
                // é¦–å…ˆæ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†æ—‹è½¬æŒ‰é’®
                let rotationButtonClicked = false;
                for (let triangle of this.triangles) {
                    if (triangle.isPointInRotationButton(pos.x, pos.y)) {
                        // ç‚¹å‡»äº†æ—‹è½¬æŒ‰é’®
                        this.triangles.forEach(t => {
                            t.selected = false;
                            t.rotationButtonNeedsRecalc = true;  // é‡æ–°é€‰æ‹©æ—¶éœ€è¦é‡æ–°è®¡ç®—æŒ‰é’®ä½ç½®
                        });
                        triangle.selected = true;
                        triangle.rotationButtonNeedsRecalc = true;  // æ–°é€‰ä¸­çš„ä¸‰è§’å½¢éœ€è¦é‡æ–°è®¡ç®—æŒ‰é’®ä½ç½®
                        this.selectedTriangle = triangle;
                        triangle.rotating = true;
                        
                        // æ£€æŸ¥æ˜¯å¦æœ‰å…±äº«é¡¶ç‚¹æ¥ç¡®å®šæ—‹è½¬ä¸­å¿ƒ
                        this.sharedVertex = this.findSharedVertex();
                        let rotationCenterX, rotationCenterY;
                        
                        if (this.sharedVertex && 
                            (this.sharedVertex.triangle1 === triangle || 
                             this.sharedVertex.triangle2 === triangle)) {
                            // å¦‚æœæœ‰å…±äº«é¡¶ç‚¹ï¼Œä»¥å…±äº«é¡¶ç‚¹ä¸ºæ—‹è½¬ä¸­å¿ƒ
                            rotationCenterX = this.sharedVertex.sharedPoint.x;
                            rotationCenterY = this.sharedVertex.sharedPoint.y;
                            // è®°å½•å±€éƒ¨æ—‹è½¬æ¢è½´ä¸ºå¯¹åº”çš„æœ¬åœ°é¡¶ç‚¹
                            const lv = this.getLocalVerticesFor(triangle);
                            const idx = (this.sharedVertex.triangle1 === triangle) ? this.sharedVertex.vertex1Index : this.sharedVertex.vertex2Index;
                            triangle.rotationPivotLocal = lv[idx];
                            // é”å®šä¸–ç•Œæ¢è½´
                            triangle.rotationCenterWorldX = rotationCenterX;
                            triangle.rotationCenterWorldY = rotationCenterY;
                        } else {
                            // å¦åˆ™ä»¥ä¸‰è§’å½¢ä¸­å¿ƒä¸ºæ—‹è½¬ä¸­å¿ƒ
                            rotationCenterX = triangle.centerX;
                            rotationCenterY = triangle.centerY;
                            // è®°å½•å±€éƒ¨æ—‹è½¬æ¢è½´ä¸ºé‡å¿ƒ
                            triangle.rotationPivotLocal = this.getLocalCentroidFor(triangle);
                            // é”å®šä¸–ç•Œæ¢è½´
                            triangle.rotationCenterWorldX = rotationCenterX;
                            triangle.rotationCenterWorldY = rotationCenterY;
                        }
                        
                        triangle.rotationStart = Math.atan2(
                            pos.y - rotationCenterY,
                            pos.x - rotationCenterX
                        );
                        triangle.angleStart = triangle.angle;
                        rotationButtonClicked = true;
                        break;
                    }
                }
                
                if (rotationButtonClicked) return;
                
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†è§’åº¦åŒºåŸŸ
                let angleClicked = false;
                for (let triangle of this.triangles) {
                    for (let i = 0; i < 3; i++) {
                        if (triangle.isPointInAngleArea(pos.x, pos.y, i)) {
                            triangle.toggleAngleMark(i);
                            angleClicked = true;
                            break;
                        }
                    }
                    if (angleClicked) break;
                }
                
                if (angleClicked) return;
                
                // æŸ¥æ‰¾è¢«ç‚¹å‡»çš„ä¸‰è§’å½¢
                let clickedTriangle = null;
                for (let i = this.triangles.length - 1; i >= 0; i--) {
                    if (this.triangles[i].containsPoint(pos.x, pos.y)) {
                        clickedTriangle = this.triangles[i];
                        break;
                    }
                }
                
                // å–æ¶ˆä¹‹å‰çš„é€‰æ‹©
                this.triangles.forEach(t => {
                    t.selected = false;
                    t.rotationButtonNeedsRecalc = true;  // é‡æ–°é€‰æ‹©æ—¶éœ€è¦é‡æ–°è®¡ç®—æŒ‰é’®ä½ç½®
                });
                
                if (clickedTriangle) {
                    clickedTriangle.selected = true;
                    clickedTriangle.rotationButtonNeedsRecalc = true;  // æ–°é€‰ä¸­çš„ä¸‰è§’å½¢éœ€è¦é‡æ–°è®¡ç®—æŒ‰é’®ä½ç½®
                    this.selectedTriangle = clickedTriangle;
                    
                    if (isShiftPressed) {
                        // æ—‹è½¬æ¨¡å¼
                        clickedTriangle.rotating = true;
                        
                        // ä½¿ç”¨å…¬å…±å‡½æ•°åˆå§‹åŒ–æ—‹è½¬
                        this.initializeRotation(clickedTriangle, pos);
                    } else {
                        // æ‹–åŠ¨æ¨¡å¼
                        clickedTriangle.dragging = true;
                        clickedTriangle.dragOffset = {
                            x: pos.x - clickedTriangle.x,
                            y: pos.y - clickedTriangle.y
                        };
                    }
                } else {
                    this.selectedTriangle = null;
                }
            }
            
            handleMouseMove(e) {
                const pos = this.getMousePos(e);
                
                if (this.selectedTriangle) {
                    if (this.selectedTriangle.dragging) {
                        // æ‹–åŠ¨ä¸‰è§’å½¢
                        const newX = pos.x - this.selectedTriangle.dragOffset.x;
                        const newY = pos.y - this.selectedTriangle.dragOffset.y;
                        
                        // æ£€æŸ¥å¸é™„
                        const snap = this.checkSnapping(this.selectedTriangle, newX, newY);
                        
                        if (snap) {
                            this.selectedTriangle.x = snap.x;
                            this.selectedTriangle.y = snap.y;
                            this.currentSnap = snap;
                            this.showSnapIndicator(snap.snapPoint);
                        } else {
                            this.selectedTriangle.x = newX;
                            this.selectedTriangle.y = newY;
                            this.currentSnap = null;
                            this.hideSnapIndicator();
                        }
                        
                        this.selectedTriangle.updateVertices();
                        // å®æ—¶æ›´æ–°æŒä¹…åŒ–é‡åˆé¡¶ç‚¹
                        this.updatePersistentSharedVertices();
                        
                    } else if (this.selectedTriangle.rotating) {
                        // æ—‹è½¬è¿‡ç¨‹ä¸­ä¸å†åˆ‡æ¢æ¢è½´ï¼Œä½¿ç”¨å¼€å§‹æ—¶é”å®šçš„ä¸–ç•Œæ¢è½´
                        const rotationCenterX = this.selectedTriangle.rotationCenterWorldX ?? this.selectedTriangle.centerX;
                        const rotationCenterY = this.selectedTriangle.rotationCenterWorldY ?? this.selectedTriangle.centerY;
                        
                        const currentAngle = Math.atan2(
                            pos.y - rotationCenterY,
                            pos.x - rotationCenterX
                        );
                        const deltaAngle = currentAngle - this.selectedTriangle.rotationStart;
                        // ä½¿ç”¨è®°å½•çš„å±€éƒ¨æ¢è½´æ—‹è½¬ï¼Œä¿æŒè¯¥ç‚¹ä¸åŠ¨
                        const pivotLocal = this.selectedTriangle.rotationPivotLocal || this.getLocalCentroidFor(this.selectedTriangle);
                        this.rotateTriangleAroundPivot(
                            this.selectedTriangle,
                            rotationCenterX,
                            rotationCenterY,
                            deltaAngle,
                            pivotLocal
                        );
                        // å®æ—¶æ›´æ–°æŒä¹…åŒ–é‡åˆé¡¶ç‚¹
                        this.updatePersistentSharedVertices();
                    }
                }
            }
            
            // å›´ç»•æŒ‡å®šç‚¹æ—‹è½¬ä¸‰è§’å½¢
            rotateTriangleAroundPoint(triangle, pivotX, pivotY, deltaAngle) {
                // è®¡ç®—ä¸‰è§’å½¢ä¸­å¿ƒç›¸å¯¹äºæ—‹è½¬ç‚¹çš„ä½ç½®
                const centerX = triangle.centerX;
                const centerY = triangle.centerY;
                
                // è®¡ç®—ä¸­å¿ƒç‚¹ç›¸å¯¹äºæ—‹è½¬ç‚¹çš„å‘é‡
                const dx = centerX - pivotX;
                const dy = centerY - pivotY;
                
                // æ—‹è½¬ä¸­å¿ƒç‚¹ä½ç½®
                const cos = Math.cos(deltaAngle);
                const sin = Math.sin(deltaAngle);
                
                const newCenterX = pivotX + (dx * cos - dy * sin);
                const newCenterY = pivotY + (dx * sin + dy * cos);
                
                // æ›´æ–°ä¸‰è§’å½¢ä½ç½®å’Œè§’åº¦
                triangle.x = newCenterX;
                triangle.y = newCenterY;
                triangle.angle = triangle.angleStart + deltaAngle;
                
                // æ›´æ–°é¡¶ç‚¹
                triangle.updateVertices();
            }

            // åˆå§‹åŒ–ä¸‰è§’å½¢çš„æ—‹è½¬å‚æ•°
            initializeRotation(triangle, pos) {
                // æ£€æŸ¥æ˜¯å¦æœ‰å…±äº«é¡¶ç‚¹æ¥ç¡®å®šæ—‹è½¬ä¸­å¿ƒ
                this.sharedVertex = this.findSharedVertex();
                let rotationCenterX, rotationCenterY;
                
                if (this.sharedVertex && 
                    (this.sharedVertex.triangle1 === triangle || 
                     this.sharedVertex.triangle2 === triangle)) {
                    // å¦‚æœæœ‰å…±äº«é¡¶ç‚¹ï¼Œä»¥å…±äº«é¡¶ç‚¹ä¸ºæ—‹è½¬ä¸­å¿ƒ
                    rotationCenterX = this.sharedVertex.sharedPoint.x;
                    rotationCenterY = this.sharedVertex.sharedPoint.y;
                    // è®°å½•å±€éƒ¨æ—‹è½¬æ¢è½´ä¸ºå¯¹åº”çš„æœ¬åœ°é¡¶ç‚¹
                    const lv = this.getLocalVerticesFor(triangle);
                    const idx = (this.sharedVertex.triangle1 === triangle) ? this.sharedVertex.vertex1Index : this.sharedVertex.vertex2Index;
                    triangle.rotationPivotLocal = lv[idx];
                } else {
                    // å¦åˆ™ä»¥ä¸‰è§’å½¢ä¸­å¿ƒä¸ºæ—‹è½¬ä¸­å¿ƒ
                    rotationCenterX = triangle.centerX;
                    rotationCenterY = triangle.centerY;
                    // è®°å½•å±€éƒ¨æ—‹è½¬æ¢è½´ä¸ºé‡å¿ƒ
                    triangle.rotationPivotLocal = this.getLocalCentroidFor(triangle);
                }
                
                // é”å®šä¸–ç•Œæ¢è½´
                triangle.rotationCenterWorldX = rotationCenterX;
                triangle.rotationCenterWorldY = rotationCenterY;
                
                // è®¾ç½®æ—‹è½¬èµ·å§‹è§’åº¦
                triangle.rotationStart = Math.atan2(
                    pos.y - rotationCenterY,
                    pos.x - rotationCenterX
                );
                triangle.angleStart = triangle.angle;
                
                return { rotationCenterX, rotationCenterY };
            }

            // è·å–ä¸ä¸‰è§’å½¢ç±»å‹åŒ¹é…çš„å±€éƒ¨é¡¶ç‚¹åæ ‡ï¼ˆä»¥ç›´è§’é¡¶ç‚¹ä¸ºåŸç‚¹ï¼‰
            getLocalVerticesFor(triangle) {
                if (triangle.type === '30-60-90') {
                    const shortSide = triangle.size;
                    const longSide = triangle.size * Math.sqrt(3);
                    return [
                        { x: 0, y: -longSide }, // é¡¶éƒ¨
                        { x: 0, y: 0 },         // å·¦ä¸‹ï¼ˆç›´è§’ï¼‰
                        { x: shortSide, y: 0 }  // å³ä¸‹
                    ];
                } else if (triangle.type === '45-45-90') {
                    const leg = triangle.size;
                    return [
                        { x: 0, y: -leg },      // é¡¶éƒ¨
                        { x: 0, y: 0 },         // å·¦ä¸‹ï¼ˆç›´è§’ï¼‰
                        { x: leg, y: 0 }        // å³ä¸‹
                    ];
                }
                return [{x:0,y:0},{x:0,y:0},{x:0,y:0}];
            }

            // è·å–å±€éƒ¨é‡å¿ƒï¼ˆé¡¶ç‚¹å¹³å‡å€¼ï¼Œå±€éƒ¨åæ ‡ç³»ï¼‰
            getLocalCentroidFor(triangle) {
                const lv = this.getLocalVerticesFor(triangle);
                return {
                    x: (lv[0].x + lv[1].x + lv[2].x) / 3,
                    y: (lv[0].y + lv[1].y + lv[2].y) / 3
                };
            }

            // æŒ‰å±€éƒ¨æ¢è½´ç»•æŒ‡å®šä¸–ç•Œæ¢è½´æ—‹è½¬ï¼Œä¿æŒè¯¥å±€éƒ¨ç‚¹ä¸åŠ¨
            rotateTriangleAroundPivot(triangle, pivotX, pivotY, deltaAngle, pivotLocal) {
                let newAngle = triangle.angleStart + deltaAngle;
                
                // æ£€æŸ¥è§’åº¦å¸é™„ï¼ˆé€‚ç”¨äºæ‰€æœ‰æ—‹è½¬æ¨¡å¼ï¼ŒåŒ…æ‹¬å…±äº«é¡¶ç‚¹æ—‹è½¬ï¼‰
                const snappedAngle = this.checkAngleSnapping(newAngle);
                if (snappedAngle !== null) {
                    newAngle = snappedAngle;
                }
                
                const cos = Math.cos(newAngle);
                const sin = Math.sin(newAngle);

                // å°†å±€éƒ¨æ¢è½´æ—‹è½¬åˆ°ä¸–ç•Œåæ ‡çš„ç›¸å¯¹å‘é‡
                const rotatedLocalX = pivotLocal.x * cos - pivotLocal.y * sin;
                const rotatedLocalY = pivotLocal.x * sin + pivotLocal.y * cos;

                // è®¡ç®—æ–°çš„é”šç‚¹ä½ç½®ï¼Œä½¿å¾—è¯¥å±€éƒ¨æ¢è½´å¯¹åº”çš„ä¸–ç•Œåæ ‡ç­‰äºæŒ‡å®šæ—‹è½¬ä¸­å¿ƒ
                const newAnchorX = pivotX - rotatedLocalX;
                const newAnchorY = pivotY - rotatedLocalY;

                triangle.x = newAnchorX;
                triangle.y = newAnchorY;
                triangle.angle = newAngle;
                triangle.updateVertices();
            }
            
            handleMouseUp(e) {
                if (this.selectedTriangle) {
                    this.selectedTriangle.dragging = false;
                    this.selectedTriangle.rotating = false;
                }
                this.hideSnapIndicator();
            }
            
            // è§¦æ‘¸äº‹ä»¶å¤„ç†æ–¹æ³•
            handleTouchStart(e) {
                const pos = this.getTouchPos(e);
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯é•¿æŒ‰ï¼ˆç”¨äºæ—‹è½¬æ¨¡å¼ï¼‰
                this.touchStartTime = Date.now();
                this.touchStartPos = pos;
                
                // è®¾ç½®é•¿æŒ‰å®šæ—¶å™¨ï¼ˆ500msåè¿›å…¥æ—‹è½¬æ¨¡å¼ï¼‰
                this.longPressTimer = setTimeout(() => {
                    this.isLongPress = true;
                    // è§¦å‘æ—‹è½¬æ¨¡å¼çš„é€»è¾‘ï¼Œç±»ä¼¼äºShift+ç‚¹å‡»
                    this.handleTouchDown(pos, true);
                }, 500);
                
                // ç«‹å³å¤„ç†æ™®é€šç‚¹å‡»
                this.handleTouchDown(pos, false);
            }
            
            handleTouchMove(e) {
                const pos = this.getTouchPos(e);
                
                // å¦‚æœç§»åŠ¨è·ç¦»è¶…è¿‡é˜ˆå€¼ï¼Œå–æ¶ˆé•¿æŒ‰
                if (this.touchStartPos) {
                    const distance = Math.sqrt(
                        (pos.x - this.touchStartPos.x) ** 2 + 
                        (pos.y - this.touchStartPos.y) ** 2
                    );
                    if (distance > 10) {
                        clearTimeout(this.longPressTimer);
                        this.isLongPress = false;
                    }
                }
                
                // å¤„ç†ç§»åŠ¨é€»è¾‘ï¼Œç±»ä¼¼äºhandleMouseMove
                if (this.selectedTriangle) {
                    if (this.selectedTriangle.dragging) {
                        // æ‹–åŠ¨ä¸‰è§’å½¢
                        const newX = pos.x - this.selectedTriangle.dragOffset.x;
                        const newY = pos.y - this.selectedTriangle.dragOffset.y;
                        
                        // æ£€æŸ¥å¸é™„
                        const snap = this.checkSnapping(this.selectedTriangle, newX, newY);
                        
                        if (snap) {
                            this.selectedTriangle.x = snap.x;
                            this.selectedTriangle.y = snap.y;
                            this.currentSnap = snap;
                            this.showSnapIndicator(snap.snapPoint);
                        } else {
                            this.selectedTriangle.x = newX;
                            this.selectedTriangle.y = newY;
                            this.currentSnap = null;
                            this.hideSnapIndicator();
                        }
                        
                        this.selectedTriangle.updateVertices();
                        // å®æ—¶æ›´æ–°æŒä¹…åŒ–é‡åˆé¡¶ç‚¹
                        this.updatePersistentSharedVertices();
                        
                    } else if (this.selectedTriangle.rotating) {
                        // æ—‹è½¬è¿‡ç¨‹ä¸­ä¸å†åˆ‡æ¢æ¢è½´ï¼Œä½¿ç”¨å¼€å§‹æ—¶é”å®šçš„ä¸–ç•Œæ¢è½´
                        const rotationCenterX = this.selectedTriangle.rotationCenterWorldX ?? this.selectedTriangle.centerX;
                        const rotationCenterY = this.selectedTriangle.rotationCenterWorldY ?? this.selectedTriangle.centerY;
                        
                        const currentAngle = Math.atan2(
                            pos.y - rotationCenterY,
                            pos.x - rotationCenterX
                        );
                        const deltaAngle = currentAngle - this.selectedTriangle.rotationStart;
                        // ä½¿ç”¨è®°å½•çš„å±€éƒ¨æ¢è½´æ—‹è½¬ï¼Œä¿æŒè¯¥ç‚¹ä¸åŠ¨
                        const pivotLocal = this.selectedTriangle.rotationPivotLocal || this.getLocalCentroidFor(this.selectedTriangle);
                        this.rotateTriangleAroundPivot(
                            this.selectedTriangle,
                            rotationCenterX,
                            rotationCenterY,
                            deltaAngle,
                            pivotLocal
                        );
                        // å®æ—¶æ›´æ–°æŒä¹…åŒ–é‡åˆé¡¶ç‚¹
                        this.updatePersistentSharedVertices();
                    }
                }
            }
            
            handleTouchEnd(e) {
                // æ¸…é™¤é•¿æŒ‰å®šæ—¶å™¨
                clearTimeout(this.longPressTimer);
                this.isLongPress = false;
                this.touchStartTime = null;
                this.touchStartPos = null;
                
                // ç»“æŸæ‹–åŠ¨å’Œæ—‹è½¬
                if (this.selectedTriangle) {
                    this.selectedTriangle.dragging = false;
                    this.selectedTriangle.rotating = false;
                }
                this.hideSnapIndicator();
            }
            
            handleTouchDown(pos, isRotationMode) {
                // é¦–å…ˆæ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†æ—‹è½¬æŒ‰é’®
                let rotationButtonClicked = false;
                for (let triangle of this.triangles) {
                    if (triangle.isPointInRotationButton(pos.x, pos.y)) {
                        // ç‚¹å‡»äº†æ—‹è½¬æŒ‰é’®
                        triangle.selected = true;
                        triangle.rotationButtonNeedsRecalc = true;  // æ–°é€‰ä¸­çš„ä¸‰è§’å½¢éœ€è¦é‡æ–°è®¡ç®—æŒ‰é’®ä½ç½®
                        this.selectedTriangle = triangle;
                        triangle.rotating = true;
                        
                        // ä½¿ç”¨å…¬å…±å‡½æ•°åˆå§‹åŒ–æ—‹è½¬
                        this.initializeRotation(triangle, pos);
                        
                        rotationButtonClicked = true;
                        break;
                    }
                }
                
                if (rotationButtonClicked) return;
                
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†è§’åº¦åŒºåŸŸ
                let angleClicked = false;
                for (let triangle of this.triangles) {
                    for (let i = 0; i < 3; i++) {
                        if (triangle.isPointInAngleArea(pos.x, pos.y, i)) {
                            triangle.toggleAngleMark(i);
                            angleClicked = true;
                            break;
                        }
                    }
                    if (angleClicked) break;
                }
                
                if (angleClicked) return;
                
                // æŸ¥æ‰¾è¢«ç‚¹å‡»çš„ä¸‰è§’å½¢
                let clickedTriangle = null;
                for (let i = this.triangles.length - 1; i >= 0; i--) {
                    if (this.triangles[i].containsPoint(pos.x, pos.y)) {
                        clickedTriangle = this.triangles[i];
                        break;
                    }
                }
                
                // å–æ¶ˆä¹‹å‰çš„é€‰æ‹©
                this.triangles.forEach(t => {
                    t.selected = false;
                    t.rotationButtonNeedsRecalc = true;  // é‡æ–°é€‰æ‹©æ—¶éœ€è¦é‡æ–°è®¡ç®—æŒ‰é’®ä½ç½®
                });
                
                if (clickedTriangle) {
                    clickedTriangle.selected = true;
                    clickedTriangle.rotationButtonNeedsRecalc = true;  // æ–°é€‰ä¸­çš„ä¸‰è§’å½¢éœ€è¦é‡æ–°è®¡ç®—æŒ‰é’®ä½ç½®
                    this.selectedTriangle = clickedTriangle;
                    
                    if (isRotationMode) {
                        // æ—‹è½¬æ¨¡å¼ï¼ˆé•¿æŒ‰è§¦å‘ï¼‰
                        clickedTriangle.rotating = true;
                        
                        // ä½¿ç”¨å…¬å…±å‡½æ•°åˆå§‹åŒ–æ—‹è½¬
                        this.initializeRotation(clickedTriangle, pos);
                    } else {
                        // æ‹–åŠ¨æ¨¡å¼
                        clickedTriangle.dragging = true;
                        clickedTriangle.dragOffset = {
                            x: pos.x - clickedTriangle.x,
                            y: pos.y - clickedTriangle.y
                        };
                    }
                } else {
                    this.selectedTriangle = null;
                }
            }
            
            checkSnapping(triangle, newX, newY) {
                const tempTriangle = new Triangle(newX, newY, triangle.size, triangle.angle, triangle.type);
                
                // æ£€æŸ¥ä¸å…¶ä»–ä¸‰è§’å½¢çš„å¸é™„
                for (let other of this.triangles) {
                    if (other === triangle) continue;
                    
                    // åªè¿›è¡Œé¡¶ç‚¹ä¸é¡¶ç‚¹ä¹‹é—´çš„å¸é™„
                    for (let vertex of tempTriangle.vertices) {
                        const closestVertex = other.getClosestVertex(vertex.x, vertex.y, this.snapThreshold);
                        if (closestVertex) {
                            const offsetX = closestVertex.vertex.x - vertex.x;
                            const offsetY = closestVertex.vertex.y - vertex.y;
                            return {
                                x: newX + offsetX,
                                y: newY + offsetY,
                                type: 'vertex',
                                snapPoint: closestVertex.vertex
                            };
                        }
                    }
                }
                
                return null;
            }
            
            showSnapIndicator(point) {
                this.snapIndicator.style.left = point.x + 'px';
                this.snapIndicator.style.top = point.y + 'px';
                this.snapIndicator.classList.add('active');
            }
            
            hideSnapIndicator() {
                this.snapIndicator.classList.remove('active');
            }
            
            draw() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // æ·»åŠ èƒŒæ™¯è‰²
                this.ctx.fillStyle = '#efefef';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ä¸ç»˜åˆ¶ç½‘æ ¼ï¼ˆå·²éšè—ï¼‰
                //this.drawGrid();
                
                // ç»˜åˆ¶æ‰€æœ‰ä¸‰è§’å½¢
                this.triangles.forEach(triangle => triangle.draw(this.ctx));
                
                // ç»˜åˆ¶æŒä¹…åŒ–çš„é‡åˆé¡¶ç‚¹çº¢è‰²å°ç‚¹
                this.drawPersistentSharedVertices();
            }
            
            // ç»˜åˆ¶æŒä¹…åŒ–çš„é‡åˆé¡¶ç‚¹çº¢è‰²å°ç‚¹
            drawPersistentSharedVertices() {
                this.persistentSharedVertices.forEach(sharedVertex => {
                    const point = sharedVertex.sharedPoint;
                    
                    // ç»˜åˆ¶çº¢è‰²å°ç‚¹
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                    this.ctx.fillStyle = '#ff4444';
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                });
            }
            
            drawGrid() {
                const gridSize = 50;
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }
            
            animate() {
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
            
            // éšæœºæ‹¼æ¥åŠŸèƒ½ - åŒä¸‰è§’å½¢åŒæ—¶ç§»åŠ¨åˆ°ä¸­å¿ƒåŒºåŸŸ
            randomSnap() {
                if (this.triangles.length < 2) return;
                
                // ç¦ç”¨æŒ‰é’®é˜²æ­¢é‡å¤ç‚¹å‡»
                const randomButton = document.getElementById('randomButton');
                randomButton.disabled = true;
                
                // è·å–ä¸¤ä¸ªä¸‰è§’å½¢
                const triangle1 = this.triangles[0];
                const triangle2 = this.triangles[1];
                
                // éšæœºé€‰æ‹©æ¯ä¸ªä¸‰è§’å½¢çš„ä¸€ä¸ªé¡¶ç‚¹è¿›è¡Œæ‹¼æ¥
                const vertex1Index = Math.floor(Math.random() * 3);
                const vertex2Index = Math.floor(Math.random() * 3);
                
                // è®¡ç®—çª—å£ä¸­å¿ƒåŒºåŸŸçš„æ‹¼æ¥ç‚¹
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                // æ·»åŠ ä¸€äº›éšæœºåç§»ï¼Œè®©æ‹¼æ¥ç‚¹åœ¨ä¸­å¿ƒåŒºåŸŸå†…å˜åŒ–
                const offsetRange = 100; // ä¸­å¿ƒåŒºåŸŸèŒƒå›´
                const snapPointX = centerX + (Math.random() - 0.5) * offsetRange;
                const snapPointY = centerY + (Math.random() - 0.5) * offsetRange;
                
                // è®¡ç®—ä¸¤ä¸ªä¸‰è§’å½¢çš„ç›®æ ‡è§’åº¦ï¼ˆè¾¹å¯¹è¾¹æ‹¼æ¥ï¼‰
                const alignmentAngles = this.calculateDualAlignmentAngles(triangle1, triangle2, vertex1Index, vertex2Index);
                
                // å¼€å§‹åŒä¸‰è§’å½¢åŒæ—¶åŠ¨ç”»
                this.animateDualRandomSnap(
                    triangle1, triangle2, 
                    vertex1Index, vertex2Index,
                    snapPointX, snapPointY,
                    alignmentAngles.angle1, alignmentAngles.angle2,
                    randomButton
                );
            }
            
            // åŒä¸‰è§’å½¢åŒæ—¶åŠ¨ç”»åˆ°ä¸­å¿ƒåŒºåŸŸæ‹¼æ¥
            animateDualRandomSnap(triangle1, triangle2, vertex1Index, vertex2Index, snapPointX, snapPointY, targetAngle1, targetAngle2, button) {
                const startTime = Date.now();
                const duration = 1500; // åŠ¨ç”»æŒç»­æ—¶é—´1.5ç§’
                
                // è®°å½•ä¸¤ä¸ªä¸‰è§’å½¢çš„åˆå§‹çŠ¶æ€
                const start1 = { x: triangle1.x, y: triangle1.y, angle: triangle1.angle };
                const start2 = { x: triangle2.x, y: triangle2.y, angle: triangle2.angle };
                
                // è®¡ç®—ä¸¤ä¸ªä¸‰è§’å½¢çš„ç›®æ ‡ä½ç½®
                const target1 = this.calculateTriangleTargetPosition(triangle1, vertex1Index, snapPointX, snapPointY, targetAngle1);
                const target2 = this.calculateTriangleTargetPosition(triangle2, vertex2Index, snapPointX, snapPointY, targetAngle2);
                
                // ç¡®ä¿æ‹¼æ¥åçš„ç»„åˆåœ¨çª—å£ä¸­å¿ƒåŒºåŸŸå†…
                const adjustedTargets = this.adjustDualTargetsToCenter(target1, target2, triangle1, triangle2, targetAngle1, targetAngle2);
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
                    const easeProgress = this.easeInOutCubic(progress);
                    
                    // åŒæ—¶åŠ¨ç”»ä¸¤ä¸ªä¸‰è§’å½¢çš„ä½ç½®å’Œè§’åº¦
                    // ä¸‰è§’å½¢1
                    triangle1.x = start1.x + (adjustedTargets.target1.x - start1.x) * easeProgress;
                    triangle1.y = start1.y + (adjustedTargets.target1.y - start1.y) * easeProgress;
                    
                    let angleDiff1 = targetAngle1 - start1.angle;
                    if (angleDiff1 > Math.PI) angleDiff1 -= 2 * Math.PI;
                    if (angleDiff1 < -Math.PI) angleDiff1 += 2 * Math.PI;
                    triangle1.angle = start1.angle + angleDiff1 * easeProgress;
                    triangle1.updateVertices();
                    
                    // ä¸‰è§’å½¢2
                    triangle2.x = start2.x + (adjustedTargets.target2.x - start2.x) * easeProgress;
                    triangle2.y = start2.y + (adjustedTargets.target2.y - start2.y) * easeProgress;
                    
                    let angleDiff2 = targetAngle2 - start2.angle;
                    if (angleDiff2 > Math.PI) angleDiff2 -= 2 * Math.PI;
                    if (angleDiff2 < -Math.PI) angleDiff2 += 2 * Math.PI;
                    triangle2.angle = start2.angle + angleDiff2 * easeProgress;
                    triangle2.updateVertices();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // åŠ¨ç”»å®Œæˆï¼Œæ›´æ–°æŒä¹…åŒ–é‡åˆé¡¶ç‚¹
                        this.updatePersistentSharedVertices();
                        // é‡æ–°å¯ç”¨æŒ‰é’®
                        button.disabled = false;
                    }
                };
                
                animate();
            }
            
            // è®¡ç®—åŒä¸‰è§’å½¢å¯¹é½è§’åº¦
            calculateDualAlignmentAngles(triangle1, triangle2, vertex1Index, vertex2Index) {
                // éšæœºé€‰æ‹©è¦å¯¹é½çš„è¾¹
                const getAdjacentVertices = (index) => [(index + 1) % 3, (index + 2) % 3];
                
                const adjacent1 = getAdjacentVertices(vertex1Index);
                const adjacent2 = getAdjacentVertices(vertex2Index);
                
                const randomEdge1 = Math.floor(Math.random() * 2);
                const randomEdge2 = Math.floor(Math.random() * 2);
                
                const edge1Vertex = adjacent1[randomEdge1];
                const edge2Vertex = adjacent2[randomEdge2];
                
                // è®¡ç®—ç†æƒ³çš„å¯¹é½è§’åº¦ï¼ˆè®©ä¸¤æ¡è¾¹åå‘å¯¹é½ï¼‰
                const localVertices1 = this.getLocalVerticesFor(triangle1);
                const localVertices2 = this.getLocalVerticesFor(triangle2);
                
                const edge1Angle = Math.atan2(
                    localVertices1[edge1Vertex].y - localVertices1[vertex1Index].y,
                    localVertices1[edge1Vertex].x - localVertices1[vertex1Index].x
                );
                
                const edge2Angle = Math.atan2(
                    localVertices2[edge2Vertex].y - localVertices2[vertex2Index].y,
                    localVertices2[edge2Vertex].x - localVertices2[vertex2Index].x
                );
                
                // è®©ä¸¤æ¡è¾¹åå‘å¯¹é½
                const targetAngle1 = -edge1Angle;
                const targetAngle2 = Math.PI - edge2Angle;
                
                return { angle1: targetAngle1, angle2: targetAngle2 };
            }
            
            // è®¡ç®—ä¸‰è§’å½¢ç›®æ ‡ä½ç½®ï¼ˆè®©æŒ‡å®šé¡¶ç‚¹ç§»åŠ¨åˆ°æ‹¼æ¥ç‚¹ï¼‰
            calculateTriangleTargetPosition(triangle, vertexIndex, snapPointX, snapPointY, targetAngle) {
                const localVertices = this.getLocalVerticesFor(triangle);
                const localVertex = localVertices[vertexIndex];
                
                // åº”ç”¨ç›®æ ‡è§’åº¦æ—‹è½¬åˆ°å±€éƒ¨é¡¶ç‚¹
                const cos = Math.cos(targetAngle);
                const sin = Math.sin(targetAngle);
                
                const rotatedLocalVertex = {
                    x: localVertex.x * cos - localVertex.y * sin,
                    y: localVertex.x * sin + localVertex.y * cos
                };
                
                // è®¡ç®—ç›®æ ‡ä½ç½®ï¼ˆè®©æ—‹è½¬åçš„é¡¶ç‚¹ä¸æ‹¼æ¥ç‚¹é‡åˆï¼‰
                return {
                    x: snapPointX - rotatedLocalVertex.x,
                    y: snapPointY - rotatedLocalVertex.y
                };
            }
            
            // è°ƒæ•´åŒä¸‰è§’å½¢ç›®æ ‡ä½ç½®ï¼Œç¡®ä¿ç»„åˆåœ¨ä¸­å¿ƒåŒºåŸŸ
            adjustDualTargetsToCenter(target1, target2, triangle1, triangle2, angle1, angle2) {
                const displayWidth = window.innerWidth;
                const displayHeight = window.innerHeight;
                const margin = 80; // è¾¹ç•Œç•™ç™½
                
                // è®¡ç®—ä¸¤ä¸ªä¸‰è§’å½¢ç»„åˆåçš„è¾¹ç•Œ
                const bounds1 = this.calculateTriangleBounds(triangle1, target1.x, target1.y, angle1);
                const bounds2 = this.calculateTriangleBounds(triangle2, target2.x, target2.y, angle2);
                
                const combinedBounds = {
                    minX: Math.min(bounds1.minX, bounds2.minX),
                    maxX: Math.max(bounds1.maxX, bounds2.maxX),
                    minY: Math.min(bounds1.minY, bounds2.minY),
                    maxY: Math.max(bounds1.maxY, bounds2.maxY)
                };
                
                let offsetX = 0;
                let offsetY = 0;
                
                // æ£€æŸ¥è¾¹ç•Œå¹¶è®¡ç®—åç§»
                if (combinedBounds.minX < margin) {
                    offsetX = margin - combinedBounds.minX;
                }
                if (combinedBounds.maxX > displayWidth - margin) {
                    offsetX = (displayWidth - margin) - combinedBounds.maxX;
                }
                if (combinedBounds.minY < margin) {
                    offsetY = margin - combinedBounds.minY;
                }
                if (combinedBounds.maxY > displayHeight - margin) {
                    offsetY = (displayHeight - margin) - combinedBounds.maxY;
                }
                
                // åº”ç”¨åç§»
                return {
                    target1: { x: target1.x + offsetX, y: target1.y + offsetY },
                    target2: { x: target2.x + offsetX, y: target2.y + offsetY }
                };
            }
            
            // åŠ¨ç”»å®ç°éšæœºæ‹¼æ¥
            animateRandomSnap(movingTriangle, targetTriangle, movingVertexIndex, targetVertexIndex, button) {
                const startTime = Date.now();
                const duration = 1500; // åŠ¨ç”»æŒç»­æ—¶é—´1.5ç§’
                
                // è®°å½•åˆå§‹çŠ¶æ€
                const startX = movingTriangle.x;
                const startY = movingTriangle.y;
                const startAngle = movingTriangle.angle;
                
                // è®¡ç®—è¾¹çš„å¯¹é½è§’åº¦
                const targetAngle = this.calculateAlignmentAngle(movingTriangle, targetTriangle, movingVertexIndex, targetVertexIndex);
                
                // è®¡ç®—æœ€ç»ˆç›®æ ‡ä½ç½®ï¼ˆè€ƒè™‘æ—‹è½¬åçš„é¡¶ç‚¹ä½ç½®ï¼‰
                const finalTargetPos = this.calculateFinalTargetPosition(
                    movingTriangle, targetTriangle, movingVertexIndex, targetVertexIndex, targetAngle
                );
                
                // æ£€æŸ¥å¹¶è°ƒæ•´ç›®æ ‡ä½ç½®ï¼Œç¡®ä¿åœ¨çª—å£å†…
                const adjustedTarget = this.adjustPositionToBounds(finalTargetPos, movingTriangle, targetAngle);
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
                    const easeProgress = this.easeInOutCubic(progress);
                    
                    // åŒæ—¶æ’å€¼ä½ç½®å’Œè§’åº¦
                    movingTriangle.x = startX + (adjustedTarget.x - startX) * easeProgress;
                    movingTriangle.y = startY + (adjustedTarget.y - startY) * easeProgress;
                    
                    // æ’å€¼è§’åº¦
                    let angleDiff = targetAngle - startAngle;
                    // å¤„ç†è§’åº¦è·¨è¶Šé—®é¢˜ï¼Œé€‰æ‹©æœ€çŸ­è·¯å¾„
                    if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    movingTriangle.angle = startAngle + angleDiff * easeProgress;
                    movingTriangle.updateVertices();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // åŠ¨ç”»å®Œæˆï¼Œæ›´æ–°æŒä¹…åŒ–é‡åˆé¡¶ç‚¹
                        this.updatePersistentSharedVertices();
                        // é‡æ–°å¯ç”¨æŒ‰é’®
                        button.disabled = false;
                    }
                };
                
                animate();
            }
            
            // è®¡ç®—æœ€ç»ˆç›®æ ‡ä½ç½®ï¼ˆè€ƒè™‘æ—‹è½¬ï¼‰
            calculateFinalTargetPosition(movingTriangle, targetTriangle, movingVertexIndex, targetVertexIndex, targetAngle) {
                // è·å–ç›®æ ‡é¡¶ç‚¹ä½ç½®
                const targetVertex = targetTriangle.vertices[targetVertexIndex];
                
                // è®¡ç®—æ—‹è½¬åçš„å±€éƒ¨é¡¶ç‚¹åæ ‡
                const localVertices = this.getLocalVerticesFor(movingTriangle);
                const movingLocalVertex = localVertices[movingVertexIndex];
                
                // åº”ç”¨ç›®æ ‡è§’åº¦æ—‹è½¬åˆ°å±€éƒ¨é¡¶ç‚¹
                const cos = Math.cos(targetAngle);
                const sin = Math.sin(targetAngle);
                
                const rotatedLocalVertex = {
                    x: movingLocalVertex.x * cos - movingLocalVertex.y * sin,
                    y: movingLocalVertex.x * sin + movingLocalVertex.y * cos
                };
                
                // è®¡ç®—ç›®æ ‡ä½ç½®ï¼ˆè®©æ—‹è½¬åçš„é¡¶ç‚¹ä¸ç›®æ ‡é¡¶ç‚¹é‡åˆï¼‰
                return {
                    x: targetVertex.x - rotatedLocalVertex.x,
                    y: targetVertex.y - rotatedLocalVertex.y
                };
            }
            
            // è°ƒæ•´ä½ç½®ç¡®ä¿åœ¨çª—å£è¾¹ç•Œå†…
            adjustPositionToBounds(targetPos, triangle, targetAngle) {
                // è·å–æ˜¾ç¤ºå°ºå¯¸
                const displayWidth = window.innerWidth;
                const displayHeight = window.innerHeight;
                const margin = 150; // è¾¹ç•Œç•™ç™½
                
                // è®¡ç®—æ—‹è½¬åçš„ä¸‰è§’å½¢è¾¹ç•Œ
                const bounds = this.calculateTriangleBounds(triangle, targetPos.x, targetPos.y, targetAngle);
                
                let adjustedX = targetPos.x;
                let adjustedY = targetPos.y;
                
                // æ£€æŸ¥å·¦è¾¹ç•Œ
                if (bounds.minX < margin) {
                    adjustedX += margin - bounds.minX;
                }
                // æ£€æŸ¥å³è¾¹ç•Œ
                if (bounds.maxX > displayWidth - margin) {
                    adjustedX -= bounds.maxX - (displayWidth - margin);
                }
                // æ£€æŸ¥ä¸Šè¾¹ç•Œ
                if (bounds.minY < margin) {
                    adjustedY += margin - bounds.minY;
                }
                // æ£€æŸ¥ä¸‹è¾¹ç•Œ
                if (bounds.maxY > displayHeight - margin) {
                    adjustedY -= bounds.maxY - (displayHeight - margin);
                }
                
                return { x: adjustedX, y: adjustedY };
            }
            
            // è®¡ç®—ä¸‰è§’å½¢åœ¨æŒ‡å®šä½ç½®å’Œè§’åº¦ä¸‹çš„è¾¹ç•Œ
            calculateTriangleBounds(triangle, x, y, angle) {
                const localVertices = this.getLocalVerticesFor(triangle);
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                
                // è®¡ç®—æ‰€æœ‰é¡¶ç‚¹çš„ä¸–ç•Œåæ ‡
                localVertices.forEach(vertex => {
                    const worldX = x + vertex.x * cos - vertex.y * sin;
                    const worldY = y + vertex.x * sin + vertex.y * cos;
                    
                    minX = Math.min(minX, worldX);
                    maxX = Math.max(maxX, worldX);
                    minY = Math.min(minY, worldY);
                    maxY = Math.max(maxY, worldY);
                });
                
                return { minX, maxX, minY, maxY };
            }
            
            // ç¼“åŠ¨å‡½æ•°
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
            
            // è®¡ç®—è¾¹å¯¹é½çš„è§’åº¦
            calculateAlignmentAngle(movingTriangle, targetTriangle, movingVertexIndex, targetVertexIndex) {
                // è·å–ç›¸é‚»é¡¶ç‚¹ç´¢å¼•
                const getAdjacentVertices = (index) => {
                    return [(index + 1) % 3, (index + 2) % 3];
                };
                
                const movingAdjacent = getAdjacentVertices(movingVertexIndex);
                const targetAdjacent = getAdjacentVertices(targetVertexIndex);
                
                // éšæœºé€‰æ‹©ä¸€æ¡è¾¹è¿›è¡Œå¯¹é½
                const randomEdge = Math.floor(Math.random() * 2);
                const movingEdgeVertex = movingAdjacent[randomEdge];
                const targetEdgeVertex = targetAdjacent[randomEdge];
                
                // è®¡ç®—ç›®æ ‡è¾¹çš„æ–¹å‘
                const targetVertex1 = targetTriangle.vertices[targetVertexIndex];
                const targetVertex2 = targetTriangle.vertices[targetEdgeVertex];
                const targetEdgeAngle = Math.atan2(
                    targetVertex2.y - targetVertex1.y,
                    targetVertex2.x - targetVertex1.x
                );
                
                // è®¡ç®—ç§»åŠ¨ä¸‰è§’å½¢å¯¹åº”è¾¹çš„å½“å‰æ–¹å‘
                const movingLocalVertices = this.getLocalVerticesFor(movingTriangle);
                const movingLocalVertex1 = movingLocalVertices[movingVertexIndex];
                const movingLocalVertex2 = movingLocalVertices[movingEdgeVertex];
                const movingEdgeAngle = Math.atan2(
                    movingLocalVertex2.y - movingLocalVertex1.y,
                    movingLocalVertex2.x - movingLocalVertex1.x
                );
                
                // è®¡ç®—éœ€è¦çš„æ—‹è½¬è§’åº¦ï¼ˆè®©è¾¹åå‘å¯¹é½ï¼‰
                return targetEdgeAngle - movingEdgeAngle + Math.PI;
            }
        }
        
        // å¯åŠ¨åº”ç”¨
        window.addEventListener('DOMContentLoaded', () => {
            new CanvasApp();
        });
    </script>
</body>
</html>