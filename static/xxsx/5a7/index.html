<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五年级上册《植树问题》互动教学应用</title>
    <style>
        /* Reset and base styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        html {
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
        }
        
        body {
            margin: 0;
            font-family: 'Noto Sans SC', sans-serif;
            background-image: linear-gradient(to top, #f3e7e9 0%, #e3eeff 99%, #e3eeff 100%);
            color: #374151;
            height: 100vh;
        }
        
        button {
            font-family: inherit;
            font-size: 100%;
            line-height: 1.15;
            margin: 0;
            overflow: visible;
            text-transform: none;
            background: transparent;
            border: 0;
            cursor: pointer;
        }
        
        input {
            font-family: inherit;
            font-size: 100%;
            line-height: 1.15;
            margin: 0;
            overflow: visible;
        }
        
        input[type="number"] {
            -webkit-appearance: textfield;
        }
        
        label {
            display: inline-block;
        }
        
        /* Utility classes */
        .text-gray-700 { color: #374151; }
        .text-gray-800 { color: #1f2937; }
        .text-gray-600 { color: #4b5563; }
        .text-blue-600 { color: #2563eb; }
        .text-blue-700 { color: #1d4ed8; }
        .text-green-600 { color: #16a34a; }
        .text-green-700 { color: #15803d; }
        .text-red-600 { color: #dc2626; }
        .text-red-700 { color: #b91c1c; }
        .text-yellow-700 { color: #a16207; }
        .text-purple-700 { color: #7c3aed; }
        .text-indigo-400 { color: #818cf8; }
        
        .bg-gray-50 { background-color: #f9fafb; }
        .bg-gray-100 { background-color: #f3f4f6; }
        .bg-blue-100 { background-color: #dbeafe; }
        .bg-green-100 { background-color: #dcfce7; }
        .bg-red-100 { background-color: #fee2e2; }
        .bg-purple-100 { background-color: #f3e8ff; }
        
        .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .text-base { font-size: 1rem; line-height: 1.5rem; }
        .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
        .text-xl { font-size: 1.25rem; line-height: 1.75rem; }
        .text-2xl { font-size: 1.5rem; line-height: 2rem; }
        .text-4xl { font-size: 2.25rem; line-height: 2.5rem; }
        
        .font-medium { font-weight: 500; }
        .font-semibold { font-weight: 600; }
        .font-bold { font-weight: 700; }
        .font-mono { font-family: ui-monospace, SFMono-Regular, "SF Mono", Consolas, "Liberation Mono", Menlo, monospace; }
        
        .text-center { text-align: center; }
        
        .container {
            width: 100%;
            margin-left: auto;
            margin-right: auto;
            max-width: 1200px !important;
        }
        
        .mx-auto { margin-left: auto; margin-right: auto; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-6 { margin-bottom: 1.5rem; }
        .mb-8 { margin-bottom: 2rem; }
        .mt-2 { margin-top: 0.5rem; }
        
        .p-2 { padding: 0.5rem; }
        .p-3 { padding: 0.75rem; }
        .p-6 { padding: 1.5rem; }
        .px-1 { padding-left: 0.25rem; padding-right: 0.25rem; }
        .px-8 { padding-left: 2rem; padding-right: 2rem; }
        
        .p-4 { padding: 1rem; }
        .p-8 { padding: 2rem; }
        
        .w-full { width: 100%; }
        .h-48 { height: 12rem; }
        
        .rounded { border-radius: 0.25rem; }
        .rounded-lg { border-radius: 0.5rem; }
        .rounded-md { border-radius: 0.375rem; }
        
        .border { border-width: 1px; }
        .border-gray-300 { border-color: #d1d5db; }
        
        .block { display: block; }
        .flex { display: flex; }
        .grid { display: grid; }
        
        .grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
        
        .gap-2 { gap: 0.5rem; }
        .gap-4 { gap: 1rem; }
        .gap-6 { gap: 1.5rem; }
        
        .justify-center { justify-content: center; }
        .items-start { align-items: flex-start; }
        
        .space-y-4 > :not([hidden]) ~ :not([hidden]) {
            margin-top: 1rem;
        }
        
        .flex-1 { flex: 1 1 0%; }
        
        .cursor-pointer { cursor: pointer; }
        
        .overflow-x-auto { overflow-x: auto; }
        
        .focus\:ring-2:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
            box-shadow: 0 0 0 2px #818cf8;
        }
        
        .focus\:ring-indigo-400:focus {
            box-shadow: 0 0 0 2px #818cf8;
        }
        
        /* Responsive classes */
        @media (min-width: 640px) {
            .sm\:p-6 { padding: 1.5rem; }
        }
        
        @media (min-width: 768px) {
            .md\:h-64 { height: 16rem; }
        }
        
        @media (min-width: 1024px) {
            .lg\:p-8 { padding: 2rem; }
            .lg\:h-96 { height: 24rem; }
            .lg\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        }
        .card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.2s ease-in-out;
            border: 1px solid transparent;
        }
        .btn-primary {
            background-color: #4a69bd;
            color: white;
        }
        .btn-primary:hover {
            background-color: #3b5998;
        }
        .btn-secondary {
            background-color: #e0e7ff;
            color: #4338ca;
        }
        .btn-secondary.active {
            background-color: #4a69bd;
            color: white;
            font-weight: 700;
        }
        .btn-control {
            background-color: #f3f4f6;
            color: #374151;
            border-color: #d1d5db;
        }
        .btn-control:hover {
            background-color: #e5e7eb;
        }
        .btn-control:disabled {
            background-color: #f9fafb;
            color: #9ca3af;
            cursor: not-allowed;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #e5e7eb;
            padding: 1rem;
            text-align: center;
            vertical-align: middle;
        }
        th {
            background-color: #f9fafb;
            font-weight: 600;
        }
        .table-canvas {
            width: 150px;
            height: 75px;
            margin: 0 auto;
        }

        .btn-reset {
            background-color: #dc2626;
            color: white;
        }
        .btn-reset:hover {
            background-color: #b91c1c;
        }
        
        /* Position utilities */
        .fixed {
            position: fixed;
        }
        
        .top-4 {
            top: 2rem;
        }
        
        .right-4 {
            right: 2rem;
        }
        
        .z-50 {
            z-index: 50;
        }
    </style>
</head>
<body class="text-gray-700">
    <!-- 右上角导航 -->
    <nav class="fixed top-4 right-4 z-50 flex gap-4">
        <button id="nav-simulator" class="btn btn-primary active">模拟器</button>
        <button id="nav-knowledge" class="btn btn-secondary">知识结构</button>
    </nav>

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <!-- 页面标题 -->
        <header class="text-center mb-8">
            <h2 class="text-3xl font-bold text-gray-800 mb-6">"植树问题"互动教学应用</h2>
        </header>

        <main>
            <!-- Interactive Simulator -->
            <section id="simulator" class="card p-6 mb-8">
                <div class="w-full mb-4">
                    <canvas id="visualizer" class="bg-gray-100 rounded-lg w-full h-48 md:h-64 lg:h-96 cursor-pointer px-8"></canvas>
                </div>
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 items-start">
                    
                    <!-- 第一列：总长度和间距 -->
                    <div class="space-y-4">
                        <div>
                            <label for="totalLength" class="block text-sm font-medium mb-1">总长度 (米)</label>
                            <input type="number" id="totalLength" value="100" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-indigo-400">
                        </div>
                        <div>
                            <label for="spacing" class="block text-sm font-medium mb-1">间距 (米)</label>
                            <input type="number" id="spacing" value="20" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-indigo-400">
                        </div>

                        <button id="reset-btn" class="btn btn-reset w-full">重置</button>
                    </div>

                    <!-- 第二列：植树情境 -->
                    <div class="space-y-4">
                        <div>
                            <p class="block text-sm font-medium mb-2">植树情境</p>
                            <div class="grid grid-cols-1 gap-2" id="scenario-buttons">
                                <button data-scenario="both" class="btn btn-secondary active">两端都栽</button>
                                <button data-scenario="one" class="btn btn-secondary">一端栽</button>
                                <button data-scenario="none" class="btn btn-secondary">两端不栽</button>
                                <button data-scenario="closed" class="btn btn-secondary">封闭图形</button>
                            </div>
                        </div>
                    </div>

                    <!-- 第三列：结果显示和控制 -->
                    <div class="space-y-4">
                        <div id="results" class="text-center p-3 bg-gray-50 rounded-lg">
                             <p class="text-lg">当前: 第 <span id="current-step" class="font-bold text-xl text-blue-600">0</span> 步，共 <span id="total-steps" class="font-bold text-xl text-blue-600">0</span> 步</p>
                             <p class="text-lg">已栽树苗: <span id="tree-count" class="font-bold text-2xl text-green-600">0</span> 棵</p>
                             <p class="text-sm text-gray-600 mt-2">💡 提示：点击线段端点可以种树</p>
                        </div>
                        <div class="flex gap-2">
                            <button id="prev-step-btn" class="btn btn-control flex-1" disabled>◀ 上一步</button>
                            <button id="next-step-btn" class="btn btn-control flex-1" disabled>下一步 ▶</button>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Core Knowledge Structure Table -->
            <section id="knowledge-table" class="card p-6">
                <div class="overflow-x-auto">
                    <table>
                        <thead>
                            <tr>
                                <th>情境</th>
                                <th class="cursor-pointer" id="animation-control">情境动图 ⏸️ </th>
                                <th>规律发现 (公式)</th>
                                <th>关键点</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="font-bold text-green-700 text-lg">两端都栽</td>
                                <td><canvas class="table-canvas" id="canvas-both" data-scenario="both"></canvas></td>
                                <td><code class="text-xl font-mono bg-gray-100 p-2 rounded font-bold"><span class="text-green-600">棵数</span> = <span class="text-blue-600">间隔数</span> <span class="text-red-600">+ 1</span></code></td>
                                <td class="text-base">植树数量比<span class="bg-blue-100 text-blue-700 px-1 rounded font-semibold">间隔数量</span>多<span class="bg-red-100 text-red-700 px-1 rounded font-semibold">1</span>。</td>
                            </tr>
                            <tr>
                                <td class="font-bold text-blue-700 text-lg">一端栽</td>
                                <td><canvas class="table-canvas" id="canvas-one" data-scenario="one"></canvas></td>
                                <td><code class="text-xl font-mono bg-gray-100 p-2 rounded font-bold"><span class="text-green-600">棵数</span> = <span class="text-blue-600">间隔数</span></code></td>
                                <td class="text-base">植树数量<span class="bg-green-100 text-green-700 px-1 rounded font-semibold">等于</span><span class="bg-blue-100 text-blue-700 px-1 rounded font-semibold">间隔数量</span>。</td>
                            </tr>
                            <tr>
                                <td class="font-bold text-yellow-700 text-lg">两端不栽</td>
                                <td><canvas class="table-canvas" id="canvas-none" data-scenario="none"></canvas></td>
                                <td><code class="text-xl font-mono bg-gray-100 p-2 rounded font-bold"><span class="text-green-600">棵数</span> = <span class="text-blue-600">间隔数</span> <span class="text-red-600">- 1</span></code></td>
                                <td class="text-base">植树数量比<span class="bg-blue-100 text-blue-700 px-1 rounded font-semibold">间隔数量</span>少<span class="bg-red-100 text-red-700 px-1 rounded font-semibold">1</span>。</td>
                            </tr>
                            <tr>
                                <td class="font-bold text-purple-700 text-lg">封闭图形</td>
                                <td><canvas class="table-canvas" id="canvas-closed" data-scenario="closed"></canvas></td>
                                <td><code class="text-xl font-mono bg-gray-100 p-2 rounded font-bold"><span class="text-green-600">棵数</span> = <span class="text-blue-600">间隔数</span></code></td>
                                <td class="text-base"><span class="bg-purple-100 text-purple-700 px-1 rounded font-semibold">首尾相接</span>，植树数量<span class="bg-green-100 text-green-700 px-1 rounded font-semibold">等于</span><span class="bg-blue-100 text-blue-700 px-1 rounded font-semibold">间隔数量</span>。</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Main Simulator Elements
            const totalLengthInput = document.getElementById('totalLength');
            const spacingInput = document.getElementById('spacing');
            const scenarioButtons = document.getElementById('scenario-buttons');
            const resetBtn = document.getElementById('reset-btn');
            const prevStepBtn = document.getElementById('prev-step-btn');
            const nextStepBtn = document.getElementById('next-step-btn');
            
            // Navigation Elements
            const navSimulator = document.getElementById('nav-simulator');
            const navKnowledge = document.getElementById('nav-knowledge');
            const simulatorSection = document.getElementById('simulator');
            const knowledgeSection = document.getElementById('knowledge-table');
            
            const currentStepEl = document.getElementById('current-step');
            const totalStepsEl = document.getElementById('total-steps');
            const treeCountEl = document.getElementById('tree-count');
            
            const mainCanvas = document.getElementById('visualizer');
            const mainCtx = mainCanvas.getContext('2d');

            // Simulation State
            let simState = {
                totalLength: 100,
                spacing: 20,
                scenario: 'both',
                intervalCount: 0,
                totalSteps: 0,
                currentStep: 0,
                isCalculated: false,
                clickablePoints: [], // 存储可点击的端点位置
                plantedTrees: [], // 存储已种植的树的位置
                scenarioMemory: {}, // 记忆不同情况的操作状态
                spacingLabels: [], // 存储间距标注
            };

            function updateStepButtons() {
                prevStepBtn.disabled = simState.currentStep <= 0;
                nextStepBtn.disabled = simState.currentStep >= simState.totalSteps;
            }

            function resetSimulation() {
                simState.isCalculated = false;
                simState.currentStep = 0;
                simState.totalSteps = 0;
                simState.clickablePoints = [];
                simState.plantedTrees = [];
                simState.spacingLabels = [];
                prevStepBtn.disabled = true;
                nextStepBtn.disabled = true;
                drawMainVisualization();
                updateResultDisplay();
            }

            function fullReset() {
                simState.scenarioMemory = {};
                resetSimulation();
            }

            // 导航切换功能
            function showSimulator() {
                simulatorSection.style.display = 'block';
                knowledgeSection.style.display = 'none';
                navSimulator.classList.add('active');
                navSimulator.classList.remove('btn-secondary');
                navSimulator.classList.add('btn-primary');
                navKnowledge.classList.remove('active');
                navKnowledge.classList.add('btn-secondary');
                navKnowledge.classList.remove('btn-primary');
            }

            function showKnowledge() {
                simulatorSection.style.display = 'none';
                knowledgeSection.style.display = 'block';
                navKnowledge.classList.add('active');
                navKnowledge.classList.remove('btn-secondary');
                navKnowledge.classList.add('btn-primary');
                navSimulator.classList.remove('active');
                navSimulator.classList.add('btn-secondary');
                navSimulator.classList.remove('btn-primary');
            }

            function saveCurrentState() {
                const key = `${simState.scenario}_${simState.totalLength}_${simState.spacing}`;
                simState.scenarioMemory[key] = {
                    plantedTrees: [...simState.plantedTrees],
                    currentStep: simState.currentStep,
                    isCalculated: simState.isCalculated,
                    spacingLabels: [...simState.spacingLabels]
                };
            }

            function loadSavedState() {
                const key = `${simState.scenario}_${simState.totalLength}_${simState.spacing}`;
                const saved = simState.scenarioMemory[key];
                if (saved) {
                    simState.plantedTrees = [...saved.plantedTrees];
                    simState.currentStep = saved.currentStep;
                    simState.isCalculated = saved.isCalculated;
                    simState.spacingLabels = [...(saved.spacingLabels || [])];
                    return true;
                }
                return false;
            }

            function startCalculation() {
                simState.totalLength = parseFloat(totalLengthInput.value) || 0;
                simState.spacing = parseFloat(spacingInput.value) || 1;

                if (simState.totalLength <= 0 || simState.spacing <= 0) {
                    alert('请输入有效的长度和间距！');
                    return;
                }

                simState.intervalCount = Math.floor(simState.totalLength / simState.spacing);
                
                switch(simState.scenario) {
                    case 'both':
                        simState.totalSteps = simState.intervalCount + 1;
                        break;
                    case 'one':
                    case 'closed':
                        simState.totalSteps = simState.intervalCount;
                        break;
                    case 'none':
                        simState.totalSteps = simState.intervalCount > 0 ? simState.intervalCount - 1 : 0;
                        break;
                }
                
                // 尝试加载保存的状态
                if (!loadSavedState()) {
                    simState.currentStep = 0;
                    simState.plantedTrees = [];
                    simState.isCalculated = true;
                }
                
                drawMainVisualization();
                updateStepButtons();
                updateResultDisplay();
            }

            function handleStep(direction) {
                if (!simState.isCalculated) return;
                
                const newStep = simState.currentStep + direction;
                if (newStep < 0 || newStep > simState.totalSteps) return;
                
                simState.currentStep = newStep;
                
                // 根据当前步数更新已种植的树
                simState.plantedTrees = [];
                for (let i = 0; i < simState.currentStep; i++) {
                    if (i < simState.clickablePoints.length) {
                        const point = simState.clickablePoints[i];
                        simState.plantedTrees.push({
                            x: point.x,
                            y: point.y,
                            index: point.index
                        });
                    }
                }
                
                drawMainVisualization();
                updateStepButtons();
                updateResultDisplay();
            }

            function updateResultDisplay() {
                currentStepEl.textContent = simState.currentStep;
                totalStepsEl.textContent = simState.totalSteps;
                treeCountEl.textContent = simState.plantedTrees.length;
            }

            // 处理canvas点击事件
            function handleCanvasClick(event) {
                if (!simState.isCalculated) return;
                
                const rect = mainCanvas.getBoundingClientRect();
                const style = window.getComputedStyle(mainCanvas);
                const paddingLeft = parseFloat(style.paddingLeft) || 0;
                const paddingTop = parseFloat(style.paddingTop) || 0;
                
                // canvas的实际内容区域尺寸
                const contentWidth = rect.width - paddingLeft - parseFloat(style.paddingRight || 0);
                const contentHeight = rect.height - paddingTop - parseFloat(style.paddingBottom || 0);
                
                // 计算缩放比例（基于内容区域）
                const scaleX = mainCanvas.width / contentWidth;
                const scaleY = mainCanvas.height / contentHeight;
                
                // 计算相对于canvas内容区域的坐标
                const clickX = (event.clientX - rect.left - paddingLeft) * scaleX;
                const clickY = (event.clientY - rect.top - paddingTop) * scaleY;
                
                // 检查是否点击了可点击的点
                for (let point of simState.clickablePoints) {
                    const distance = Math.sqrt(
                        Math.pow(clickX - point.x, 2) + Math.pow(clickY - point.y, 2)
                    );
                    
                    if (distance <= 15) { // 点击范围
                        // 检查该位置是否已经种了树
                        const alreadyPlanted = simState.plantedTrees.some(tree => 
                            Math.abs(tree.x - point.x) < 10 && Math.abs(tree.y - point.y) < 10
                        );
                        
                        if (!alreadyPlanted) {
                            // 检查是否可以在此位置种树
                            if (point.canActuallyPlant !== false) {
                                // 种树
                                simState.plantedTrees.push({
                                    x: point.x,
                                    y: point.y,
                                    index: point.index
                                });
                                
                                // 更新当前步数
                                simState.currentStep = simState.plantedTrees.length;
                                
                                // 重新绘制
                                drawMainVisualization();
                                updateResultDisplay();
                                updateStepButtons();
                                
                                // 检查是否完成
                                if (simState.plantedTrees.length >= simState.totalSteps) {
                                    setTimeout(() => {
                                        alert('🎉 恭喜！您已完成所有植树任务！');
                                    }, 100);
                                }
                            } else {
                                  // 提示用户此位置不能种树
                                  if (simState.scenario === 'one') {
                                      if (point.index === 0 || point.index === simState.intervalCount) {
                                          alert('一端栽模式下，两端只能选择一端种树！');
                                      }
                                  }
                              }
                        }
                        return; // 如果点击了端点，直接返回
                    }
                }
                
                // 检查是否点击了线段（用于添加间距标注）
                if (simState.scenario !== 'closed') {
                    const padding = 30;
                    const canvasWidth = mainCanvas.width;
                    const drawWidth = canvasWidth - 2 * padding;
                    const segmentWidth = drawWidth / simState.intervalCount;
                    const y = mainCanvas.height / 2 + 20;
                    
                    // 检查每个线段
                    for (let i = 0; i < simState.intervalCount; i++) {
                        const x1 = padding + i * segmentWidth;
                        const x2 = padding + (i + 1) * segmentWidth;
                        const segmentCenterX = (x1 + x2) / 2;
                        
                        // 检查点击是否在线段范围内
                        if (clickX >= x1 && clickX <= x2 && Math.abs(clickY - y) <= 10) {
                            // 检查该线段是否已有标注
                            const existingLabel = simState.spacingLabels.find(label => label.segmentIndex === i);
                            
                            if (existingLabel) {
                                // 移除已存在的标注
                                simState.spacingLabels = simState.spacingLabels.filter(label => label.segmentIndex !== i);
                            } else {
                                // 添加新的间距标注
                                simState.spacingLabels.push({
                                    segmentIndex: i,
                                    x: segmentCenterX,
                                    y: y - 30,
                                    spacing: simState.spacing
                                });
                            }
                            
                            drawMainVisualization();
                            break;
                        }
                    }
                } else {
                    // 封闭图形的特殊处理：点击圆弧可以显示间距标注
                    const radius = Math.min(mainCanvas.width, mainCanvas.height) / 2 - 30;
                    const centerX = mainCanvas.width / 2;
                    const centerY = mainCanvas.height / 2;
                    
                    // 计算点击位置到圆心的距离
                    const distanceToCenter = Math.sqrt(
                        Math.pow(clickX - centerX, 2) + Math.pow(clickY - centerY, 2)
                    );
                    
                    // 检查是否点击在圆弧附近（允许一定误差范围）
                    if (Math.abs(distanceToCenter - radius) <= 15) {
                        // 计算点击位置对应的角度
                        const angle = Math.atan2(clickY - centerY, clickX - centerX);
                        let normalizedAngle = angle + Math.PI / 2; // 调整角度，使顶部为0
                        if (normalizedAngle < 0) normalizedAngle += 2 * Math.PI;
                        
                        // 确定点击的是哪个弧段
                        const segmentAngle = (2 * Math.PI) / simState.intervalCount;
                        const segmentIndex = Math.floor(normalizedAngle / segmentAngle);
                        
                        // 计算该弧段的中点位置
                        const midAngle = (segmentIndex + 0.5) * segmentAngle - Math.PI / 2;
                        const labelX = centerX + (radius - 40) * Math.cos(midAngle);
                        const labelY = centerY + (radius - 40) * Math.sin(midAngle);
                        
                        // 检查该弧段是否已有标注
                        const existingLabel = simState.spacingLabels.find(label => label.segmentIndex === segmentIndex);
                        
                        if (existingLabel) {
                            // 移除已存在的标注
                            simState.spacingLabels = simState.spacingLabels.filter(label => label.segmentIndex !== segmentIndex);
                        } else {
                            // 添加新的间距标注
                            simState.spacingLabels.push({
                                segmentIndex: segmentIndex,
                                x: labelX,
                                y: labelY,
                                spacing: simState.spacing,
                                isClosed: true
                            });
                        }
                        
                        drawMainVisualization();
                    }
                }
            }

            function drawTree(ctx, x, y, size = 1) {
                const crownRadius = 10 * size;
                const trunkHeight = 10 * size;
                const trunkWidth = 4 * size;
                
                ctx.fillStyle = '#8d5524'; // Trunk
                ctx.fillRect(x - trunkWidth / 2, y - trunkHeight, trunkWidth, trunkHeight);
                ctx.fillStyle = '#22c55e'; // Crown
                ctx.beginPath();
                ctx.arc(x, y - trunkHeight - crownRadius / 2, crownRadius, 0, 2 * Math.PI);
                ctx.fill();
            }

            function drawMainVisualization() {
                mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                const padding = 30;
                const canvasWidth = mainCanvas.width;
                const canvasHeight = mainCanvas.height;
                const y = canvasHeight / 2 + 20;

                // 重置可点击点数组
                simState.clickablePoints = [];

                if (!simState.isCalculated || simState.intervalCount <= 0) return;

                if (simState.scenario === 'closed') {
                    const radius = Math.min(canvasWidth, canvasHeight) / 2 - padding;
                    const centerX = canvasWidth / 2;
                    const centerY = canvasHeight / 2;
                    
                    mainCtx.beginPath();
                    mainCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    mainCtx.strokeStyle = '#9ca3af';
                    mainCtx.lineWidth = 2;
                    mainCtx.setLineDash([5, 5]);
                    mainCtx.stroke();
                    mainCtx.setLineDash([]);

                    // 计算可点击的点位置
                    for (let i = 0; i < simState.intervalCount; i++) {
                        const angle = (i / simState.intervalCount) * 2 * Math.PI - Math.PI / 2;
                        const x = centerX + radius * Math.cos(angle);
                        const y_point = centerY + radius * Math.sin(angle);
                        simState.clickablePoints.push({x, y: y_point, index: i});
                    }

                    // 绘制已种植的树
                    simState.plantedTrees.forEach(tree => {
                        drawTree(mainCtx, tree.x, tree.y);
                    });

                    // 绘制可点击的点（如果还没种树）
                    simState.clickablePoints.forEach(point => {
                        const isPlanted = simState.plantedTrees.some(tree => 
                            Math.abs(tree.x - point.x) < 10 && Math.abs(tree.y - point.y) < 10
                        );
                        if (!isPlanted) {
                            mainCtx.beginPath();
                            mainCtx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                            
                            // 根据是否可以种树显示不同颜色
                            if (point.canActuallyPlant !== false) {
                                mainCtx.fillStyle = '#fbbf24'; // 可种树：黄色
                                mainCtx.strokeStyle = '#f59e0b';
                            } else {
                                mainCtx.fillStyle = '#d1d5db'; // 不可种树：灰色
                                mainCtx.strokeStyle = '#9ca3af';
                            }
                            
                            mainCtx.fill();
                            mainCtx.lineWidth = 2;
                            mainCtx.stroke();
                        }
                    });
                } else {
                    const drawWidth = canvasWidth - 2 * padding;
                    const segmentWidth = drawWidth / simState.intervalCount;

                    mainCtx.beginPath();
                    mainCtx.moveTo(padding, y);
                    mainCtx.lineTo(canvasWidth - padding, y);
                    mainCtx.strokeStyle = '#9ca3af';
                    mainCtx.lineWidth = 2;
                    mainCtx.stroke();

                    // 绘制刻度线并计算可点击的点
                    for (let i = 0; i <= simState.intervalCount; i++) {
                        const x = padding + i * segmentWidth;
                        mainCtx.beginPath();
                        mainCtx.moveTo(x, y - 5);
                        mainCtx.lineTo(x, y + 5);
                        mainCtx.strokeStyle = '#6b7280';
                        mainCtx.stroke();

                        // 根据情境确定哪些点可以点击
                        let canPlant = false;
                        let canActuallyPlant = true;
                        
                        switch (simState.scenario) {
                            case 'both':
                                canPlant = true;
                                break;
                            case 'one':
                                // 一端栽：两端只能2选一，中间都可以种
                                canPlant = true;
                                // 检查是否已经种了端点
                                const hasLeftEnd = simState.plantedTrees.some(tree => tree.index === 0);
                                const hasRightEnd = simState.plantedTrees.some(tree => tree.index === simState.intervalCount);
                                
                                if (i === 0) {
                                    // 左端点：如果右端已种则不能种
                                    canActuallyPlant = !hasRightEnd;
                                } else if (i === simState.intervalCount) {
                                    // 右端点：如果左端已种则不能种
                                    canActuallyPlant = !hasLeftEnd;
                                } else {
                                    // 中间点：总是可以种
                                    canActuallyPlant = true;
                                }
                                break;
                            case 'none':
                                canPlant = i > 0 && i < simState.intervalCount;
                                break;
                        }
                        
                        if (canPlant) {
                            simState.clickablePoints.push({x, y, index: i, canActuallyPlant});
                        }
                    }

                    // 绘制已种植的树
                    simState.plantedTrees.forEach(tree => {
                        drawTree(mainCtx, tree.x, tree.y);
                    });

                    // 绘制可点击的点（如果还没种树）
                    simState.clickablePoints.forEach(point => {
                        const isPlanted = simState.plantedTrees.some(tree => 
                            Math.abs(tree.x - point.x) < 10 && Math.abs(tree.y - point.y) < 10
                        );
                        if (!isPlanted) {
                            mainCtx.beginPath();
                            mainCtx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                            mainCtx.fillStyle = '#fbbf24';
                            mainCtx.fill();
                            mainCtx.strokeStyle = '#f59e0b';
                            mainCtx.lineWidth = 2;
                            mainCtx.stroke();
                        }
                    });
                }
                
                // 绘制间距标注
                simState.spacingLabels.forEach(label => {
                    mainCtx.fillStyle = '#008000';
                    mainCtx.font = 'bold 20px Arial';
                    mainCtx.textAlign = 'center';
                    mainCtx.fillText(`${label.spacing}米`, label.x, label.y);
                    
                    // 绘制指示线
                    mainCtx.strokeStyle = '#008000';
                    mainCtx.lineWidth = 1;
                    mainCtx.setLineDash([3, 3]);
                    mainCtx.beginPath();
                    
                    if (label.isClosed) {
                         // 封闭图形的指示线：从标注位置朝外指向圆弧外侧
                         const centerX = mainCanvas.width / 2;
                         const centerY = mainCanvas.height / 2;
                         const radius = Math.min(mainCanvas.width, mainCanvas.height) / 2 - 30;
                         
                         // 计算从圆心到标注位置的方向（朝外）
                         const dx = label.x - centerX;
                         const dy = label.y - centerY;
                         const distance = Math.sqrt(dx * dx + dy * dy);
                         const unitX = dx / distance;
                         const unitY = dy / distance;
                         
                         // 绘制指示线：从标注位置朝外延伸
                         mainCtx.moveTo(label.x + unitX * 5, label.y + unitY * 5);
                         mainCtx.lineTo(label.x + unitX * 25, label.y + unitY * 25);
                     } else {
                        // 直线的指示线
                        mainCtx.moveTo(label.x, label.y + 5);
                        mainCtx.lineTo(label.x, label.y + 25);
                    }
                    
                    mainCtx.stroke();
                    mainCtx.setLineDash([]);
                });
            }
            
            // Setup Navigation Listeners
            navSimulator.addEventListener('click', showSimulator);
            navKnowledge.addEventListener('click', showKnowledge);
            
            // Setup Main Simulator Listeners
            resetBtn.addEventListener('click', fullReset);
            prevStepBtn.addEventListener('click', () => handleStep(-1));
            nextStepBtn.addEventListener('click', () => handleStep(1));
            mainCanvas.addEventListener('click', handleCanvasClick);
            scenarioButtons.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON' && e.target.dataset.scenario) {
                    // 保存当前状态
                    if (simState.isCalculated) {
                        saveCurrentState();
                    }
                    
                    simState.scenario = e.target.dataset.scenario;
                    document.querySelectorAll('#scenario-buttons button').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // 切换情境时隐藏间距长度标注
                    simState.spacingLabels = [];
                    
                    // 自动开始计算
                    startCalculation();
                }
            });
            ['input', 'change'].forEach(evt => {
                totalLengthInput.addEventListener(evt, () => {
                    if (simState.isCalculated) {
                        saveCurrentState();
                        startCalculation();
                    }
                });
                spacingInput.addEventListener(evt, () => {
                    if (simState.isCalculated) {
                        saveCurrentState();
                        startCalculation();
                    }
                });
            });


            // Table Animations
            const tableCanvases = document.querySelectorAll('.table-canvas');
            let globalAnimationPlaying = true;
            const animationControl = document.getElementById('animation-control');
            
            tableCanvases.forEach(canvas => {
                const ctx = canvas.getContext('2d');
                const scenario = canvas.dataset.scenario;
                let frame = 0;
                const totalFrames = 180; // 3 seconds at 60fps
                const intervals = 4;

                function animate() {
                    if (globalAnimationPlaying) {
                        frame++;
                        if (frame > totalFrames) frame = 0;
                    }
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const padding = 10;
                    const y = canvas.height / 2 + 10;
                    
                    if (scenario === 'closed') {
                        const radius = Math.min(canvas.width, canvas.height)/2 - padding;
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                        ctx.strokeStyle = '#9ca3af';
                        ctx.stroke();

                        let treesToShow;
                        if (globalAnimationPlaying) {
                            treesToShow = Math.floor((frame / totalFrames) * intervals) + 1;
                        } else {
                            treesToShow = intervals; // 显示完整状态
                        }
                        
                        for (let i = 0; i < treesToShow; i++) {
                           const angle = (i / intervals) * 2 * Math.PI - Math.PI / 2;
                           drawTree(ctx, centerX + radius * Math.cos(angle), centerY + radius * Math.sin(angle), 0.6);
                        }
                    } else {
                        const drawWidth = canvas.width - 2 * padding;
                        const segmentWidth = drawWidth / intervals;
                        ctx.beginPath();
                        ctx.moveTo(padding, y);
                        ctx.lineTo(canvas.width - padding, y);
                        ctx.strokeStyle = '#9ca3af';
                        ctx.stroke();
                        
                        let treeCount;
                        if (scenario === 'both') treeCount = intervals + 1;
                        if (scenario === 'one') treeCount = intervals;
                        if (scenario === 'none') treeCount = intervals - 1;

                        let treesToShow;
                        if (globalAnimationPlaying) {
                            treesToShow = Math.floor((frame / totalFrames) * treeCount) + 1;
                        } else {
                            treesToShow = treeCount; // 显示完整状态
                        }

                        for (let i = 0; i < treesToShow; i++) {
                            let x;
                            if (scenario === 'both') x = padding + i * segmentWidth;
                            if (scenario === 'one') x = padding + i * segmentWidth;
                            if (scenario === 'none') x = padding + (i + 1) * segmentWidth;
                            drawTree(ctx, x, y, 0.6);
                        }
                    }
                    
                    requestAnimationFrame(animate);
                }
                animate();
            });
            
            // 添加点击表头控制所有动画的功能
            animationControl.addEventListener('click', () => {
                globalAnimationPlaying = !globalAnimationPlaying;
                animationControl.textContent = globalAnimationPlaying ? '情境动图 ⏸️ ' : '情境动图 ▶️';
            });
            
            // 设置canvas尺寸
            function resizeCanvas() {
                const rect = mainCanvas.getBoundingClientRect();
                const style = window.getComputedStyle(mainCanvas);
                const paddingLeft = parseFloat(style.paddingLeft) || 0;
                const paddingRight = parseFloat(style.paddingRight) || 0;
                const paddingTop = parseFloat(style.paddingTop) || 0;
                const paddingBottom = parseFloat(style.paddingBottom) || 0;
                
                // 设置canvas实际绘制区域尺寸（排除padding）
                mainCanvas.width = rect.width - paddingLeft - paddingRight;
                mainCanvas.height = rect.height - paddingTop - paddingBottom;
                drawMainVisualization();
            }
            
            // 监听窗口大小变化
            window.addEventListener('resize', resizeCanvas);
            
            // Initial setup
            resizeCanvas();
            showSimulator(); // 默认显示交互模拟器
            startCalculation(); // 默认开始计算
        });
    </script>
</body>
</html>