<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å¹´çº§ä¸Šå†Œã€Šæ¤æ ‘é—®é¢˜ã€‹äº’åŠ¨æ•™å­¦åº”ç”¨</title>
    <style>
        /* Reset and base styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        html {
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
        }
        
        body {
            margin: 0;
            font-family: 'Noto Sans SC', sans-serif;
            background-image: linear-gradient(to top, #f3e7e9 0%, #e3eeff 99%, #e3eeff 100%);
            color: #374151;
            height: 100vh;
        }
        
        button {
            font-family: inherit;
            font-size: 100%;
            line-height: 1.15;
            margin: 0;
            overflow: visible;
            text-transform: none;
            background: transparent;
            border: 0;
            cursor: pointer;
        }
        
        input {
            font-family: inherit;
            font-size: 100%;
            line-height: 1.15;
            margin: 0;
            overflow: visible;
        }
        
        input[type="number"] {
            -webkit-appearance: textfield;
        }
        
        label {
            display: inline-block;
        }
        
        /* Utility classes */
        .text-gray-700 { color: #374151; }
        .text-gray-800 { color: #1f2937; }
        .text-gray-600 { color: #4b5563; }
        .text-blue-600 { color: #2563eb; }
        .text-blue-700 { color: #1d4ed8; }
        .text-green-600 { color: #16a34a; }
        .text-green-700 { color: #15803d; }
        .text-red-600 { color: #dc2626; }
        .text-red-700 { color: #b91c1c; }
        .text-yellow-700 { color: #a16207; }
        .text-purple-700 { color: #7c3aed; }
        .text-indigo-400 { color: #818cf8; }
        
        .bg-gray-50 { background-color: #f9fafb; }
        .bg-gray-100 { background-color: #f3f4f6; }
        .bg-blue-100 { background-color: #dbeafe; }
        .bg-green-100 { background-color: #dcfce7; }
        .bg-red-100 { background-color: #fee2e2; }
        .bg-purple-100 { background-color: #f3e8ff; }
        
        .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .text-base { font-size: 1rem; line-height: 1.5rem; }
        .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
        .text-xl { font-size: 1.25rem; line-height: 1.75rem; }
        .text-2xl { font-size: 1.5rem; line-height: 2rem; }
        .text-4xl { font-size: 2.25rem; line-height: 2.5rem; }
        
        .font-medium { font-weight: 500; }
        .font-semibold { font-weight: 600; }
        .font-bold { font-weight: 700; }
        .font-mono { font-family: ui-monospace, SFMono-Regular, "SF Mono", Consolas, "Liberation Mono", Menlo, monospace; }
        
        .text-center { text-align: center; }
        
        .container {
            width: 100%;
            margin-left: auto;
            margin-right: auto;
            max-width: 1200px !important;
        }
        
        .mx-auto { margin-left: auto; margin-right: auto; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-6 { margin-bottom: 1.5rem; }
        .mb-8 { margin-bottom: 2rem; }
        .mt-2 { margin-top: 0.5rem; }
        
        .p-2 { padding: 0.5rem; }
        .p-3 { padding: 0.75rem; }
        .p-6 { padding: 1.5rem; }
        .px-1 { padding-left: 0.25rem; padding-right: 0.25rem; }
        .px-8 { padding-left: 2rem; padding-right: 2rem; }
        
        .p-4 { padding: 1rem; }
        .p-8 { padding: 2rem; }
        
        .w-full { width: 100%; }
        .h-48 { height: 12rem; }
        
        .rounded { border-radius: 0.25rem; }
        .rounded-lg { border-radius: 0.5rem; }
        .rounded-md { border-radius: 0.375rem; }
        
        .border { border-width: 1px; }
        .border-gray-300 { border-color: #d1d5db; }
        
        .block { display: block; }
        .flex { display: flex; }
        .grid { display: grid; }
        
        .grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
        
        .gap-2 { gap: 0.5rem; }
        .gap-4 { gap: 1rem; }
        .gap-6 { gap: 1.5rem; }
        
        .justify-center { justify-content: center; }
        .items-start { align-items: flex-start; }
        
        .space-y-4 > :not([hidden]) ~ :not([hidden]) {
            margin-top: 1rem;
        }
        
        .flex-1 { flex: 1 1 0%; }
        
        .cursor-pointer { cursor: pointer; }
        
        .overflow-x-auto { overflow-x: auto; }
        
        .focus\:ring-2:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
            box-shadow: 0 0 0 2px #818cf8;
        }
        
        .focus\:ring-indigo-400:focus {
            box-shadow: 0 0 0 2px #818cf8;
        }
        
        /* Responsive classes */
        @media (min-width: 640px) {
            .sm\:p-6 { padding: 1.5rem; }
        }
        
        @media (min-width: 768px) {
            .md\:h-64 { height: 16rem; }
        }
        
        @media (min-width: 1024px) {
            .lg\:p-8 { padding: 2rem; }
            .lg\:h-96 { height: 24rem; }
            .lg\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        }
        .card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.2s ease-in-out;
            border: 1px solid transparent;
        }
        .btn-primary {
            background-color: #4a69bd;
            color: white;
        }
        .btn-primary:hover {
            background-color: #3b5998;
        }
        .btn-secondary {
            background-color: #e0e7ff;
            color: #4338ca;
        }
        .btn-secondary.active {
            background-color: #4a69bd;
            color: white;
            font-weight: 700;
        }
        .btn-control {
            background-color: #f3f4f6;
            color: #374151;
            border-color: #d1d5db;
        }
        .btn-control:hover {
            background-color: #e5e7eb;
        }
        .btn-control:disabled {
            background-color: #f9fafb;
            color: #9ca3af;
            cursor: not-allowed;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #e5e7eb;
            padding: 1rem;
            text-align: center;
            vertical-align: middle;
        }
        th {
            background-color: #f9fafb;
            font-weight: 600;
        }
        .table-canvas {
            width: 150px;
            height: 75px;
            margin: 0 auto;
        }

        .btn-reset {
            background-color: #dc2626;
            color: white;
        }
        .btn-reset:hover {
            background-color: #b91c1c;
        }
        
        /* Position utilities */
        .fixed {
            position: fixed;
        }
        
        .top-4 {
            top: 2rem;
        }
        
        .right-4 {
            right: 2rem;
        }
        
        .z-50 {
            z-index: 50;
        }
    </style>
</head>
<body class="text-gray-700">
    <!-- å³ä¸Šè§’å¯¼èˆª -->
    <nav class="fixed top-4 right-4 z-50 flex gap-4">
        <button id="nav-simulator" class="btn btn-primary active">æ¨¡æ‹Ÿå™¨</button>
        <button id="nav-knowledge" class="btn btn-secondary">çŸ¥è¯†ç»“æ„</button>
    </nav>

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <!-- é¡µé¢æ ‡é¢˜ -->
        <header class="text-center mb-8">
            <h2 class="text-3xl font-bold text-gray-800 mb-6">"æ¤æ ‘é—®é¢˜"äº’åŠ¨æ•™å­¦åº”ç”¨</h2>
        </header>

        <main>
            <!-- Interactive Simulator -->
            <section id="simulator" class="card p-6 mb-8">
                <div class="w-full mb-4">
                    <canvas id="visualizer" class="bg-gray-100 rounded-lg w-full h-48 md:h-64 lg:h-96 cursor-pointer px-8"></canvas>
                </div>
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 items-start">
                    
                    <!-- ç¬¬ä¸€åˆ—ï¼šæ€»é•¿åº¦å’Œé—´è· -->
                    <div class="space-y-4">
                        <div>
                            <label for="totalLength" class="block text-sm font-medium mb-1">æ€»é•¿åº¦ (ç±³)</label>
                            <input type="number" id="totalLength" value="100" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-indigo-400">
                        </div>
                        <div>
                            <label for="spacing" class="block text-sm font-medium mb-1">é—´è· (ç±³)</label>
                            <input type="number" id="spacing" value="20" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-indigo-400">
                        </div>

                        <button id="reset-btn" class="btn btn-reset w-full">é‡ç½®</button>
                    </div>

                    <!-- ç¬¬äºŒåˆ—ï¼šæ¤æ ‘æƒ…å¢ƒ -->
                    <div class="space-y-4">
                        <div>
                            <p class="block text-sm font-medium mb-2">æ¤æ ‘æƒ…å¢ƒ</p>
                            <div class="grid grid-cols-1 gap-2" id="scenario-buttons">
                                <button data-scenario="both" class="btn btn-secondary active">ä¸¤ç«¯éƒ½æ ½</button>
                                <button data-scenario="one" class="btn btn-secondary">ä¸€ç«¯æ ½</button>
                                <button data-scenario="none" class="btn btn-secondary">ä¸¤ç«¯ä¸æ ½</button>
                                <button data-scenario="closed" class="btn btn-secondary">å°é—­å›¾å½¢</button>
                            </div>
                        </div>
                    </div>

                    <!-- ç¬¬ä¸‰åˆ—ï¼šç»“æœæ˜¾ç¤ºå’Œæ§åˆ¶ -->
                    <div class="space-y-4">
                        <div id="results" class="text-center p-3 bg-gray-50 rounded-lg">
                             <p class="text-lg">å½“å‰: ç¬¬ <span id="current-step" class="font-bold text-xl text-blue-600">0</span> æ­¥ï¼Œå…± <span id="total-steps" class="font-bold text-xl text-blue-600">0</span> æ­¥</p>
                             <p class="text-lg">å·²æ ½æ ‘è‹—: <span id="tree-count" class="font-bold text-2xl text-green-600">0</span> æ£µ</p>
                             <p class="text-sm text-gray-600 mt-2">ğŸ’¡ æç¤ºï¼šç‚¹å‡»çº¿æ®µç«¯ç‚¹å¯ä»¥ç§æ ‘</p>
                        </div>
                        <div class="flex gap-2">
                            <button id="prev-step-btn" class="btn btn-control flex-1" disabled>â—€ ä¸Šä¸€æ­¥</button>
                            <button id="next-step-btn" class="btn btn-control flex-1" disabled>ä¸‹ä¸€æ­¥ â–¶</button>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Core Knowledge Structure Table -->
            <section id="knowledge-table" class="card p-6">
                <div class="overflow-x-auto">
                    <table>
                        <thead>
                            <tr>
                                <th>æƒ…å¢ƒ</th>
                                <th class="cursor-pointer" id="animation-control">æƒ…å¢ƒåŠ¨å›¾ â¸ï¸ </th>
                                <th>è§„å¾‹å‘ç° (å…¬å¼)</th>
                                <th>å…³é”®ç‚¹</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="font-bold text-green-700 text-lg">ä¸¤ç«¯éƒ½æ ½</td>
                                <td><canvas class="table-canvas" id="canvas-both" data-scenario="both"></canvas></td>
                                <td><code class="text-xl font-mono bg-gray-100 p-2 rounded font-bold"><span class="text-green-600">æ£µæ•°</span> = <span class="text-blue-600">é—´éš”æ•°</span> <span class="text-red-600">+ 1</span></code></td>
                                <td class="text-base">æ¤æ ‘æ•°é‡æ¯”<span class="bg-blue-100 text-blue-700 px-1 rounded font-semibold">é—´éš”æ•°é‡</span>å¤š<span class="bg-red-100 text-red-700 px-1 rounded font-semibold">1</span>ã€‚</td>
                            </tr>
                            <tr>
                                <td class="font-bold text-blue-700 text-lg">ä¸€ç«¯æ ½</td>
                                <td><canvas class="table-canvas" id="canvas-one" data-scenario="one"></canvas></td>
                                <td><code class="text-xl font-mono bg-gray-100 p-2 rounded font-bold"><span class="text-green-600">æ£µæ•°</span> = <span class="text-blue-600">é—´éš”æ•°</span></code></td>
                                <td class="text-base">æ¤æ ‘æ•°é‡<span class="bg-green-100 text-green-700 px-1 rounded font-semibold">ç­‰äº</span><span class="bg-blue-100 text-blue-700 px-1 rounded font-semibold">é—´éš”æ•°é‡</span>ã€‚</td>
                            </tr>
                            <tr>
                                <td class="font-bold text-yellow-700 text-lg">ä¸¤ç«¯ä¸æ ½</td>
                                <td><canvas class="table-canvas" id="canvas-none" data-scenario="none"></canvas></td>
                                <td><code class="text-xl font-mono bg-gray-100 p-2 rounded font-bold"><span class="text-green-600">æ£µæ•°</span> = <span class="text-blue-600">é—´éš”æ•°</span> <span class="text-red-600">- 1</span></code></td>
                                <td class="text-base">æ¤æ ‘æ•°é‡æ¯”<span class="bg-blue-100 text-blue-700 px-1 rounded font-semibold">é—´éš”æ•°é‡</span>å°‘<span class="bg-red-100 text-red-700 px-1 rounded font-semibold">1</span>ã€‚</td>
                            </tr>
                            <tr>
                                <td class="font-bold text-purple-700 text-lg">å°é—­å›¾å½¢</td>
                                <td><canvas class="table-canvas" id="canvas-closed" data-scenario="closed"></canvas></td>
                                <td><code class="text-xl font-mono bg-gray-100 p-2 rounded font-bold"><span class="text-green-600">æ£µæ•°</span> = <span class="text-blue-600">é—´éš”æ•°</span></code></td>
                                <td class="text-base"><span class="bg-purple-100 text-purple-700 px-1 rounded font-semibold">é¦–å°¾ç›¸æ¥</span>ï¼Œæ¤æ ‘æ•°é‡<span class="bg-green-100 text-green-700 px-1 rounded font-semibold">ç­‰äº</span><span class="bg-blue-100 text-blue-700 px-1 rounded font-semibold">é—´éš”æ•°é‡</span>ã€‚</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Main Simulator Elements
            const totalLengthInput = document.getElementById('totalLength');
            const spacingInput = document.getElementById('spacing');
            const scenarioButtons = document.getElementById('scenario-buttons');
            const resetBtn = document.getElementById('reset-btn');
            const prevStepBtn = document.getElementById('prev-step-btn');
            const nextStepBtn = document.getElementById('next-step-btn');
            
            // Navigation Elements
            const navSimulator = document.getElementById('nav-simulator');
            const navKnowledge = document.getElementById('nav-knowledge');
            const simulatorSection = document.getElementById('simulator');
            const knowledgeSection = document.getElementById('knowledge-table');
            
            const currentStepEl = document.getElementById('current-step');
            const totalStepsEl = document.getElementById('total-steps');
            const treeCountEl = document.getElementById('tree-count');
            
            const mainCanvas = document.getElementById('visualizer');
            const mainCtx = mainCanvas.getContext('2d');

            // Simulation State
            let simState = {
                totalLength: 100,
                spacing: 20,
                scenario: 'both',
                intervalCount: 0,
                totalSteps: 0,
                currentStep: 0,
                isCalculated: false,
                clickablePoints: [], // å­˜å‚¨å¯ç‚¹å‡»çš„ç«¯ç‚¹ä½ç½®
                plantedTrees: [], // å­˜å‚¨å·²ç§æ¤çš„æ ‘çš„ä½ç½®
                scenarioMemory: {}, // è®°å¿†ä¸åŒæƒ…å†µçš„æ“ä½œçŠ¶æ€
                spacingLabels: [], // å­˜å‚¨é—´è·æ ‡æ³¨
            };

            function updateStepButtons() {
                prevStepBtn.disabled = simState.currentStep <= 0;
                nextStepBtn.disabled = simState.currentStep >= simState.totalSteps;
            }

            function resetSimulation() {
                simState.isCalculated = false;
                simState.currentStep = 0;
                simState.totalSteps = 0;
                simState.clickablePoints = [];
                simState.plantedTrees = [];
                simState.spacingLabels = [];
                prevStepBtn.disabled = true;
                nextStepBtn.disabled = true;
                drawMainVisualization();
                updateResultDisplay();
            }

            function fullReset() {
                simState.scenarioMemory = {};
                resetSimulation();
            }

            // å¯¼èˆªåˆ‡æ¢åŠŸèƒ½
            function showSimulator() {
                simulatorSection.style.display = 'block';
                knowledgeSection.style.display = 'none';
                navSimulator.classList.add('active');
                navSimulator.classList.remove('btn-secondary');
                navSimulator.classList.add('btn-primary');
                navKnowledge.classList.remove('active');
                navKnowledge.classList.add('btn-secondary');
                navKnowledge.classList.remove('btn-primary');
            }

            function showKnowledge() {
                simulatorSection.style.display = 'none';
                knowledgeSection.style.display = 'block';
                navKnowledge.classList.add('active');
                navKnowledge.classList.remove('btn-secondary');
                navKnowledge.classList.add('btn-primary');
                navSimulator.classList.remove('active');
                navSimulator.classList.add('btn-secondary');
                navSimulator.classList.remove('btn-primary');
            }

            function saveCurrentState() {
                const key = `${simState.scenario}_${simState.totalLength}_${simState.spacing}`;
                simState.scenarioMemory[key] = {
                    plantedTrees: [...simState.plantedTrees],
                    currentStep: simState.currentStep,
                    isCalculated: simState.isCalculated,
                    spacingLabels: [...simState.spacingLabels]
                };
            }

            function loadSavedState() {
                const key = `${simState.scenario}_${simState.totalLength}_${simState.spacing}`;
                const saved = simState.scenarioMemory[key];
                if (saved) {
                    simState.plantedTrees = [...saved.plantedTrees];
                    simState.currentStep = saved.currentStep;
                    simState.isCalculated = saved.isCalculated;
                    simState.spacingLabels = [...(saved.spacingLabels || [])];
                    return true;
                }
                return false;
            }

            function startCalculation() {
                simState.totalLength = parseFloat(totalLengthInput.value) || 0;
                simState.spacing = parseFloat(spacingInput.value) || 1;

                if (simState.totalLength <= 0 || simState.spacing <= 0) {
                    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„é•¿åº¦å’Œé—´è·ï¼');
                    return;
                }

                simState.intervalCount = Math.floor(simState.totalLength / simState.spacing);
                
                switch(simState.scenario) {
                    case 'both':
                        simState.totalSteps = simState.intervalCount + 1;
                        break;
                    case 'one':
                    case 'closed':
                        simState.totalSteps = simState.intervalCount;
                        break;
                    case 'none':
                        simState.totalSteps = simState.intervalCount > 0 ? simState.intervalCount - 1 : 0;
                        break;
                }
                
                // å°è¯•åŠ è½½ä¿å­˜çš„çŠ¶æ€
                if (!loadSavedState()) {
                    simState.currentStep = 0;
                    simState.plantedTrees = [];
                    simState.isCalculated = true;
                }
                
                drawMainVisualization();
                updateStepButtons();
                updateResultDisplay();
            }

            function handleStep(direction) {
                if (!simState.isCalculated) return;
                
                const newStep = simState.currentStep + direction;
                if (newStep < 0 || newStep > simState.totalSteps) return;
                
                simState.currentStep = newStep;
                
                // æ ¹æ®å½“å‰æ­¥æ•°æ›´æ–°å·²ç§æ¤çš„æ ‘
                simState.plantedTrees = [];
                for (let i = 0; i < simState.currentStep; i++) {
                    if (i < simState.clickablePoints.length) {
                        const point = simState.clickablePoints[i];
                        simState.plantedTrees.push({
                            x: point.x,
                            y: point.y,
                            index: point.index
                        });
                    }
                }
                
                drawMainVisualization();
                updateStepButtons();
                updateResultDisplay();
            }

            function updateResultDisplay() {
                currentStepEl.textContent = simState.currentStep;
                totalStepsEl.textContent = simState.totalSteps;
                treeCountEl.textContent = simState.plantedTrees.length;
            }

            // å¤„ç†canvasç‚¹å‡»äº‹ä»¶
            function handleCanvasClick(event) {
                if (!simState.isCalculated) return;
                
                const rect = mainCanvas.getBoundingClientRect();
                const style = window.getComputedStyle(mainCanvas);
                const paddingLeft = parseFloat(style.paddingLeft) || 0;
                const paddingTop = parseFloat(style.paddingTop) || 0;
                
                // canvasçš„å®é™…å†…å®¹åŒºåŸŸå°ºå¯¸
                const contentWidth = rect.width - paddingLeft - parseFloat(style.paddingRight || 0);
                const contentHeight = rect.height - paddingTop - parseFloat(style.paddingBottom || 0);
                
                // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼ˆåŸºäºå†…å®¹åŒºåŸŸï¼‰
                const scaleX = mainCanvas.width / contentWidth;
                const scaleY = mainCanvas.height / contentHeight;
                
                // è®¡ç®—ç›¸å¯¹äºcanvaså†…å®¹åŒºåŸŸçš„åæ ‡
                const clickX = (event.clientX - rect.left - paddingLeft) * scaleX;
                const clickY = (event.clientY - rect.top - paddingTop) * scaleY;
                
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å¯ç‚¹å‡»çš„ç‚¹
                for (let point of simState.clickablePoints) {
                    const distance = Math.sqrt(
                        Math.pow(clickX - point.x, 2) + Math.pow(clickY - point.y, 2)
                    );
                    
                    if (distance <= 15) { // ç‚¹å‡»èŒƒå›´
                        // æ£€æŸ¥è¯¥ä½ç½®æ˜¯å¦å·²ç»ç§äº†æ ‘
                        const alreadyPlanted = simState.plantedTrees.some(tree => 
                            Math.abs(tree.x - point.x) < 10 && Math.abs(tree.y - point.y) < 10
                        );
                        
                        if (!alreadyPlanted) {
                            // æ£€æŸ¥æ˜¯å¦å¯ä»¥åœ¨æ­¤ä½ç½®ç§æ ‘
                            if (point.canActuallyPlant !== false) {
                                // ç§æ ‘
                                simState.plantedTrees.push({
                                    x: point.x,
                                    y: point.y,
                                    index: point.index
                                });
                                
                                // æ›´æ–°å½“å‰æ­¥æ•°
                                simState.currentStep = simState.plantedTrees.length;
                                
                                // é‡æ–°ç»˜åˆ¶
                                drawMainVisualization();
                                updateResultDisplay();
                                updateStepButtons();
                                
                                // æ£€æŸ¥æ˜¯å¦å®Œæˆ
                                if (simState.plantedTrees.length >= simState.totalSteps) {
                                    setTimeout(() => {
                                        alert('ğŸ‰ æ­å–œï¼æ‚¨å·²å®Œæˆæ‰€æœ‰æ¤æ ‘ä»»åŠ¡ï¼');
                                    }, 100);
                                }
                            } else {
                                  // æç¤ºç”¨æˆ·æ­¤ä½ç½®ä¸èƒ½ç§æ ‘
                                  if (simState.scenario === 'one') {
                                      if (point.index === 0 || point.index === simState.intervalCount) {
                                          alert('ä¸€ç«¯æ ½æ¨¡å¼ä¸‹ï¼Œä¸¤ç«¯åªèƒ½é€‰æ‹©ä¸€ç«¯ç§æ ‘ï¼');
                                      }
                                  }
                              }
                        }
                        return; // å¦‚æœç‚¹å‡»äº†ç«¯ç‚¹ï¼Œç›´æ¥è¿”å›
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†çº¿æ®µï¼ˆç”¨äºæ·»åŠ é—´è·æ ‡æ³¨ï¼‰
                if (simState.scenario !== 'closed') {
                    const padding = 30;
                    const canvasWidth = mainCanvas.width;
                    const drawWidth = canvasWidth - 2 * padding;
                    const segmentWidth = drawWidth / simState.intervalCount;
                    const y = mainCanvas.height / 2 + 20;
                    
                    // æ£€æŸ¥æ¯ä¸ªçº¿æ®µ
                    for (let i = 0; i < simState.intervalCount; i++) {
                        const x1 = padding + i * segmentWidth;
                        const x2 = padding + (i + 1) * segmentWidth;
                        const segmentCenterX = (x1 + x2) / 2;
                        
                        // æ£€æŸ¥ç‚¹å‡»æ˜¯å¦åœ¨çº¿æ®µèŒƒå›´å†…
                        if (clickX >= x1 && clickX <= x2 && Math.abs(clickY - y) <= 10) {
                            // æ£€æŸ¥è¯¥çº¿æ®µæ˜¯å¦å·²æœ‰æ ‡æ³¨
                            const existingLabel = simState.spacingLabels.find(label => label.segmentIndex === i);
                            
                            if (existingLabel) {
                                // ç§»é™¤å·²å­˜åœ¨çš„æ ‡æ³¨
                                simState.spacingLabels = simState.spacingLabels.filter(label => label.segmentIndex !== i);
                            } else {
                                // æ·»åŠ æ–°çš„é—´è·æ ‡æ³¨
                                simState.spacingLabels.push({
                                    segmentIndex: i,
                                    x: segmentCenterX,
                                    y: y - 30,
                                    spacing: simState.spacing
                                });
                            }
                            
                            drawMainVisualization();
                            break;
                        }
                    }
                } else {
                    // å°é—­å›¾å½¢çš„ç‰¹æ®Šå¤„ç†ï¼šç‚¹å‡»åœ†å¼§å¯ä»¥æ˜¾ç¤ºé—´è·æ ‡æ³¨
                    const radius = Math.min(mainCanvas.width, mainCanvas.height) / 2 - 30;
                    const centerX = mainCanvas.width / 2;
                    const centerY = mainCanvas.height / 2;
                    
                    // è®¡ç®—ç‚¹å‡»ä½ç½®åˆ°åœ†å¿ƒçš„è·ç¦»
                    const distanceToCenter = Math.sqrt(
                        Math.pow(clickX - centerX, 2) + Math.pow(clickY - centerY, 2)
                    );
                    
                    // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨åœ†å¼§é™„è¿‘ï¼ˆå…è®¸ä¸€å®šè¯¯å·®èŒƒå›´ï¼‰
                    if (Math.abs(distanceToCenter - radius) <= 15) {
                        // è®¡ç®—ç‚¹å‡»ä½ç½®å¯¹åº”çš„è§’åº¦
                        const angle = Math.atan2(clickY - centerY, clickX - centerX);
                        let normalizedAngle = angle + Math.PI / 2; // è°ƒæ•´è§’åº¦ï¼Œä½¿é¡¶éƒ¨ä¸º0
                        if (normalizedAngle < 0) normalizedAngle += 2 * Math.PI;
                        
                        // ç¡®å®šç‚¹å‡»çš„æ˜¯å“ªä¸ªå¼§æ®µ
                        const segmentAngle = (2 * Math.PI) / simState.intervalCount;
                        const segmentIndex = Math.floor(normalizedAngle / segmentAngle);
                        
                        // è®¡ç®—è¯¥å¼§æ®µçš„ä¸­ç‚¹ä½ç½®
                        const midAngle = (segmentIndex + 0.5) * segmentAngle - Math.PI / 2;
                        const labelX = centerX + (radius - 40) * Math.cos(midAngle);
                        const labelY = centerY + (radius - 40) * Math.sin(midAngle);
                        
                        // æ£€æŸ¥è¯¥å¼§æ®µæ˜¯å¦å·²æœ‰æ ‡æ³¨
                        const existingLabel = simState.spacingLabels.find(label => label.segmentIndex === segmentIndex);
                        
                        if (existingLabel) {
                            // ç§»é™¤å·²å­˜åœ¨çš„æ ‡æ³¨
                            simState.spacingLabels = simState.spacingLabels.filter(label => label.segmentIndex !== segmentIndex);
                        } else {
                            // æ·»åŠ æ–°çš„é—´è·æ ‡æ³¨
                            simState.spacingLabels.push({
                                segmentIndex: segmentIndex,
                                x: labelX,
                                y: labelY,
                                spacing: simState.spacing,
                                isClosed: true
                            });
                        }
                        
                        drawMainVisualization();
                    }
                }
            }

            function drawTree(ctx, x, y, size = 1) {
                const crownRadius = 10 * size;
                const trunkHeight = 10 * size;
                const trunkWidth = 4 * size;
                
                ctx.fillStyle = '#8d5524'; // Trunk
                ctx.fillRect(x - trunkWidth / 2, y - trunkHeight, trunkWidth, trunkHeight);
                ctx.fillStyle = '#22c55e'; // Crown
                ctx.beginPath();
                ctx.arc(x, y - trunkHeight - crownRadius / 2, crownRadius, 0, 2 * Math.PI);
                ctx.fill();
            }

            function drawMainVisualization() {
                mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                const padding = 30;
                const canvasWidth = mainCanvas.width;
                const canvasHeight = mainCanvas.height;
                const y = canvasHeight / 2 + 20;

                // é‡ç½®å¯ç‚¹å‡»ç‚¹æ•°ç»„
                simState.clickablePoints = [];

                if (!simState.isCalculated || simState.intervalCount <= 0) return;

                if (simState.scenario === 'closed') {
                    const radius = Math.min(canvasWidth, canvasHeight) / 2 - padding;
                    const centerX = canvasWidth / 2;
                    const centerY = canvasHeight / 2;
                    
                    mainCtx.beginPath();
                    mainCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    mainCtx.strokeStyle = '#9ca3af';
                    mainCtx.lineWidth = 2;
                    mainCtx.setLineDash([5, 5]);
                    mainCtx.stroke();
                    mainCtx.setLineDash([]);

                    // è®¡ç®—å¯ç‚¹å‡»çš„ç‚¹ä½ç½®
                    for (let i = 0; i < simState.intervalCount; i++) {
                        const angle = (i / simState.intervalCount) * 2 * Math.PI - Math.PI / 2;
                        const x = centerX + radius * Math.cos(angle);
                        const y_point = centerY + radius * Math.sin(angle);
                        simState.clickablePoints.push({x, y: y_point, index: i});
                    }

                    // ç»˜åˆ¶å·²ç§æ¤çš„æ ‘
                    simState.plantedTrees.forEach(tree => {
                        drawTree(mainCtx, tree.x, tree.y);
                    });

                    // ç»˜åˆ¶å¯ç‚¹å‡»çš„ç‚¹ï¼ˆå¦‚æœè¿˜æ²¡ç§æ ‘ï¼‰
                    simState.clickablePoints.forEach(point => {
                        const isPlanted = simState.plantedTrees.some(tree => 
                            Math.abs(tree.x - point.x) < 10 && Math.abs(tree.y - point.y) < 10
                        );
                        if (!isPlanted) {
                            mainCtx.beginPath();
                            mainCtx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                            
                            // æ ¹æ®æ˜¯å¦å¯ä»¥ç§æ ‘æ˜¾ç¤ºä¸åŒé¢œè‰²
                            if (point.canActuallyPlant !== false) {
                                mainCtx.fillStyle = '#fbbf24'; // å¯ç§æ ‘ï¼šé»„è‰²
                                mainCtx.strokeStyle = '#f59e0b';
                            } else {
                                mainCtx.fillStyle = '#d1d5db'; // ä¸å¯ç§æ ‘ï¼šç°è‰²
                                mainCtx.strokeStyle = '#9ca3af';
                            }
                            
                            mainCtx.fill();
                            mainCtx.lineWidth = 2;
                            mainCtx.stroke();
                        }
                    });
                } else {
                    const drawWidth = canvasWidth - 2 * padding;
                    const segmentWidth = drawWidth / simState.intervalCount;

                    mainCtx.beginPath();
                    mainCtx.moveTo(padding, y);
                    mainCtx.lineTo(canvasWidth - padding, y);
                    mainCtx.strokeStyle = '#9ca3af';
                    mainCtx.lineWidth = 2;
                    mainCtx.stroke();

                    // ç»˜åˆ¶åˆ»åº¦çº¿å¹¶è®¡ç®—å¯ç‚¹å‡»çš„ç‚¹
                    for (let i = 0; i <= simState.intervalCount; i++) {
                        const x = padding + i * segmentWidth;
                        mainCtx.beginPath();
                        mainCtx.moveTo(x, y - 5);
                        mainCtx.lineTo(x, y + 5);
                        mainCtx.strokeStyle = '#6b7280';
                        mainCtx.stroke();

                        // æ ¹æ®æƒ…å¢ƒç¡®å®šå“ªäº›ç‚¹å¯ä»¥ç‚¹å‡»
                        let canPlant = false;
                        let canActuallyPlant = true;
                        
                        switch (simState.scenario) {
                            case 'both':
                                canPlant = true;
                                break;
                            case 'one':
                                // ä¸€ç«¯æ ½ï¼šä¸¤ç«¯åªèƒ½2é€‰ä¸€ï¼Œä¸­é—´éƒ½å¯ä»¥ç§
                                canPlant = true;
                                // æ£€æŸ¥æ˜¯å¦å·²ç»ç§äº†ç«¯ç‚¹
                                const hasLeftEnd = simState.plantedTrees.some(tree => tree.index === 0);
                                const hasRightEnd = simState.plantedTrees.some(tree => tree.index === simState.intervalCount);
                                
                                if (i === 0) {
                                    // å·¦ç«¯ç‚¹ï¼šå¦‚æœå³ç«¯å·²ç§åˆ™ä¸èƒ½ç§
                                    canActuallyPlant = !hasRightEnd;
                                } else if (i === simState.intervalCount) {
                                    // å³ç«¯ç‚¹ï¼šå¦‚æœå·¦ç«¯å·²ç§åˆ™ä¸èƒ½ç§
                                    canActuallyPlant = !hasLeftEnd;
                                } else {
                                    // ä¸­é—´ç‚¹ï¼šæ€»æ˜¯å¯ä»¥ç§
                                    canActuallyPlant = true;
                                }
                                break;
                            case 'none':
                                canPlant = i > 0 && i < simState.intervalCount;
                                break;
                        }
                        
                        if (canPlant) {
                            simState.clickablePoints.push({x, y, index: i, canActuallyPlant});
                        }
                    }

                    // ç»˜åˆ¶å·²ç§æ¤çš„æ ‘
                    simState.plantedTrees.forEach(tree => {
                        drawTree(mainCtx, tree.x, tree.y);
                    });

                    // ç»˜åˆ¶å¯ç‚¹å‡»çš„ç‚¹ï¼ˆå¦‚æœè¿˜æ²¡ç§æ ‘ï¼‰
                    simState.clickablePoints.forEach(point => {
                        const isPlanted = simState.plantedTrees.some(tree => 
                            Math.abs(tree.x - point.x) < 10 && Math.abs(tree.y - point.y) < 10
                        );
                        if (!isPlanted) {
                            mainCtx.beginPath();
                            mainCtx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                            mainCtx.fillStyle = '#fbbf24';
                            mainCtx.fill();
                            mainCtx.strokeStyle = '#f59e0b';
                            mainCtx.lineWidth = 2;
                            mainCtx.stroke();
                        }
                    });
                }
                
                // ç»˜åˆ¶é—´è·æ ‡æ³¨
                simState.spacingLabels.forEach(label => {
                    mainCtx.fillStyle = '#008000';
                    mainCtx.font = 'bold 20px Arial';
                    mainCtx.textAlign = 'center';
                    mainCtx.fillText(`${label.spacing}ç±³`, label.x, label.y);
                    
                    // ç»˜åˆ¶æŒ‡ç¤ºçº¿
                    mainCtx.strokeStyle = '#008000';
                    mainCtx.lineWidth = 1;
                    mainCtx.setLineDash([3, 3]);
                    mainCtx.beginPath();
                    
                    if (label.isClosed) {
                         // å°é—­å›¾å½¢çš„æŒ‡ç¤ºçº¿ï¼šä»æ ‡æ³¨ä½ç½®æœå¤–æŒ‡å‘åœ†å¼§å¤–ä¾§
                         const centerX = mainCanvas.width / 2;
                         const centerY = mainCanvas.height / 2;
                         const radius = Math.min(mainCanvas.width, mainCanvas.height) / 2 - 30;
                         
                         // è®¡ç®—ä»åœ†å¿ƒåˆ°æ ‡æ³¨ä½ç½®çš„æ–¹å‘ï¼ˆæœå¤–ï¼‰
                         const dx = label.x - centerX;
                         const dy = label.y - centerY;
                         const distance = Math.sqrt(dx * dx + dy * dy);
                         const unitX = dx / distance;
                         const unitY = dy / distance;
                         
                         // ç»˜åˆ¶æŒ‡ç¤ºçº¿ï¼šä»æ ‡æ³¨ä½ç½®æœå¤–å»¶ä¼¸
                         mainCtx.moveTo(label.x + unitX * 5, label.y + unitY * 5);
                         mainCtx.lineTo(label.x + unitX * 25, label.y + unitY * 25);
                     } else {
                        // ç›´çº¿çš„æŒ‡ç¤ºçº¿
                        mainCtx.moveTo(label.x, label.y + 5);
                        mainCtx.lineTo(label.x, label.y + 25);
                    }
                    
                    mainCtx.stroke();
                    mainCtx.setLineDash([]);
                });
            }
            
            // Setup Navigation Listeners
            navSimulator.addEventListener('click', showSimulator);
            navKnowledge.addEventListener('click', showKnowledge);
            
            // Setup Main Simulator Listeners
            resetBtn.addEventListener('click', fullReset);
            prevStepBtn.addEventListener('click', () => handleStep(-1));
            nextStepBtn.addEventListener('click', () => handleStep(1));
            mainCanvas.addEventListener('click', handleCanvasClick);
            scenarioButtons.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON' && e.target.dataset.scenario) {
                    // ä¿å­˜å½“å‰çŠ¶æ€
                    if (simState.isCalculated) {
                        saveCurrentState();
                    }
                    
                    simState.scenario = e.target.dataset.scenario;
                    document.querySelectorAll('#scenario-buttons button').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // åˆ‡æ¢æƒ…å¢ƒæ—¶éšè—é—´è·é•¿åº¦æ ‡æ³¨
                    simState.spacingLabels = [];
                    
                    // è‡ªåŠ¨å¼€å§‹è®¡ç®—
                    startCalculation();
                }
            });
            ['input', 'change'].forEach(evt => {
                totalLengthInput.addEventListener(evt, () => {
                    if (simState.isCalculated) {
                        saveCurrentState();
                        startCalculation();
                    }
                });
                spacingInput.addEventListener(evt, () => {
                    if (simState.isCalculated) {
                        saveCurrentState();
                        startCalculation();
                    }
                });
            });


            // Table Animations
            const tableCanvases = document.querySelectorAll('.table-canvas');
            let globalAnimationPlaying = true;
            const animationControl = document.getElementById('animation-control');
            
            tableCanvases.forEach(canvas => {
                const ctx = canvas.getContext('2d');
                const scenario = canvas.dataset.scenario;
                let frame = 0;
                const totalFrames = 180; // 3 seconds at 60fps
                const intervals = 4;

                function animate() {
                    if (globalAnimationPlaying) {
                        frame++;
                        if (frame > totalFrames) frame = 0;
                    }
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const padding = 10;
                    const y = canvas.height / 2 + 10;
                    
                    if (scenario === 'closed') {
                        const radius = Math.min(canvas.width, canvas.height)/2 - padding;
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                        ctx.strokeStyle = '#9ca3af';
                        ctx.stroke();

                        let treesToShow;
                        if (globalAnimationPlaying) {
                            treesToShow = Math.floor((frame / totalFrames) * intervals) + 1;
                        } else {
                            treesToShow = intervals; // æ˜¾ç¤ºå®Œæ•´çŠ¶æ€
                        }
                        
                        for (let i = 0; i < treesToShow; i++) {
                           const angle = (i / intervals) * 2 * Math.PI - Math.PI / 2;
                           drawTree(ctx, centerX + radius * Math.cos(angle), centerY + radius * Math.sin(angle), 0.6);
                        }
                    } else {
                        const drawWidth = canvas.width - 2 * padding;
                        const segmentWidth = drawWidth / intervals;
                        ctx.beginPath();
                        ctx.moveTo(padding, y);
                        ctx.lineTo(canvas.width - padding, y);
                        ctx.strokeStyle = '#9ca3af';
                        ctx.stroke();
                        
                        let treeCount;
                        if (scenario === 'both') treeCount = intervals + 1;
                        if (scenario === 'one') treeCount = intervals;
                        if (scenario === 'none') treeCount = intervals - 1;

                        let treesToShow;
                        if (globalAnimationPlaying) {
                            treesToShow = Math.floor((frame / totalFrames) * treeCount) + 1;
                        } else {
                            treesToShow = treeCount; // æ˜¾ç¤ºå®Œæ•´çŠ¶æ€
                        }

                        for (let i = 0; i < treesToShow; i++) {
                            let x;
                            if (scenario === 'both') x = padding + i * segmentWidth;
                            if (scenario === 'one') x = padding + i * segmentWidth;
                            if (scenario === 'none') x = padding + (i + 1) * segmentWidth;
                            drawTree(ctx, x, y, 0.6);
                        }
                    }
                    
                    requestAnimationFrame(animate);
                }
                animate();
            });
            
            // æ·»åŠ ç‚¹å‡»è¡¨å¤´æ§åˆ¶æ‰€æœ‰åŠ¨ç”»çš„åŠŸèƒ½
            animationControl.addEventListener('click', () => {
                globalAnimationPlaying = !globalAnimationPlaying;
                animationControl.textContent = globalAnimationPlaying ? 'æƒ…å¢ƒåŠ¨å›¾ â¸ï¸ ' : 'æƒ…å¢ƒåŠ¨å›¾ â–¶ï¸';
            });
            
            // è®¾ç½®canvaså°ºå¯¸
            function resizeCanvas() {
                const rect = mainCanvas.getBoundingClientRect();
                const style = window.getComputedStyle(mainCanvas);
                const paddingLeft = parseFloat(style.paddingLeft) || 0;
                const paddingRight = parseFloat(style.paddingRight) || 0;
                const paddingTop = parseFloat(style.paddingTop) || 0;
                const paddingBottom = parseFloat(style.paddingBottom) || 0;
                
                // è®¾ç½®canvaså®é™…ç»˜åˆ¶åŒºåŸŸå°ºå¯¸ï¼ˆæ’é™¤paddingï¼‰
                mainCanvas.width = rect.width - paddingLeft - paddingRight;
                mainCanvas.height = rect.height - paddingTop - paddingBottom;
                drawMainVisualization();
            }
            
            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', resizeCanvas);
            
            // Initial setup
            resizeCanvas();
            showSimulator(); // é»˜è®¤æ˜¾ç¤ºäº¤äº’æ¨¡æ‹Ÿå™¨
            startCalculation(); // é»˜è®¤å¼€å§‹è®¡ç®—
        });
    </script>
</body>
</html>