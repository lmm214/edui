<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>平行四边形的第四点在哪儿呢？</title>
    <style>
        :root {
            --dot-color: #e5e5e5;
            --active-blue: #2196F3;
            --ghost-orange: rgba(255, 152, 0, 0.3);
            --active-orange: #FF9800;
            --line-main: #333;
            --line-history: #e0e0e0;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #fff;
            font-family: sans-serif;
            touch-action: none;
        }

        #svg-canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            cursor: grab;
            user-select: none;
        }

        #svg-canvas:active {
            cursor: grabbing;
        }

        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 200;
        }

        .overlay {
            position: fixed;
            pointer-events: none;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
        }

        .header {
            top: 30px;
        }

        .footer {
            bottom: 40px;
        }

        .glass-panel {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px 40px;
            border-radius: 50px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        h1 {
            margin: 0;
            font-size: 22px;
            color: #333;
            cursor: pointer;
            user-select: none;
        }

        .btn-group {
            display: flex;
            gap: 15px;
        }

        button {
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: 0.3s;
            font-weight: bold;
            background: var(--active-blue);
            color: white;
        }

        button:disabled {
            background: #eee;
            color: #aaa;
            cursor: not-allowed;
        }

        #reset-btn {
            background: #f5f5f5;
            color: #666;
        }

        .grid-dot {
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
        }

        .grid-line {
            stroke: var(--dot-color);
            stroke-width: 2;
            pointer-events: none;
        }

        .shape-line {
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: none;
        }

        .history-line {
            pointer-events: none;
        }

        .dot-hit-area {
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            pointer-events: all;
        }

        .top-right-tool {
            position: fixed;
            top: 30px;
            right: 30px;
            z-index: 150;
        }

        .icon-btn {
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.3s;
        }

        .icon-btn:hover {
            transform: scale(1.05);
            background: #fff;
        }

        .icon-btn svg {
            width: 24px;
            height: 24px;
            fill: #666;
        }
    </style>
</head>

<body>

    <div class="overlay header">
        <div class="glass-panel">
            <h1 id="title">平行四边形的第四点在哪儿呢？</h1>
        </div>
    </div>

    <div class="top-right-tool">
        <div class="icon-btn" id="grid-toggle-btn" title="切换模式">
            <svg viewBox="0 0 24 24">
                <path id="btn-icon-path" d="M5,18 L8,6 L16,6 L19,18 Z" />
            </svg>
        </div>
    </div>

    <canvas id="confetti-canvas"></canvas>

    <svg id="svg-canvas">
        <g id="view-group">
            <g id="background-layer"></g>
            <g id="history-layer"></g>
            <g id="main-line-layer"></g>
            <g id="dot-layer"></g>
        </g>
    </svg>

    <div class="overlay footer">
        <div class="glass-panel">
            <div class="btn-group">
                <button id="verify-btn" disabled>验证当前</button>
                <button id="reset-btn">清空重置</button>
            </div>
        </div>
    </div>

    <script>
        const svg = document.getElementById('svg-canvas');
        const viewGroup = document.getElementById('view-group');
        const dotLayer = document.getElementById('dot-layer');
        const mainLineLayer = document.getElementById('main-line-layer');
        const backgroundLayer = document.getElementById('background-layer');
        const historyLayer = document.getElementById('history-layer');
        const title = document.getElementById('title');
        const verifyBtn = document.getElementById('verify-btn');
        const resetBtn = document.getElementById('reset-btn');
        const gridToggleBtn = document.getElementById('grid-toggle-btn');
        const confettiCanvas = document.getElementById('confetti-canvas');
        const ctx = confettiCanvas.getContext('2d');

        const SPACING = 100;
        const HIT_RADIUS = 40;
        let selectedPoints = [];
        let allGridDots = [];
        let smartMode = false;
        let ghostPoints = [];
        let currentActiveIndex = -1;
        let gridMode = 'dots'; // 'dots' or 'lines'

        let scale = 1;
        let offset = { x: 0, y: 0 };
        let isDragging = false;
        let lastPointerPos = { x: 0, y: 0 };
        let hasMovedSignificantly = false;

        let pointers = [];
        let initialPinchDist = 0;
        let initialScale = 1;

        function init() {
            dotLayer.innerHTML = '';
            mainLineLayer.innerHTML = '';
            historyLayer.innerHTML = '';
            backgroundLayer.innerHTML = '';
            selectedPoints = [];
            allGridDots = [];
            ghostPoints = [];
            smartMode = false;
            currentActiveIndex = -1;
            verifyBtn.disabled = true;

            scale = 1;
            offset = { x: 0, y: 0 };
            updateTransform();

            title.innerText = gridMode === 'dots' ? '平行四边形的第四点在哪儿呢？' : '梯形的第四点在哪里？';

            const w = window.innerWidth, h = window.innerHeight;
            confettiCanvas.width = w;
            confettiCanvas.height = h;

            if (gridMode === 'dots') {
                const gridRange = 25;
                for (let i = -gridRange; i <= gridRange; i++) {
                    for (let j = -gridRange; j <= gridRange; j++) {
                        const x = w / 2 + i * SPACING;
                        const y = h / 2 + j * SPACING;
                        createDot(x, y);
                    }
                }
            } else {
                // 10 vertical, 5 horizontal lines
                const numV = 10;
                const numH = 5;
                const totalW = (numV - 1) * SPACING;
                const totalH = (numH - 1) * SPACING;
                const startX = w / 2 - totalW / 2;
                const startY = h / 2 - totalH / 2;

                // Draw Lines
                for (let i = 0; i < numV; i++) {
                    const x = startX + i * SPACING;
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", x); line.setAttribute("y1", startY);
                    line.setAttribute("x2", x); line.setAttribute("y2", startY + totalH);
                    line.setAttribute("class", "grid-line");
                    backgroundLayer.appendChild(line);
                }
                for (let j = 0; j < numH; j++) {
                    const y = startY + j * SPACING;
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", startX); line.setAttribute("y1", y);
                    line.setAttribute("x2", startX + totalW); line.setAttribute("y2", y);
                    line.setAttribute("class", "grid-line");
                    backgroundLayer.appendChild(line);
                }

                // Create Intersections
                for (let i = 0; i < numV; i++) {
                    for (let j = 0; j < numH; j++) {
                        const x = startX + i * SPACING;
                        const y = startY + j * SPACING;
                        createDot(x, y);
                    }
                }
            }
        }

        function createDot(x, y) {
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

            // 视觉显示点
            const visual = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            visual.setAttribute("cx", x); visual.setAttribute("cy", y);
            visual.setAttribute("r", 6); visual.setAttribute("fill", "var(--dot-color)");
            visual.setAttribute("class", "grid-dot");

            // 交互热区
            const hit = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            hit.setAttribute("cx", x); hit.setAttribute("cy", y);
            hit.setAttribute("r", HIT_RADIUS / scale);
            hit.setAttribute("fill", "rgba(0,0,0,0)");
            hit.setAttribute("class", "dot-hit-area");

            hit.addEventListener('pointerdown', (e) => e.stopPropagation());
            hit.onclick = (e) => {
                if (!hasMovedSignificantly) onDotClick(x, y, visual);
            };

            g.appendChild(visual);
            g.appendChild(hit);
            dotLayer.appendChild(g);
            allGridDots.push({ x, y, el: visual, hit: hit });
        }

        function updateTransform() {
            viewGroup.setAttribute('transform', `translate(${offset.x}, ${offset.y}) scale(${scale})`);

            // 关键修复：动态调整感应区半径，确保在不同缩放级别下点击范围在屏幕上感知恒定
            const dynamicHitR = HIT_RADIUS / scale;
            allGridDots.forEach(d => {
                if (d.hit) d.hit.setAttribute("r", dynamicHitR);
            });
        }

        svg.onpointerdown = (e) => {
            pointers.push(e);
            isDragging = true;
            lastPointerPos = { x: e.clientX, y: e.clientY };
            hasMovedSignificantly = false;

            if (pointers.length === 2) {
                initialPinchDist = Math.hypot(pointers[0].clientX - pointers[1].clientX, pointers[0].clientY - pointers[1].clientY);
                initialScale = scale;
            }
        };

        window.onpointermove = (e) => {
            const idx = pointers.findIndex(p => p.pointerId === e.pointerId);
            if (idx !== -1) pointers[idx] = e;

            if (!isDragging) return;

            if (pointers.length === 1) {
                const dx = e.clientX - lastPointerPos.x;
                const dy = e.clientY - lastPointerPos.y;
                offset.x += dx;
                offset.y += dy;
                lastPointerPos = { x: e.clientX, y: e.clientY };

                if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                    hasMovedSignificantly = true;
                }
                updateTransform();
            } else if (pointers.length === 2) {
                hasMovedSignificantly = true;
                const dist = Math.hypot(pointers[0].clientX - pointers[1].clientX, pointers[0].clientY - pointers[1].clientY);
                const midX = (pointers[0].clientX + pointers[1].clientX) / 2;
                const midY = (pointers[0].clientY + pointers[1].clientY) / 2;

                const zoomDelta = (dist / initialPinchDist - 1) * 0.8 + 1;
                const newScale = initialScale * zoomDelta;
                zoomAt(midX, midY, newScale / scale);
            }
        };

        window.onpointerup = (e) => {
            pointers = pointers.filter(p => p.pointerId !== e.pointerId);
            if (pointers.length < 2) initialPinchDist = 0;
            if (pointers.length === 0) isDragging = false;
        };

        svg.onwheel = (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.96 : 1.04;
            zoomAt(e.clientX, e.clientY, zoomFactor);
        };

        function zoomAt(clientX, clientY, factor) {
            const newScale = Math.min(Math.max(scale * factor, 0.3), 5);
            const realFactor = newScale / scale;
            offset.x = clientX - (clientX - offset.x) * realFactor;
            offset.y = clientY - (clientY - offset.y) * realFactor;
            scale = newScale;
            updateTransform();
        }

        function onDotClick(x, y, el) {
            if (smartMode) return;

            const idx = selectedPoints.findIndex(p => p.x === x && p.y === y);
            if (idx > -1) {
                selectedPoints.splice(idx, 1);
                el.setAttribute("fill", "var(--dot-color)");
                el.setAttribute("r", 6);
                mainLineLayer.innerHTML = '';
            } else if (selectedPoints.length < 4) {
                const isFourth = selectedPoints.length === 3;
                selectedPoints.push({ x, y, el });

                if (isFourth) {
                    el.setAttribute("fill", "var(--active-orange)");
                    el.setAttribute("r", 14);
                    mainLineLayer.innerHTML = '';
                    drawShape(selectedPoints, mainLineLayer, "var(--line-main)", 8);
                } else {
                    el.setAttribute("fill", "var(--active-blue)");
                    el.setAttribute("r", 12);
                }
            }
            verifyBtn.disabled = selectedPoints.length !== 4;
        }

        function sortPoints(pts) {
            const cx = pts.reduce((a, b) => a + b.x, 0) / pts.length;
            const cy = pts.reduce((a, b) => a + b.y, 0) / pts.length;
            return [...pts].sort((a, b) => Math.atan2(a.y - cy, a.x - cx) - Math.atan2(b.y - cy, b.x - cx));
        }

        function drawShape(pts, layer, color, width, isDash = false) {
            if (pts.length < 3) return;
            const sorted = sortPoints(pts);
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            let d = `M ${sorted[0].x} ${sorted[0].y}`;
            for (let i = 1; i < sorted.length; i++) d += ` L ${sorted[i].x} ${sorted[i].y}`;
            d += " Z";
            path.setAttribute("d", d);
            path.setAttribute("fill", "none");
            path.setAttribute("stroke", color);
            path.setAttribute("stroke-width", width);
            if (isDash) path.setAttribute("stroke-dasharray", "5,5");
            path.setAttribute("class", layer === historyLayer ? "history-line" : "shape-line");
            layer.appendChild(path);
        }

        function isParallel(a, b, c, d) {
            return Math.abs((b.y - a.y) * (d.x - c.x) - (b.x - a.x) * (d.y - c.y)) < 1;
        }

        function distSq(a, b) {
            return (b.x - a.x) ** 2 + (b.y - a.y) ** 2;
        }

        function isTrapezoid(p) {
            // p 已经排过序
            const s1p = isParallel(p[0], p[1], p[2], p[3]);
            const s1lenMatch = Math.abs(distSq(p[0], p[1]) - distSq(p[2], p[3])) < 10;
            const s2p = isParallel(p[1], p[2], p[3], p[0]);
            const s2lenMatch = Math.abs(distSq(p[1], p[2]) - distSq(p[3], p[0])) < 10;

            // 排除平行四边形：两组对边均平行的情况
            if (s1p && s2p) return false;
            // 梯形：只有一组对边平行（且必然长度不等，因为如果长度相等且平行则是平行四边形）
            return s1p || s2p;
        }

        function isParallelogram(p) {
            const s1p = isParallel(p[0], p[1], p[2], p[3]);
            const s2p = isParallel(p[1], p[2], p[3], p[0]);
            return s1p && s2p;
        }

        title.onclick = () => {
            if (selectedPoints.length !== 3 || smartMode) return;
            smartMode = true;

            allGridDots.forEach(dot => {
                if (selectedPoints.some(p => p.x === dot.x && p.y === dot.y)) return;

                const pts = sortPoints([...selectedPoints, dot]);
                const isValid = gridMode === 'dots' ? isParallelogram(pts) : isTrapezoid(pts);

                if (isValid) {
                    dot.el.setAttribute("fill", "var(--ghost-orange)");
                    dot.el.setAttribute("r", 10);
                    dot.hit.onclick = (e) => {
                        if (!hasMovedSignificantly) activateGhostCase(ghostPoints.length, dot);
                    };
                    ghostPoints.push({ dot, index: ghostPoints.length });
                }
            });
        };

        function activateGhostCase(index, dotObj) {
            if (currentActiveIndex !== -1 && currentActiveIndex !== index) {
                const oldCase = ghostPoints.find(g => g.index === currentActiveIndex);
                drawShape([...selectedPoints, oldCase.dot], historyLayer, "var(--line-history)", 2);
            }

            ghostPoints.forEach(g => {
                if (g.index === index) {
                    g.dot.el.setAttribute("fill", "var(--active-orange)");
                    g.dot.el.setAttribute("r", 14);
                } else {
                    g.dot.el.setAttribute("fill", "var(--ghost-orange)");
                    g.dot.el.setAttribute("r", 10);
                }
            });

            mainLineLayer.innerHTML = '';
            drawShape([...selectedPoints, dotObj], mainLineLayer, "var(--line-main)", 8);

            currentActiveIndex = index;
            verifyBtn.disabled = false;
        }

        async function verify() {
            let finalPts = [];
            if (smartMode && currentActiveIndex !== -1) {
                const activeGhost = ghostPoints.find(g => g.index === currentActiveIndex);
                finalPts = [...selectedPoints, activeGhost.dot];
            } else if (selectedPoints.length === 4) {
                finalPts = [...selectedPoints];
            } else {
                return;
            }

            const pts = sortPoints(finalPts);
            verifyBtn.disabled = true;

            let success = false;
            if (gridMode === 'dots') {
                success = isParallelogram(pts);
                if (success) {
                    await animateVector(pts[0], pts[1], pts[3], pts[2], "#FF5722");
                    await animateVector(pts[1], pts[2], pts[0], pts[3], "#9C27B0");
                }
            } else {
                success = isTrapezoid(pts);
                if (success) {
                    if (isParallel(pts[0], pts[1], pts[2], pts[3])) {
                        await animateVector(pts[0], pts[1], pts[3], pts[2], "#FF5722");
                    } else {
                        await animateVector(pts[1], pts[2], pts[0], pts[3], "#9C27B0");
                    }
                }
            }

            if (success) {
                triggerConfetti();
            } else {
                // 震动或提示
                title.style.color = '#F44336';
                setTimeout(() => title.style.color = '#333', 500);
            }

            verifyBtn.disabled = false;
        }

        function animateVector(s1, s2, t1, t2, col) {
            return new Promise(res => {
                const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
                l.setAttribute("x1", s1.x); l.setAttribute("y1", s1.y);
                l.setAttribute("x2", s2.x); l.setAttribute("y2", s2.y);
                l.setAttribute("stroke", col); l.setAttribute("stroke-width", 10);
                l.setAttribute("stroke-dasharray", "10,10");
                viewGroup.appendChild(l);

                const anim = l.animate([
                    { transform: 'translate(0,0)' },
                    { transform: `translate(${t1.x - s1.x}px, ${t1.y - s1.y}px)` }
                ], { duration: 1000, easing: 'ease-in-out', fill: 'forwards' });

                anim.onfinish = () => {
                    setTimeout(() => { l.remove(); res(); }, 200);
                };
            });
        }

        let particles = [];
        const colors = ['#2196F3', '#FF9800', '#4CAF50', '#FF4081', '#FFEB3B'];

        class Particle {
            constructor() {
                this.x = window.innerWidth / 2;
                this.y = window.innerHeight / 2;
                this.vx = (Math.random() - 0.5) * 20;
                this.vy = (Math.random() - 1) * 15;
                this.gravity = 0.5;
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.w = Math.random() * 10 + 5;
                this.h = Math.random() * 10 + 5;
                this.rotation = Math.random() * 360;
                this.rSpeed = Math.random() * 10 - 5;
                this.life = 100;
            }
            update() {
                this.vx *= 0.99;
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rSpeed;
                this.life -= 1;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation * Math.PI / 180);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life / 100;
                ctx.fillRect(-this.w / 2, -this.h / 2, this.w, this.h);
                ctx.restore();
            }
        }

        function triggerConfetti() {
            particles = [];
            for (let i = 0; i < 100; i++) particles.push(new Particle());
            animateParticles();
        }

        function animateParticles() {
            if (particles.length === 0) return;
            ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
            requestAnimationFrame(animateParticles);
        }

        resetBtn.onclick = init;
        verifyBtn.onclick = verify;
        const btnIconPath = document.getElementById('btn-icon-path');
        const iconTrapezoid = "M5,18 L8,6 L16,6 L19,18 Z";
        const iconParallelogram = "M3,18 L7,6 L21,6 L17,18 Z";

        gridToggleBtn.onclick = () => {
            gridMode = (gridMode === 'dots' ? 'lines' : 'dots');
            btnIconPath.setAttribute('d', gridMode === 'dots' ? iconTrapezoid : iconParallelogram);
            init();
        };
        window.onresize = () => {
            const w = window.innerWidth, h = window.innerHeight;
            confettiCanvas.width = w;
            confettiCanvas.height = h;
        };

        init();  
    </script>
</body>

</html>