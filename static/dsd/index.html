<!DOCTYPE html>  
<html lang="zh-CN">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">  
    <title>第四个顶点在哪儿呢？</title>  
    <style>  
        :root {  
            --dot-color: #e5e5e5;  
            --active-blue: #2196F3;  
            --ghost-orange: rgba(255, 152, 0, 0.3); 
            --active-orange: #FF9800;              
            --line-main: #333;  
            --line-history: #e0e0e0;               
        }  
  
        body, html {  
            margin: 0; padding: 0;  
            width: 100vw; height: 100vh;  
            overflow: hidden;  
            background-color: #fff;  
            font-family: sans-serif;  
            touch-action: none; 
        }  
  
        #svg-canvas { 
            width: 100vw; 
            height: 100vh; 
            display: block; 
            cursor: grab;
            user-select: none;
        }  
        #svg-canvas:active { cursor: grabbing; }
  
        #confetti-canvas {
            position: fixed; top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; z-index: 200;
        }
  
        .overlay {  
            position: fixed; pointer-events: none;  
            width: 100%; display: flex; flex-direction: column; align-items: center; z-index: 100;  
        }  
        .header { top: 30px; }  
        .footer { bottom: 40px; }  
  
        .glass-panel {  
            pointer-events: auto;  
            background: rgba(255, 255, 255, 0.9);  
            backdrop-filter: blur(10px);  
            padding: 15px 40px; border-radius: 50px;  
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);  
            border: 1px solid rgba(0,0,0,0.05);  
        }  
  
        h1 { margin: 0; font-size: 22px; color: #333; cursor: pointer; user-select: none; }  
  
        .btn-group { display: flex; gap: 15px; }  
        button {  
            padding: 12px 30px; font-size: 16px; border: none; border-radius: 25px;  
            cursor: pointer; transition: 0.3s; font-weight: bold;  
            background: var(--active-blue); color: white;  
        }  
        button:disabled { background: #eee; color: #aaa; cursor: not-allowed; }  
        #reset-btn { background: #f5f5f5; color: #666; }  
  
        .grid-dot { transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); pointer-events: none; }  
        .shape-line { stroke-linecap: round; stroke-linejoin: round; pointer-events: none; }  
        .history-line { pointer-events: none; }  
        .dot-hit-area { cursor: pointer; -webkit-tap-highlight-color: transparent; pointer-events: all; }
    </style>  
</head>  
<body>  
  
    <div class="overlay header">  
        <div class="glass-panel">  
            <h1 id="title">第四个顶点在哪儿呢？</h1>  
        </div>  
    </div>  
  
    <canvas id="confetti-canvas"></canvas>

    <svg id="svg-canvas">  
        <g id="view-group">
            <g id="history-layer"></g>  
            <g id="main-line-layer"></g>  
            <g id="dot-layer"></g>  
        </g>
    </svg>  
  
    <div class="overlay footer">  
        <div class="glass-panel">  
            <div class="btn-group">  
                <button id="verify-btn" disabled>验证当前</button>  
                <button id="reset-btn">清空重置</button>  
            </div>  
        </div>  
    </div>  
  
<script>  
    const svg = document.getElementById('svg-canvas');  
    const viewGroup = document.getElementById('view-group');
    const dotLayer = document.getElementById('dot-layer');  
    const mainLineLayer = document.getElementById('main-line-layer');  
    const historyLayer = document.getElementById('history-layer');  
    const title = document.getElementById('title');  
    const verifyBtn = document.getElementById('verify-btn');  
    const resetBtn = document.getElementById('reset-btn');  
    const confettiCanvas = document.getElementById('confetti-canvas');
    const ctx = confettiCanvas.getContext('2d');
  
    const SPACING = 100;  
    const HIT_RADIUS = 40; // 期望的屏幕物理点击半径
    const MAX_COORD_RADIUS = 45; // 坐标系中的最大半径（SPACING/2 略小一点），防止重叠
    
    let selectedPoints = [];  
    let allGridDots = [];  
    let smartMode = false;  
    let ghostPoints = [];    
    let currentActiveIndex = -1;  

    let scale = 1;
    let offset = { x: 0, y: 0 };
    let isDragging = false;
    let lastPointerPos = { x: 0, y: 0 };
    let hasMovedSignificantly = false;

    let pointers = [];
    let initialPinchDist = 0;
    let initialScale = 1;
  
    function init() {  
        dotLayer.innerHTML = '';  
        mainLineLayer.innerHTML = '';  
        historyLayer.innerHTML = '';  
        selectedPoints = [];  
        allGridDots = [];  
        ghostPoints = [];  
        smartMode = false;  
        currentActiveIndex = -1;  
        verifyBtn.disabled = true;  
        
        // 保持当前的视图变换状态，不再强制重置 scale/offset
        // 如果是首次加载（scale为1且offset为0），则不做改变
        updateTransform();

        const w = window.innerWidth, h = window.innerHeight;  
        confettiCanvas.width = w;
        confettiCanvas.height = h;

        const gridRange = 25; 
        for (let i = -gridRange; i <= gridRange; i++) {
            for (let j = -gridRange; j <= gridRange; j++) {
                const x = w/2 + i * SPACING;
                const y = h/2 + j * SPACING;
                
                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

                // 视觉显示点
                const visual = document.createElementNS("http://www.w3.org/2000/svg", "circle");  
                visual.setAttribute("cx", x); visual.setAttribute("cy", y);  
                visual.setAttribute("r", 6); visual.setAttribute("fill", "var(--dot-color)");  
                visual.setAttribute("class", "grid-dot");  
                
                // 交互热区
                const hit = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                hit.setAttribute("cx", x); hit.setAttribute("cy", y);
                hit.setAttribute("r", HIT_RADIUS);
                hit.setAttribute("fill", "rgba(0,0,0,0)");
                hit.setAttribute("class", "dot-hit-area");
                
                // 修复核心：移除 stopPropagation，允许事件冒泡以重置 hasMovedSignificantly 状态
                // hit.addEventListener('pointerdown', (e) => e.stopPropagation()); 
                
                hit.onclick = (e) => {
                    // 如果判定为没有发生显著位移（即不是拖拽操作），则触发点击
                    if (!hasMovedSignificantly) {
                        onDotClick(x, y, visual);
                    }
                };
                
                g.appendChild(visual);
                g.appendChild(hit);
                dotLayer.appendChild(g);  
                allGridDots.push({x, y, el: visual, hit: hit});  
            }
        }
        
        // 重新计算一次热区大小
        updateTransform();
    }  

    function updateTransform() {
        viewGroup.setAttribute('transform', `translate(${offset.x}, ${offset.y}) scale(${scale})`);
        
        // 修复核心2：计算动态半径
        // 逻辑：尝试保持屏幕上40px的大小 (HIT_RADIUS / scale)
        // 但限制最大值不能超过 45 (MAX_COORD_RADIUS)，防止缩小时互相重叠
        const dynamicHitR = Math.min(HIT_RADIUS / scale, MAX_COORD_RADIUS);
        
        allGridDots.forEach(d => {
            if (d.hit) d.hit.setAttribute("r", dynamicHitR);
        });
    }

    svg.onpointerdown = (e) => {
        pointers.push(e);
        isDragging = true;
        lastPointerPos = { x: e.clientX, y: e.clientY };
        hasMovedSignificantly = false; // 每次按下都重置状态

        if (pointers.length === 2) {
            initialPinchDist = Math.hypot(pointers[0].clientX - pointers[1].clientX, pointers[0].clientY - pointers[1].clientY);
            initialScale = scale;
        }
    };

    window.onpointermove = (e) => {
        const idx = pointers.findIndex(p => p.pointerId === e.pointerId);
        if (idx !== -1) pointers[idx] = e;

        if (!isDragging) return;

        if (pointers.length === 1) {
            const dx = e.clientX - lastPointerPos.x;
            const dy = e.clientY - lastPointerPos.y;
            offset.x += dx;
            offset.y += dy;
            lastPointerPos = { x: e.clientX, y: e.clientY };

            // 移动超过5像素才算作拖拽，避免手抖
            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                hasMovedSignificantly = true;
            }
            updateTransform();
        } else if (pointers.length === 2) {
            hasMovedSignificantly = true;
            const dist = Math.hypot(pointers[0].clientX - pointers[1].clientX, pointers[0].clientY - pointers[1].clientY);
            const midX = (pointers[0].clientX + pointers[1].clientX) / 2;
            const midY = (pointers[0].clientY + pointers[1].clientY) / 2;
            
            const zoomDelta = (dist / initialPinchDist - 1) * 0.8 + 1;
            const newScale = initialScale * zoomDelta;
            zoomAt(midX, midY, newScale / scale);
        }
    };

    window.onpointerup = (e) => {
        pointers = pointers.filter(p => p.pointerId !== e.pointerId);
        if (pointers.length < 2) initialPinchDist = 0;
        if (pointers.length === 0) isDragging = false;
    };

    svg.onwheel = (e) => {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 0.96 : 1.04;
        zoomAt(e.clientX, e.clientY, zoomFactor);
    };

    function zoomAt(clientX, clientY, factor) {
        const newScale = Math.min(Math.max(scale * factor, 0.3), 5); 
        const realFactor = newScale / scale;
        offset.x = clientX - (clientX - offset.x) * realFactor;
        offset.y = clientY - (clientY - offset.y) * realFactor;
        scale = newScale;
        updateTransform();
    }

    function onDotClick(x, y, el) {  
        if (smartMode) return;  

        const idx = selectedPoints.findIndex(p => p.x === x && p.y === y);  
        if (idx > -1) {  
            selectedPoints.splice(idx, 1);  
            el.setAttribute("fill", "var(--dot-color)");  
            el.setAttribute("r", 6);  
            mainLineLayer.innerHTML = '';  
        } else if (selectedPoints.length < 4) {  
            const isFourth = selectedPoints.length === 3;  
            selectedPoints.push({x, y, el});  
            
            if (isFourth) {  
                el.setAttribute("fill", "var(--active-orange)");  
                el.setAttribute("r", 14);  
                mainLineLayer.innerHTML = '';  
                drawShape(selectedPoints, mainLineLayer, "var(--line-main)", 8);  
            } else {  
                el.setAttribute("fill", "var(--active-blue)");  
                el.setAttribute("r", 12);  
            }  
        }  
        verifyBtn.disabled = selectedPoints.length !== 4;  
    }  
  
    function sortPoints(pts) {  
        const cx = pts.reduce((a,b)=>a+b.x,0)/pts.length;  
        const cy = pts.reduce((a,b)=>a+b.y,0)/pts.length;  
        return [...pts].sort((a,b)=> Math.atan2(a.y-cy, a.x-cx) - Math.atan2(b.y-cy, b.x-cx));  
    }  
  
    function drawShape(pts, layer, color, width, isDash = false) {  
        if (pts.length < 3) return;
        const sorted = sortPoints(pts);  
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");  
        let d = `M ${sorted[0].x} ${sorted[0].y}`;  
        for(let i=1; i<sorted.length; i++) d += ` L ${sorted[i].x} ${sorted[i].y}`;  
        d += " Z";  
        path.setAttribute("d", d);  
        path.setAttribute("fill", "none");  
        path.setAttribute("stroke", color);  
        path.setAttribute("stroke-width", width);  
        if(isDash) path.setAttribute("stroke-dasharray", "5,5");  
        path.setAttribute("class", layer === historyLayer ? "history-line" : "shape-line");  
        layer.appendChild(path);  
    }  
  
    title.onclick = () => {  
        if (selectedPoints.length !== 3 || smartMode) return;  
        smartMode = true;  
          
        const [A, B, C] = selectedPoints;  
        const targets = [  
            {x: A.x + C.x - B.x, y: A.y + C.y - B.y},  
            {x: A.x + B.x - C.x, y: A.y + B.y - C.y},  
            {x: B.x + C.x - A.x, y: B.y + C.y - A.y}  
        ];  
  
        targets.forEach((pos, i) => {  
            const dot = allGridDots.find(d => Math.abs(d.x-pos.x)<5 && Math.abs(d.y-pos.y)<5);  
            if(dot) {  
                dot.el.setAttribute("fill", "var(--ghost-orange)");  
                dot.el.setAttribute("r", 10);  
                dot.hit.onclick = (e) => {
                    if (!hasMovedSignificantly) activateGhostCase(i, dot);
                };  
                ghostPoints.push({dot, index: i});  
            }  
        });  
    };  
  
    function activateGhostCase(index, dotObj) {  
        if (currentActiveIndex !== -1 && currentActiveIndex !== index) {  
            const oldCase = ghostPoints.find(g => g.index === currentActiveIndex);  
            drawShape([...selectedPoints, oldCase.dot], historyLayer, "var(--line-history)", 2);  
        }  
  
        ghostPoints.forEach(g => {  
            if(g.index === index) {  
                g.dot.el.setAttribute("fill", "var(--active-orange)");  
                g.dot.el.setAttribute("r", 14);  
            } else {  
                g.dot.el.setAttribute("fill", "var(--ghost-orange)");  
                g.dot.el.setAttribute("r", 10);  
            }  
        });  
  
        mainLineLayer.innerHTML = '';  
        drawShape([...selectedPoints, dotObj], mainLineLayer, "var(--line-main)", 8);  
          
        currentActiveIndex = index;  
        verifyBtn.disabled = false;  
    }  
  
    async function verify() {  
        let finalPts = [];
        if (smartMode && currentActiveIndex !== -1) {
            const activeGhost = ghostPoints.find(g => g.index === currentActiveIndex);
            finalPts = [...selectedPoints, activeGhost.dot];
        } else if (selectedPoints.length === 4) {
            finalPts = [...selectedPoints];
        } else {
            return;
        }
          
        const pts = sortPoints(finalPts);  
        verifyBtn.disabled = true;  
        await animateVector(pts[0], pts[1], pts[3], pts[2], "#FF5722");  
        await animateVector(pts[1], pts[2], pts[0], pts[3], "#9C27B0");  
        
        const isPara = Math.abs((pts[0].x + pts[2].x) - (pts[1].x + pts[3].x)) < 5 && 
                       Math.abs((pts[0].y + pts[2].y) - (pts[1].y + pts[3].y)) < 5;

        if (isPara) triggerConfetti();
        verifyBtn.disabled = false;  
    }  
  
    function animateVector(s1, s2, t1, t2, col) {  
        return new Promise(res => {  
            const l = document.createElementNS("http://www.w3.org/2000/svg", "line");  
            l.setAttribute("x1", s1.x); l.setAttribute("y1", s1.y);  
            l.setAttribute("x2", s2.x); l.setAttribute("y2", s2.y);  
            l.setAttribute("stroke", col); l.setAttribute("stroke-width", 10);  
            l.setAttribute("stroke-dasharray", "10,10");  
            viewGroup.appendChild(l); 
  
            const anim = l.animate([  
                { transform: 'translate(0,0)' },  
                { transform: `translate(${t1.x - s1.x}px, ${t1.y - s1.y}px)` }  
            ], { duration: 1000, easing: 'ease-in-out', fill: 'forwards' });  
  
            anim.onfinish = () => {  
                setTimeout(() => { l.remove(); res(); }, 200);  
            };  
        });  
    }

    let particles = [];
    const colors = ['#2196F3', '#FF9800', '#4CAF50', '#FF4081', '#FFEB3B'];

    class Particle {
        constructor() {
            this.x = window.innerWidth / 2;
            this.y = window.innerHeight / 2;
            this.vx = (Math.random() - 0.5) * 20;
            this.vy = (Math.random() - 1) * 15;
            this.gravity = 0.5;
            this.color = colors[Math.floor(Math.random() * colors.length)];
            this.w = Math.random() * 10 + 5;
            this.h = Math.random() * 10 + 5;
            this.rotation = Math.random() * 360;
            this.rSpeed = Math.random() * 10 - 5;
            this.life = 100;
        }
        update() {
            this.vx *= 0.99;
            this.vy += this.gravity;
            this.x += this.vx;
            this.y += this.vy;
            this.rotation += this.rSpeed;
            this.life -= 1;
        }
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation * Math.PI / 180);
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.life / 100;
            ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
            ctx.restore();
        }
    }

    function triggerConfetti() {
        particles = [];
        for(let i=0; i<100; i++) particles.push(new Particle());
        animateParticles();
    }

    function animateParticles() {
        if(particles.length === 0) return;
        ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        for(let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            particles[i].draw();
            if(particles[i].life <= 0) particles.splice(i, 1);
        }
        requestAnimationFrame(animateParticles);
    }
  
    resetBtn.onclick = () => {
        // 重置时也重置变换
        // scale = 1; offset = {x:0, y:0}; // 如果不想重置视图，可以注释掉这行
        init();
    };  
    verifyBtn.onclick = verify;  
    window.onresize = () => {
        const w = window.innerWidth, h = window.innerHeight;
        confettiCanvas.width = w;
        confettiCanvas.height = h;
    };  
  
    init();  
</script>  
</body>  
</html>
