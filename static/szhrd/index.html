<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ•°å­—åå®¹é“ï¼ˆAIåŠ©æ•™ç‰ˆï¼‰</title>
    <style>
        :root {
            --bg-page: #eef9ff; 
            --board-base: #ffb74d; 
            
            /* åˆ†å±‚é¢œè‰²å®šä¹‰ */
            --layer-1: #ff8a80; /* 1-4: çº¢è‰²ç³» */
            --layer-2: #4fc3f7; /* 5-8: è“è‰²ç³» */
            --layer-3: #aed581; /* 9-12: ç»¿è‰²ç³» */
            --layer-4: #ce93d8; /* 13-15: ç´«è‰²ç³» */
            
            --text-dark: #5d4037;
            --accent: #ff6f00;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0;
            height: 100vh;
            background: var(--bg-page);
            font-family: "Rounded Mplus 1c", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            color: var(--text-dark);
        }

        .container {
            display: flex;
            flex-direction: column; 
            align-items: center;
            justify-content: space-between; 
            width: 100%;
            height: 100%;
            max-width: 600px;
            padding: 10px;
            position: relative;
        }

        /* æ¸¸æˆä¸»åŒºåŸŸ (ä¸Šæ–¹) */
        .game-main {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            flex: 1; 
            width: 100%;
            padding-bottom: 160px; /* ä¸ºåº•éƒ¨æµ®å±‚ç•™å‡ºç©ºé—´ */
        }

        /* é¡¶éƒ¨æ§åˆ¶æ  */
        .controls { 
            width: 90%;
            max-width: 500px;
            margin-bottom: 35px;
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        
        .btn {
            padding: 8px 20px; background: var(--accent); color: white;
            border: none; border-radius: 50px; cursor: pointer; font-weight: bold;
            box-shadow: 0 4px 0 #b34e00; transition: 0.1s;
            font-size: 0.95rem;
            z-index: 20; 
        }
        .btn:active { transform: translateY(3px); box-shadow: 0 2px 0 #b34e00; }
        
        #status {
            font-weight: bold;
            font-size: 1.1rem;
            color: var(--accent);
            background: white;
            padding: 5px 15px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        /* æ£‹ç›˜ */
        .board-outer {
            background: var(--board-base);
            padding: 12px;
            border-radius: 20px;
            box-shadow: 0 8px 0 #e6a13c, 0 10px 20px rgba(0,0,0,0.15);
            width: 90%; 
            aspect-ratio: 1 / 1; 
            display: flex;
            align-items: center;
            justify-content: center;
            max-height: 500px;
            max-width: 500px;
            z-index: 10;
            position: relative; /* ç¡®ä¿é®ç½©å±‚ç›¸å¯¹äºæ£‹ç›˜å®šä½ */
        }

        .board-inner {
            width: 100%;
            height: 100%;
            background: #dcd0c0;
            border-radius: 12px;
            position: relative;
            box-shadow: inset 6px 6px 10px rgba(0,0,0,0.2);
            padding: 6px;
        }

        /* åŠ è½½é®ç½©å±‚æ ·å¼ */
        .loading-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(3px); /* æ¯›ç»ç’ƒæ•ˆæœ */
            border-radius: 20px; /* ä¸ board-outer åœ†è§’ä¸€è‡´ */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .loading-mask.active {
            opacity: 1;
            pointer-events: all;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #ffdbb0;
            border-top: 4px solid var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        .loading-text {
            color: var(--accent);
            font-weight: bold;
            font-size: 1.1rem;
            letter-spacing: 1px;
            animation: breathe 1.5s infinite ease-in-out;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* æ£‹å­æ ·å¼ */
        .tile {
            position: absolute;
            width: calc(25% - 8px);
            height: calc(25% - 8px);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.5rem, 5vw, 2.2rem);
            font-weight: 900;
            color: white;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 5px 0 rgba(0,0,0,0.15), inset 0 -3px 0 rgba(0,0,0,0.1);
            z-index: 1;
        }

        .tile.layer-1, .step-item.layer-1 { background-color: var(--layer-1); }
        .tile.layer-2, .step-item.layer-2 { background-color: var(--layer-2); }
        .tile.layer-3, .step-item.layer-3 { background-color: var(--layer-3); }
        .tile.layer-4, .step-item.layer-4 { background-color: var(--layer-4); }

        .tile.locked {
            filter: brightness(0.95);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
        }
        .tile.locked::after {
            content: 'ğŸ”’';
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.7rem;
            opacity: 0.5;
        }

        .tile.hint {
            border: 4px solid #fff; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.2); 
            animation: breathe 2s infinite ease-in-out; 
            z-index: 10;
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); } 
        }

        /* åº•éƒ¨æ•™å­¦åŠ©æ‰‹ */
        .sidebar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto;
            max-height: 25vh; 
            background: white;
            border-radius: 25px 25px 0 0; 
            border-top: 6px solid var(--board-base);
            display: flex;
            flex-direction: column;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.1);
            z-index: 100;
            padding-bottom: 1rem; 
        }

        .sidebar-header {
            background: transparent;
            color: var(--text-dark);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
        }

        .header-left { display: flex; align-items: center; gap: 10px; flex: 1; }
        
        .header-title {
            font-size: 1rem;
            font-weight: bold;
            white-space: nowrap;
        }

        .current-goal {
            background: #fff3e0;
            color: var(--accent);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* ç®—æ³•é€‰æ‹©å™¨ */
        .algo-selector {
            appearance: none;
            -webkit-appearance: none; 
            padding: 6px 30px 6px 12px;
            border-radius: 20px;
            border: 2px solid var(--board-base);
            background: white url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ff6f00' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e") no-repeat right 8px center;
            background-size: 14px;
            color: var(--accent);
            font-weight: bold;
            font-family: inherit;
            font-size: 0.85rem;
            outline: none;
            cursor: pointer;
            width: auto;
            box-shadow: 0 3px 0 rgba(0,0,0,0.1);
            transition: all 0.2s;
        }

        .algo-selector:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 rgba(0,0,0,0.1);
        }

        /* æ­¥éª¤åˆ—è¡¨ */
        #step-list {
            flex: 1;
            display: flex;
            flex-direction: row; 
            overflow-x: auto; 
            overflow-y: hidden;
            padding: 30px 15px;
            gap: 12px;
            align-items: center;
            scrollbar-width: none; 
        }
        #step-list::-webkit-scrollbar { display: none; }

        .step-item {
            width: 50px;
            height: 50px;
            flex-shrink: 0;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 1.2rem;
            color: white;
            box-shadow: 0 3px 0 rgba(0,0,0,0.15);
            position: relative;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .step-item:not(:last-child)::after {
            content: 'â†’';
            position: absolute;
            right: -14px;
            color: #ccc;
            font-size: 1rem;
            font-weight: normal;
        }

        .step-item.active {
            transform: scale(1.1);
            border: 2px solid var(--accent);
            box-shadow: 0 5px 10px rgba(0,0,0,0.2);
            z-index: 2;
        }

        .empty-tip {
            width: 100%;
            text-align: center;
            color: #999;
            font-size: 0.9rem;
            padding: 10px;
        }

        /* åº†å…¸ Canvas */
        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
        }
    </style>
</head>
<body>

<canvas id="confetti-canvas"></canvas>

<div class="container">
    <div class="game-main">
        <div class="controls">
            <button class="btn" onclick="initGame()">æ–°æŒ‘æˆ˜</button>
            <div id="status">æ­¥æ•°: 0</div>
        </div>

        <div class="board-outer">
            <div class="board-inner" id="board"></div>
            <!-- åŠ è½½é®ç½©å±‚ -->
            <div id="loading-mask" class="loading-mask">
                <div class="spinner"></div>
                <div class="loading-text">AI æ­£åœ¨å…¨é€Ÿæ€è€ƒä¸­â€¦â€¦</div>
            </div>
        </div>
    </div>

    <!-- åº•éƒ¨æµ®åŠ¨æ•™å­¦åŠ©æ‰‹ -->
    <div class="sidebar">
        <div class="sidebar-header">
            <div class="header-left">
                <div class="header-title">AI åŠ©æ‰‹</div>
                <div id="goal-display" class="current-goal">
                    <span>å‡†å¤‡å°±ç»ª</span>
                </div>
            </div>
            <select id="algo-select" class="algo-selector" onchange="triggerAI(true)">
                <option value="regular" selected>å¸¸è§„ (é€ä¸ª)</option>
                <option value="intermediate">ğŸš€ ä¸­é˜¶ (é€å±‚)</option>
                <option value="advanced">é«˜é˜¶ (IDA*)</option>
            </select>
        </div>
        <div id="step-list">
            <div class="empty-tip">ç‚¹å‡»â€œæ–°æŒ‘æˆ˜â€å¼€å§‹</div>
        </div>
    </div>
</div>

<script>
    const GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];
    const TARGET_POS = {}; 
    GOAL.forEach((v, i) => TARGET_POS[v] = i);

    let state = [];
    let moves = 0;
    let currentPath = []; 
    let isComputing = false;
    let lockedIndices = []; 

    function initGame() {
        moves = 0;
        currentPath = [];
        state = generateSolvableState();
        stopConfetti(); 
        renderBoard();
        updateUI();
        triggerAI(true);
    }

    function generateSolvableState() {
        let arr;
        do { arr = [...GOAL].sort(() => Math.random() - 0.5); } while (!isSolvable(arr));
        return arr;
    }

    function isSolvable(arr) {
        let inv = 0;
        for (let i = 0; i < 16; i++) {
            if (arr[i] === 0) continue;
            for (let j = i + 1; j < 16; j++) { if (arr[j] !== 0 && arr[i] > arr[j]) inv++; }
        }
        const row = 4 - Math.floor(arr.indexOf(0) / 4);
        return (inv + row) % 2 !== 0;
    }

    function handleMove(idx) {
        if (isComputing) return;

        const emptyIdx = state.indexOf(0);
        const r1 = Math.floor(idx / 4), c1 = idx % 4;
        const r2 = Math.floor(emptyIdx / 4), c2 = emptyIdx % 4;

        if (Math.abs(r1 - r2) + Math.abs(c1 - c2) === 1) {
            const movedValue = state[idx];
            const followedAI = (currentPath.length > 0 && movedValue === currentPath[0]);

            state[emptyIdx] = state[idx];
            state[idx] = 0;
            moves++;

            if (followedAI) {
                currentPath.shift();
                if (currentPath.length === 0 && !isGameComplete()) {
                    renderBoard();
                    updateUI();
                    triggerAI(false); 
                } else {
                    displayPath(currentPath);
                    renderBoard();
                    updateUI();
                }
            } else {
                renderBoard();
                updateUI();
                triggerAI(false);
            }

            if (isGameComplete()) {
                startConfetti();
                document.getElementById('goal-display').innerHTML = "ğŸ‰ å…¨éƒ¨å®Œæˆ";
            }
        }
    }

    function isGameComplete() {
        return state.every((v, i) => v === GOAL[i]);
    }

    function triggerAI(isReset) {
        if (isGameComplete()) {
            displayPath([]);
            updateLockedUI(state, document.getElementById('algo-select').value);
            return;
        }

        const algo = document.getElementById('algo-select').value;
        const listEl = document.getElementById('step-list');
        const goalEl = document.getElementById('goal-display');
        const mask = document.getElementById('loading-mask'); // è·å–é®ç½©å±‚
        
        // ç«‹å³æ˜¾ç¤ºé®ç½©
        mask.classList.add('active');

        if (currentPath.length === 0) {
            listEl.innerHTML = '<div class="empty-tip">AI æ€è€ƒä¸­...</div>';
        }

        isComputing = true;
        
        // ä½¿ç”¨ setTimeout è®© UI çº¿ç¨‹æœ‰æœºä¼šæ¸²æŸ“é®ç½©
        // å¢åŠ å»¶è¿Ÿåˆ° 50ms ç¡®ä¿é®ç½©åŠ¨ç”»å¼€å§‹
        setTimeout(() => {
            let result = null;

            if (algo === 'regular') {
                result = solveRegularSmart([...state]);
            } else if (algo === 'intermediate') {
                result = solveIntermediate([...state]);
            } else {
                result = { path: solveAdvanced([...state]), goalName: "å…¨å±€æœ€ä¼˜" };
            }

            if (result && result.goalName) {
                goalEl.innerHTML = `<span>ğŸ¯ ${result.goalName}</span>`;
            }

            if (result && result.path) {
                currentPath = result.path;
                displayPath(currentPath);
            } else {
                currentPath = [];
                listEl.innerHTML = '<div class="empty-tip">è¯·æ‰‹åŠ¨ç§»åŠ¨å‡ æ­¥</div>';
            }
            
            updateLockedUI(state, algo);
            renderBoard();
            
            // è®¡ç®—å®Œæˆåéšè—é®ç½©
            mask.classList.remove('active');
            isComputing = false;
        }, 50);
    }
    
    function getLayerClass(val) {
        if (val >= 1 && val <= 4) return 'layer-1';
        if (val >= 5 && val <= 8) return 'layer-2';
        if (val >= 9 && val <= 12) return 'layer-3';
        if (val >= 13 && val <= 15) return 'layer-4';
        return '';
    }

    // --- 1. å¸¸è§„ç®—æ³• (é€ä¸ªå‡»ç ´) ---
    function solveRegularSmart(currState) {
        const isCorrect = (val, idx) => currState[idx] === val;
        
        // ç¬¬ä¸€å±‚é€ä¸ª
        if (!isCorrect(1, 0)) return { goalName: "ç›®æ ‡: 1", path: solveStage(currState, {1:0}, [])?.path };
        if (!isCorrect(2, 1)) return { goalName: "ç›®æ ‡: 2", path: solveStage(currState, {2:1}, [0])?.path };
        if (!isCorrect(3, 2)) return { goalName: "ç›®æ ‡: 3", path: solveStage(currState, {3:2}, [0, 1])?.path };
        if (!isCorrect(4, 3)) return { goalName: "ç›®æ ‡: 4", path: solveStage(currState, {3:2, 4:3}, [0, 1])?.path };

        const L1_Locks = [0, 1, 2, 3];
        // ç¬¬äºŒå±‚é€ä¸ª
        if (!isCorrect(5, 4)) return { goalName: "ç›®æ ‡: 5", path: solveStage(currState, {5:4}, L1_Locks)?.path };
        if (!isCorrect(6, 5)) return { goalName: "ç›®æ ‡: 6", path: solveStage(currState, {6:5}, [...L1_Locks, 4])?.path };
        if (!isCorrect(7, 6)) return { goalName: "ç›®æ ‡: 7", path: solveStage(currState, {7:6}, [...L1_Locks, 4, 5])?.path };
        if (!isCorrect(8, 7)) return { goalName: "ç›®æ ‡: 8", path: solveStage(currState, {7:6, 8:7}, [...L1_Locks, 4, 5])?.path };

        // å‰©ä½™æ•´ä½“
        const Bottom_Locks = [0, 1, 2, 3, 4, 5, 6, 7];
        const finalTargets = {};
        for(let v=9; v<=15; v++) finalTargets[v] = v-1;
        return { goalName: "æœ€åé˜¶æ®µ", path: solveStage(currState, finalTargets, Bottom_Locks)?.path };
    }

    // --- 2. ä¸­é˜¶ç®—æ³• (é€å±‚å‡»ç ´) ---
    function solveIntermediate(currState) {
        // ç¬¬ä¸€å±‚æ•´ä½“
        const isL1Done = [1,2,3,4].every(v => currState[v-1] === v);
        if (!isL1Done) {
             return { 
                 goalName: "ç›®æ ‡: ç¬¬ä¸€å±‚ (1-4)", 
                 path: solveStage(currState, {1:0, 2:1, 3:2, 4:3}, [])?.path 
             };
        }

        // ç¬¬äºŒå±‚æ•´ä½“ (é”å®šç¬¬ä¸€å±‚)
        const isL2Done = [5,6,7,8].every(v => currState[v-1] === v);
        const L1_Locks = [0, 1, 2, 3];
        if (!isL2Done) {
             return { 
                 goalName: "ç›®æ ‡: ç¬¬äºŒå±‚ (5-8)", 
                 path: solveStage(currState, {5:4, 6:5, 7:6, 8:7}, L1_Locks)?.path 
             };
        }

        // ç¬¬ä¸‰å››å±‚æ•´ä½“ (é”å®šä¸€äºŒå±‚)
        const Bottom_Locks = [0, 1, 2, 3, 4, 5, 6, 7];
        const finalTargets = {};
        for(let v=9; v<=15; v++) finalTargets[v] = v-1;
        
        return { 
            goalName: "ç›®æ ‡: å‰©ä½™å…¨éƒ¨", 
            path: solveStage(currState, finalTargets, Bottom_Locks)?.path 
        };
    }

    // --- 3. é«˜é˜¶ç®—æ³• (å…¨å±€IDA*) ---
    function solveAdvanced(startState) {
        lockedIndices = []; 
        let limit = getGlobalHeuristic(startState);
        const path = [];
        for (let i = 0; i < 80; i++) { 
            const res = dfs([...startState], 0, limit, -1, path);
            if (res === "FOUND") return path;
            if (res === Infinity) return null;
            limit = res;
        }
        return null;
    }

    // --- ä¼˜åŒ–åçš„ A* æ±‚è§£å™¨ ---
    function solveStage(startState, targetGoals, fixedIndices) {
        // æ€§èƒ½ä¼˜åŒ–ï¼šåˆå§‹å®¹é‡è®¾ç½®ï¼Œé¿å…é¢‘ç¹æ‰©å®¹
        // å®é™…ä¸ŠJSæ•°ç»„æ˜¯åŠ¨æ€çš„ï¼Œä½†æˆ‘ä»¬å¯ä»¥æ§åˆ¶ maxIter
        
        let openList = [{
            state: [...startState],
            g: 0,
            h: getStageHeuristic(startState, targetGoals),
            path: [],
            emptyIdx: startState.indexOf(0)
        }];
        
        let closedSet = new Set();
        let fixedSet = new Set(fixedIndices);
        
        // æ­¥æ•°ä¸Šé™è®¾ä¸º 60000ï¼Œé…åˆåŠ æƒå¯å‘å‡½æ•°ï¼Œè¶³å¤Ÿè§£å†³æ‰€æœ‰å­é—®é¢˜
        let maxIter = 60000; 

        while (openList.length > 0 && maxIter-- > 0) {
            // å¯¹ openList æ’åºï¼Œå– f = g + h æœ€å°çš„
            // æ³¨æ„ï¼šè¿™é‡Œ h å·²ç»åŒ…å«äº†æƒé‡ (Weighted A*)
            openList.sort((a, b) => (a.g + a.h) - (b.g + b.h));
            let current = openList.shift();

            let stateStr = current.state.join(',');
            if (closedSet.has(stateStr)) continue;
            closedSet.add(stateStr);

            // æ£€æŸ¥ç›®æ ‡æ˜¯å¦è¾¾æˆ (h == 0 è¡¨ç¤ºæ‰€æœ‰ç›®æ ‡å½’ä½ä¸”æ— å†²çª)
            if (current.h === 0) {
                return { path: current.path, state: current.state };
            }

            const neighbors = getNeighbors(current.emptyIdx, fixedSet);
            
            for (let nIdx of neighbors) {
                let newState = [...current.state];
                let moveVal = newState[nIdx];
                
                // äº¤æ¢
                [newState[current.emptyIdx], newState[nIdx]] = [newState[nIdx], newState[current.emptyIdx]];

                // åªæœ‰æœªè®¿é—®è¿‡çš„çŠ¶æ€æ‰åŠ å…¥
                if (!closedSet.has(newState.join(','))) {
                    let h = getStageHeuristic(newState, targetGoals);
                    openList.push({
                        state: newState,
                        g: current.g + 1,
                        h: h,
                        path: [...current.path, moveVal],
                        emptyIdx: nIdx
                    });
                }
            }
        }
        return null;
    }

    // --- å¯å‘å‡½æ•°ä¼˜åŒ–ï¼šæ›¼å“ˆé¡¿ + çº¿æ€§å†²çª + è´ªå©ªæƒé‡ ---
    function getStageHeuristic(arr, targets) {
        let h = 0;
        let conflict = 0;
        
        // 1. æ›¼å“ˆé¡¿è·ç¦»
        for (let tileStr in targets) {
            let tile = parseInt(tileStr);
            let currIdx = arr.indexOf(tile);
            if (currIdx === -1) continue;
            let targetIdx = targets[tile];
            
            let r1 = Math.floor(currIdx / 4);
            let c1 = currIdx % 4;
            let r2 = Math.floor(targetIdx / 4);
            let c2 = targetIdx % 4;
            
            h += Math.abs(r1 - r2) + Math.abs(c1 - c2);
        }

        // 2. çº¿æ€§å†²çª (Linear Conflict) - è§£å†³æ•´è¡Œå¡é¡¿çš„å…³é”®
        const rowGroups = {};
        for (let tileStr in targets) {
            let tile = parseInt(tileStr);
            let targetIdx = targets[tile];
            let tRow = Math.floor(targetIdx / 4);
            if (!rowGroups[tRow]) rowGroups[tRow] = [];
            rowGroups[tRow].push({tile: tile, tCol: targetIdx % 4});
        }

        for (let r in rowGroups) {
            let tRow = parseInt(r);
            let group = rowGroups[tRow];
            
            // æ‰¾å‡ºè¯¥è¡Œå½“å‰æœ‰å“ªäº›ç›®æ ‡å—
            let inRowTiles = [];
            for (let c = 0; c < 4; c++) {
                let val = arr[tRow * 4 + c];
                let targetInfo = group.find(g => g.tile === val);
                if (targetInfo) {
                    inRowTiles.push({ val: val, currCol: c, tCol: targetInfo.tCol });
                }
            }
            
            // è®¡ç®—å†²çª
            for (let i = 0; i < inRowTiles.length; i++) {
                for (let j = i + 1; j < inRowTiles.length; j++) {
                    let t1 = inRowTiles[i];
                    let t2 = inRowTiles[j];
                    // t1 åœ¨ t2 å·¦è¾¹ï¼Œä½† t1 çš„ç›®æ ‡åœ¨ t2 å³è¾¹ => å†²çª
                    if (t1.tCol > t2.tCol) {
                        conflict += 2;
                    }
                }
            }
        }
        
        // 3. è´ªå©ªæƒé‡ (Weighted A*)
        // ä¹˜ä»¥ 3.0ï¼Œå¤§å¹…å‡å°‘æœç´¢ç©ºé—´ï¼Œå®ç°ç§’å‡ºç»“æœ
        return (h + conflict) * 3;
    }

    function getGlobalHeuristic(arr) {
        let d = 0;
        for (let i = 0; i < 16; i++) {
            if (arr[i] === 0) continue;
            let target = arr[i] - 1;
            d += getManhattanDist(i, target);
        }
        return d;
    }

    function getManhattanDist(idx1, idx2) {
        return Math.abs(Math.floor(idx1 / 4) - Math.floor(idx2 / 4)) + Math.abs(idx1 % 4 - idx2 % 4);
    }

    function getNeighbors(idx, fixedSet) {
        const r = Math.floor(idx/4), c = idx%4;
        const potential = [];
        if (r > 0) potential.push(idx - 4);
        if (r < 3) potential.push(idx + 4);
        if (c > 0) potential.push(idx - 1);
        if (c < 3) potential.push(idx + 1);
        return potential.filter(nIdx => !fixedSet.has(nIdx));
    }

    function dfs(curr, g, limit, lastMove, path) {
        const h = getGlobalHeuristic(curr);
        if (g + h > limit) return g + h;
        if (h === 0) return "FOUND";
        let min = Infinity;
        const emptyIdx = curr.indexOf(0);
        const neighbors = getNeighbors(emptyIdx, new Set()); 
        for (let nIdx of neighbors) {
            const val = curr[nIdx];
            if (val === lastMove) continue;
            [curr[emptyIdx], curr[nIdx]] = [curr[nIdx], curr[emptyIdx]];
            path.push(val);
            const t = dfs(curr, g + 1, limit, val, path);
            if (t === "FOUND") return "FOUND";
            if (t < min) min = t;
            path.pop();
            [curr[emptyIdx], curr[nIdx]] = [curr[nIdx], curr[emptyIdx]];
        }
        return min;
    }

    function displayPath(path) {
        const listEl = document.getElementById('step-list');
        listEl.innerHTML = '';
        
        document.querySelectorAll('.tile').forEach(t => t.classList.remove('hint'));

        if (!path || path.length === 0) {
            if (isGameComplete()) listEl.innerHTML = '<div class="empty-tip" style="color:green;">ğŸ‰ æ­å–œï¼å·²å®Œæˆï¼</div>';
            return;
        }

        path.forEach((val, i) => {
            const item = document.createElement('div');
            item.className = `step-item ${getLayerClass(val)} ${i === 0 ? 'active' : ''}`;
            item.innerText = val;
            listEl.appendChild(item);
            
            if (i === 0) {
                const tile = document.getElementById(`tile-${val}`);
                if (tile) tile.classList.add('hint');
            }
        });
        
        listEl.scrollLeft = 0;
    }

    function renderBoard() {
        const board = document.getElementById('board');
        board.innerHTML = '';
        state.forEach((val, idx) => {
            if (val === 0) return;
            const tile = document.createElement('div');
            
            tile.className = `tile ${getLayerClass(val)}`;
            if (lockedIndices.includes(idx)) tile.classList.add('locked');
            
            tile.id = `tile-${val}`;
            tile.innerText = val;
            tile.style.top = `calc(${Math.floor(idx / 4) * 25}% + 5px)`;
            tile.style.left = `calc(${(idx % 4) * 25}% + 5px)`;
            tile.onclick = () => handleMove(idx);
            board.appendChild(tile);
        });
        
        if (currentPath.length > 0) {
             const nextVal = currentPath[0];
             const tile = document.getElementById(`tile-${nextVal}`);
             if (tile) tile.classList.add('hint');
        }
    }

    function updateLockedUI(currentState, algoType) {
        lockedIndices = [];
        if (typeof currentState === 'string') { algoType = currentState; currentState = state; }
        if (algoType === 'advanced') return;

        const isCorrect = (v) => currentState[v-1] === v;
        
        if (algoType === 'intermediate') {
            const L1 = [1,2,3,4].every(v => isCorrect(v));
            if (L1) lockedIndices.push(0,1,2,3);
            
            if (L1) {
                const L2 = [5,6,7,8].every(v => isCorrect(v));
                if (L2) lockedIndices.push(4,5,6,7);
            }
            return;
        }

        if (isCorrect(1)) lockedIndices.push(0);
        if (isCorrect(1) && isCorrect(2)) lockedIndices.push(1);
        if (isCorrect(1) && isCorrect(2) && isCorrect(3) && isCorrect(4)) lockedIndices.push(2, 3);
        
        if (isCorrect(1) && isCorrect(2) && isCorrect(3) && isCorrect(4)) {
            if (isCorrect(5)) lockedIndices.push(4);
            if (isCorrect(5) && isCorrect(6)) lockedIndices.push(5);
            if (isCorrect(5) && isCorrect(6) && isCorrect(7) && isCorrect(8)) lockedIndices.push(6, 7);
        }
    }

    function updateUI() {
        document.getElementById('status').innerText = `æ­¥æ•°: ${moves}`;
        const algo = document.getElementById('algo-select').value;
        updateLockedUI(state, algo);
    }

    // ==========================================
    // æ°´å½©çº¸ç¢å±‘ç‰¹æ•ˆ
    // ==========================================
    const canvas = document.getElementById("confetti-canvas");
    const ctx = canvas.getContext("2d");
    let particles = [];
    let animationId = null;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const colors = ['#ff8a80', '#4fc3f7', '#aed581', '#ce93d8', '#ffb74d'];

    class Particle {
        constructor() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height - canvas.height;
            this.size = Math.random() * 15 + 10;
            this.speedX = Math.random() * 4 - 2;
            this.speedY = Math.random() * 5 + 3;
            this.color = colors[Math.floor(Math.random() * colors.length)];
            this.rotation = Math.random() * 360;
            this.rotationSpeed = Math.random() * 10 - 5;
            this.opacity = Math.random() * 0.5 + 0.5;
        }

        update() {
            this.y += this.speedY;
            this.x += this.speedX + Math.sin(this.y * 0.01); 
            this.rotation += this.rotationSpeed;
            if (this.y > canvas.height) {
                this.y = -50;
                this.x = Math.random() * canvas.width;
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation * Math.PI / 180);
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.opacity;
            ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size * 0.6);
            ctx.restore();
        }
    }

    function startConfetti() {
        if (animationId) return; 
        particles = [];
        for (let i = 0; i < 150; i++) {
            particles.push(new Particle());
        }
        animateConfetti();
    }

    function stopConfetti() {
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    }

    function animateConfetti() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach(p => {
            p.update();
            p.draw();
        });
        animationId = requestAnimationFrame(animateConfetti);
    }

    window.onload = initGame;
</script>

</body>
</html>