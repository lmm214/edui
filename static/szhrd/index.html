<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ•°å­—åå®¹é“ï¼ˆAIåŠ©æ•™ç‰ˆï¼‰</title>
    <style>
        :root {
            --bg-page: #eef9ff; 
            --board-base: #ffb74d; 
            
            /* åˆ†å±‚é¢œè‰²å®šä¹‰ */
            --layer-1: #ff8a80; /* 1-4: çº¢è‰²ç³» */
            --layer-2: #4fc3f7; /* 5-8: è“è‰²ç³» */
            --layer-3: #aed581; /* 9-12: ç»¿è‰²ç³» */
            --layer-4: #ce93d8; /* 13-15: ç´«è‰²ç³» */
            
            --text-dark: #5d4037;
            --accent: #ff6f00;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0;
            height: 100vh;
            background: var(--bg-page);
            font-family: "Rounded Mplus 1c", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            color: var(--text-dark);
        }

        .container {
            display: flex;
            flex-direction: column; 
            align-items: center;
            justify-content: space-between; 
            width: 100%;
            height: 100%;
            max-width: 600px;
            padding: 10px;
            position: relative;
        }

        /* æ¸¸æˆä¸»åŒºåŸŸ (ä¸Šæ–¹) */
        .game-main {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            flex: 1; 
            width: 100%;
            padding-bottom: 160px; /* ä¸ºåº•éƒ¨æµ®å±‚ç•™å‡ºç©ºé—´ */
        }

        /* é¡¶éƒ¨æ§åˆ¶æ  */
        .controls { 
            width: 90%;
            max-width: 500px;
            margin-bottom: 35px;
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        
        .btn {
            padding: 8px 20px; background: var(--accent); color: white;
            border: none; border-radius: 50px; cursor: pointer; font-weight: bold;
            box-shadow: 0 4px 0 #b34e00; transition: 0.1s;
            font-size: 0.95rem;
            z-index: 20; 
        }
        .btn:active { transform: translateY(3px); box-shadow: 0 2px 0 #b34e00; }
        
        #status {
            font-weight: bold;
            font-size: 1.1rem;
            color: var(--accent);
            background: white;
            padding: 5px 15px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        /* æ£‹ç›˜ */
        .board-outer {
            background: var(--board-base);
            padding: 12px;
            border-radius: 20px;
            box-shadow: 0 8px 0 #e6a13c, 0 10px 20px rgba(0,0,0,0.15);
            width: 90%; 
            aspect-ratio: 1 / 1; 
            display: flex;
            align-items: center;
            justify-content: center;
            max-height: 500px;
            max-width: 500px;
            z-index: 10;
            position: relative; /* ç¡®ä¿é®ç½©å±‚ç›¸å¯¹äºæ£‹ç›˜å®šä½ */
        }

        .board-inner {
            width: 100%;
            height: 100%;
            background: #dcd0c0;
            border-radius: 12px;
            position: relative;
            box-shadow: inset 6px 6px 10px rgba(0,0,0,0.2);
            padding: 6px;
        }

        /* åŠ è½½é®ç½©å±‚æ ·å¼ */
        .loading-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(3px); /* æ¯›ç»ç’ƒæ•ˆæœ */
            border-radius: 20px; /* ä¸ board-outer åœ†è§’ä¸€è‡´ */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .loading-mask.active {
            opacity: 1;
            pointer-events: all;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #ffdbb0;
            border-top: 4px solid var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        .loading-text {
            color: var(--accent);
            font-weight: bold;
            font-size: 1.1rem;
            letter-spacing: 1px;
            animation: breathe 1.5s infinite ease-in-out;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* æ£‹å­æ ·å¼ */
        .tile {
            position: absolute;
            width: calc(25% - 8px);
            height: calc(25% - 8px);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.5rem, 5vw, 2.2rem);
            font-weight: 900;
            color: white;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 5px 0 rgba(0,0,0,0.15), inset 0 -3px 0 rgba(0,0,0,0.1);
            z-index: 1;
        }

        .tile.layer-1, .step-item.layer-1 { background-color: var(--layer-1); }
        .tile.layer-2, .step-item.layer-2 { background-color: var(--layer-2); }
        .tile.layer-3, .step-item.layer-3 { background-color: var(--layer-3); }
        .tile.layer-4, .step-item.layer-4 { background-color: var(--layer-4); }

        .tile.locked {
            filter: brightness(0.95);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
        }
        .tile.locked::after {
            content: 'ğŸ”’';
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.7rem;
            opacity: 0.5;
        }

        .tile.hint {
            border: 4px solid #fff; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.2); 
            animation: breathe 2s infinite ease-in-out; 
            z-index: 10;
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); } 
        }

        /* åº•éƒ¨æ•™å­¦åŠ©æ‰‹ */
        .sidebar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto;
            max-height: 25vh; 
            background: white;
            border-radius: 25px 25px 0 0; 
            border-top: 6px solid var(--board-base);
            display: flex;
            flex-direction: column;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.1);
            z-index: 100;
            padding-bottom: 1rem; 
        }

        .sidebar-header {
            background: transparent;
            color: var(--text-dark);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
        }

        .header-left { display: flex; align-items: center; gap: 10px; flex: 1; }
        
        .header-title {
            font-size: 1rem;
            font-weight: bold;
            white-space: nowrap;
        }

        .current-goal {
            background: #fff3e0;
            color: var(--accent);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* ç®—æ³•é€‰æ‹©å™¨ */
        .algo-selector {
            appearance: none;
            -webkit-appearance: none; 
            padding: 6px 30px 6px 12px;
            border-radius: 20px;
            border: 2px solid var(--board-base);
            background: white url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ff6f00' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e") no-repeat right 8px center;
            background-size: 14px;
            color: var(--accent);
            font-weight: bold;
            font-family: inherit;
            font-size: 0.85rem;
            outline: none;
            cursor: pointer;
            width: auto;
            box-shadow: 0 3px 0 rgba(0,0,0,0.1);
            transition: all 0.2s;
        }

        .algo-selector:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 rgba(0,0,0,0.1);
        }

        /* æ­¥éª¤åˆ—è¡¨ */
        #step-list {
            flex: 1;
            display: flex;
            flex-direction: row; 
            overflow-x: auto; 
            overflow-y: hidden;
            padding: 30px 15px;
            gap: 12px;
            align-items: center;
            scrollbar-width: none; 
        }
        #step-list::-webkit-scrollbar { display: none; }

        .step-item {
            width: 50px;
            height: 50px;
            flex-shrink: 0;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 1.2rem;
            color: white;
            box-shadow: 0 3px 0 rgba(0,0,0,0.15);
            position: relative;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .step-item:not(:last-child)::after {
            content: 'â†’';
            position: absolute;
            right: -14px;
            color: #ccc;
            font-size: 1rem;
            font-weight: normal;
        }

        .step-item.active {
            transform: scale(1.1);
            border: 2px solid var(--accent);
            box-shadow: 0 5px 10px rgba(0,0,0,0.2);
            z-index: 2;
        }

        .empty-tip {
            width: 100%;
            text-align: center;
            color: #999;
            font-size: 0.9rem;
            padding: 10px;
        }

        /* åº†å…¸ Canvas */
        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
        }
    </style>
</head>
<body>

<canvas id="confetti-canvas"></canvas>

<div class="container">
    <div class="game-main">
        <div class="controls">
            <button class="btn" onclick="initGame()">æ–°æŒ‘æˆ˜</button>
            <div id="status">æ­¥æ•°: 0</div>
        </div>

        <div class="board-outer">
            <div class="board-inner" id="board"></div>
            <!-- åŠ è½½é®ç½©å±‚ -->
            <div id="loading-mask" class="loading-mask">
                <div class="spinner"></div>
                <div class="loading-text">AI æ­£åœ¨å…¨é€Ÿæ€è€ƒä¸­â€¦â€¦</div>
            </div>
        </div>
    </div>

    <!-- åº•éƒ¨æµ®åŠ¨æ•™å­¦åŠ©æ‰‹ -->
    <div class="sidebar">
        <div class="sidebar-header">
            <div class="header-left">
                <div class="header-title">AI åŠ©æ‰‹</div>
                <div id="goal-display" class="current-goal">
                    <span>å‡†å¤‡å°±ç»ª</span>
                </div>
            </div>
            <select id="algo-select" class="algo-selector" onchange="triggerAI(true)">
                <option value="regular" selected>å¸¸è§„ (é€ä¸ª)</option>
                <option value="intermediate">ğŸš€ ä¸­é˜¶ (é€å±‚)</option>
                <option value="advanced">é«˜é˜¶ (IDA*)</option>
            </select>
        </div>
        <div id="step-list">
            <div class="empty-tip">ç‚¹å‡»â€œæ–°æŒ‘æˆ˜â€å¼€å§‹</div>
        </div>
    </div>
</div>

<script>
    const GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];
    const TARGET_POS = {}; 
    GOAL.forEach((v, i) => TARGET_POS[v] = i);

    // é¢„è®¡ç®—æ‰€æœ‰ä½ç½®çš„é‚»å±…ç´¢å¼•ï¼Œé¿å…è¿è¡Œæ—¶è®¡ç®— (æ€§èƒ½ä¼˜åŒ–æ ¸å¿ƒ)
    const NEIGHBOR_MAP = [];
    for(let i=0; i<16; i++) {
        const r = Math.floor(i/4), c = i%4;
        const neighbors = [];
        if (r > 0) neighbors.push(i - 4);
        if (r < 3) neighbors.push(i + 4);
        if (c > 0) neighbors.push(i - 1);
        if (c < 3) neighbors.push(i + 1);
        NEIGHBOR_MAP[i] = neighbors;
    }

    // ç®€å•çš„æœ€å°äºŒå‰å †å®ç° (O(logN) æ›¿ä»£ Array.sort çš„ O(NlogN))
    class MinHeap {
        constructor() { this.data = []; }
        push(val) {
            this.data.push(val);
            this.bubbleUp(this.data.length - 1);
        }
        pop() {
            if (this.data.length === 0) return null;
            const top = this.data[0];
            const bottom = this.data.pop();
            if (this.data.length > 0) {
                this.data[0] = bottom;
                this.sinkDown(0);
            }
            return top;
        }
        size() { return this.data.length; }
        bubbleUp(i) {
            while (i > 0) {
                const p = Math.floor((i - 1) / 2);
                if (this.data[p].f <= this.data[i].f) break;
                [this.data[p], this.data[i]] = [this.data[i], this.data[p]];
                i = p;
            }
        }
        sinkDown(i) {
            const length = this.data.length;
            while (true) {
                let left = 2 * i + 1, right = 2 * i + 2, swap = null;
                if (left < length && this.data[left].f < this.data[i].f) swap = left;
                if (right < length && this.data[right].f < (swap === null ? this.data[i].f : this.data[left].f)) swap = right;
                if (swap === null) break;
                [this.data[i], this.data[swap]] = [this.data[swap], this.data[i]];
                i = swap;
            }
        }
    }

    let state = [];
    let moves = 0;
    let currentPath = []; 
    let isComputing = false;
    let lockedIndices = []; 

    function initGame() {
        moves = 0;
        currentPath = [];
        state = generateSolvableState();
        stopConfetti(); 
        renderBoard();
        updateUI();
        triggerAI(true);
    }

    function generateSolvableState() {
        let arr;
        do { arr = [...GOAL].sort(() => Math.random() - 0.5); } while (!isSolvable(arr));
        return arr;
    }

    function isSolvable(arr) {
        let inv = 0;
        for (let i = 0; i < 16; i++) {
            if (arr[i] === 0) continue;
            for (let j = i + 1; j < 16; j++) { if (arr[j] !== 0 && arr[i] > arr[j]) inv++; }
        }
        const row = 4 - Math.floor(arr.indexOf(0) / 4);
        return (inv + row) % 2 !== 0;
    }

    function handleMove(idx) {
        if (isComputing) return;

        const emptyIdx = state.indexOf(0);
        const r1 = Math.floor(idx / 4), c1 = idx % 4;
        const r2 = Math.floor(emptyIdx / 4), c2 = emptyIdx % 4;

        if (Math.abs(r1 - r2) + Math.abs(c1 - c2) === 1) {
            const movedValue = state[idx];
            const followedAI = (currentPath.length > 0 && movedValue === currentPath[0]);

            state[emptyIdx] = state[idx];
            state[idx] = 0;
            moves++;

            if (followedAI) {
                currentPath.shift();
                if (currentPath.length === 0 && !isGameComplete()) {
                    renderBoard();
                    updateUI();
                    triggerAI(false); 
                } else {
                    displayPath(currentPath);
                    renderBoard();
                    updateUI();
                }
            } else {
                renderBoard();
                updateUI();
                triggerAI(false);
            }

            if (isGameComplete()) {
                startConfetti();
                document.getElementById('goal-display').innerHTML = "ğŸ‰ å…¨éƒ¨å®Œæˆ";
            }
        }
    }

    function isGameComplete() {
        return state.every((v, i) => v === GOAL[i]);
    }

    function triggerAI(isReset) {
        if (isGameComplete()) {
            displayPath([]);
            updateLockedUI(state, document.getElementById('algo-select').value);
            return;
        }

        const algo = document.getElementById('algo-select').value;
        const listEl = document.getElementById('step-list');
        const goalEl = document.getElementById('goal-display');
        const mask = document.getElementById('loading-mask'); 
        
        mask.classList.add('active');

        if (currentPath.length === 0) {
            listEl.innerHTML = '<div class="empty-tip">AI æ€è€ƒä¸­...</div>';
        }

        isComputing = true;
        
        setTimeout(() => {
            let result = null;
            const startTime = Date.now();

            try {
                if (algo === 'regular') {
                    result = solveRegularSmart([...state]);
                } else if (algo === 'intermediate') {
                    result = solveIntermediate([...state]);
                } else {
                    // é«˜é˜¶ç®—æ³•
                    const advancedPath = solveAdvanced([...state], startTime);
                    if (advancedPath) {
                        result = { path: advancedPath, goalName: "å…¨å±€æœ€ä¼˜" };
                    } else {
                        // ç†”æ–­ä¿æŠ¤ï¼šå¦‚æœè¶…æ—¶æˆ–æ‰¾ä¸åˆ°ï¼Œé™çº§åˆ°ä¸­é˜¶
                        console.warn("IDA* timed out or failed, falling back to Intermediate.");
                        result = solveIntermediate([...state]);
                        result.goalName = "å¿«é€Ÿè§£æ³• (è¶…æ—¶é™çº§)";
                    }
                }
            } catch (e) {
                console.error("AI Error:", e);
                // å‘ç”Ÿé”™è¯¯æ—¶çš„ä¿åº•
                result = { path: [], goalName: "è®¡ç®—å‡ºé”™" };
            }

            if (result && result.goalName) {
                goalEl.innerHTML = `<span>ğŸ¯ ${result.goalName}</span>`;
            }

            if (result && result.path) {
                currentPath = result.path;
                displayPath(currentPath);
            } else {
                currentPath = [];
                listEl.innerHTML = '<div class="empty-tip">è¯·æ‰‹åŠ¨ç§»åŠ¨å‡ æ­¥</div>';
            }
            
            updateLockedUI(state, algo);
            renderBoard();
            
            mask.classList.remove('active');
            isComputing = false;
        }, 50);
    }
    
    function getLayerClass(val) {
        if (val >= 1 && val <= 4) return 'layer-1';
        if (val >= 5 && val <= 8) return 'layer-2';
        if (val >= 9 && val <= 12) return 'layer-3';
        if (val >= 13 && val <= 15) return 'layer-4';
        return '';
    }

    // --- 1. å¸¸è§„ç®—æ³• (é€ä¸ªå‡»ç ´) ---
    function solveRegularSmart(currState) {
        const isCorrect = (val, idx) => currState[idx] === val;
        
        if (!isCorrect(1, 0)) return { goalName: "ç›®æ ‡: 1", path: solveStage(currState, {1:0}, [])?.path };
        if (!isCorrect(2, 1)) return { goalName: "ç›®æ ‡: 2", path: solveStage(currState, {2:1}, [0])?.path };
        if (!isCorrect(3, 2)) return { goalName: "ç›®æ ‡: 3", path: solveStage(currState, {3:2}, [0, 1])?.path };
        if (!isCorrect(4, 3)) return { goalName: "ç›®æ ‡: 4", path: solveStage(currState, {3:2, 4:3}, [0, 1])?.path };

        const L1_Locks = [0, 1, 2, 3];
        if (!isCorrect(5, 4)) return { goalName: "ç›®æ ‡: 5", path: solveStage(currState, {5:4}, L1_Locks)?.path };
        if (!isCorrect(6, 5)) return { goalName: "ç›®æ ‡: 6", path: solveStage(currState, {6:5}, [...L1_Locks, 4])?.path };
        if (!isCorrect(7, 6)) return { goalName: "ç›®æ ‡: 7", path: solveStage(currState, {7:6}, [...L1_Locks, 4, 5])?.path };
        if (!isCorrect(8, 7)) return { goalName: "ç›®æ ‡: 8", path: solveStage(currState, {7:6, 8:7}, [...L1_Locks, 4, 5])?.path };

        const Bottom_Locks = [0, 1, 2, 3, 4, 5, 6, 7];
        const finalTargets = {};
        for(let v=9; v<=15; v++) finalTargets[v] = v-1;
        return { goalName: "æœ€åé˜¶æ®µ", path: solveStage(currState, finalTargets, Bottom_Locks)?.path };
    }

    // --- 2. ä¸­é˜¶ç®—æ³• (é€å±‚å‡»ç ´) ---
    function solveIntermediate(currState) {
        const isL1Done = [1,2,3,4].every(v => currState[v-1] === v);
        if (!isL1Done) {
             return { 
                 goalName: "ç›®æ ‡: ç¬¬ä¸€å±‚ (1-4)", 
                 path: solveStage(currState, {1:0, 2:1, 3:2, 4:3}, [])?.path 
             };
        }

        const isL2Done = [5,6,7,8].every(v => currState[v-1] === v);
        const L1_Locks = [0, 1, 2, 3];
        if (!isL2Done) {
             return { 
                 goalName: "ç›®æ ‡: ç¬¬äºŒå±‚ (5-8)", 
                 path: solveStage(currState, {5:4, 6:5, 7:6, 8:7}, L1_Locks)?.path 
             };
        }

        const Bottom_Locks = [0, 1, 2, 3, 4, 5, 6, 7];
        const finalTargets = {};
        for(let v=9; v<=15; v++) finalTargets[v] = v-1;
        
        return { 
            goalName: "ç›®æ ‡: å‰©ä½™å…¨éƒ¨", 
            path: solveStage(currState, finalTargets, Bottom_Locks)?.path 
        };
    }

    // --- 3. é«˜é˜¶ç®—æ³• (ä¼˜åŒ–ç‰ˆ IDA*) ---
    // å¢åŠ  Linear Conflict å¯å‘å‡½æ•°ï¼Œå¹¶å¢åŠ è¶…æ—¶ç†”æ–­
    function solveAdvanced(startState, startTime) {
        lockedIndices = []; 
        let limit = getGlobalHeuristicEnhanced(startState);
        const path = [];
        const MAX_TIME = 15000; // è°ƒæ•´è¶…æ—¶ä¸º 10 ç§’

        // IDA* ä¸»å¾ªç¯
        while(true) {
            // æ—¶é—´ç†”æ–­æ£€æŸ¥
            if (Date.now() - startTime > MAX_TIME) return null;

            const res = dfs(startState, 0, limit, -1, path, startTime, MAX_TIME);
            if (res === "FOUND") return path;
            if (res === Infinity) return null;
            limit = res;
            
            // å¦‚æœæ·±åº¦è¿‡å¤§(è¶…è¿‡70æ­¥å¯¹15æ‹¼å›¾æ¥è¯´æç½•è§)ï¼Œä¹Ÿç†”æ–­
            if (limit > 70) return null;
        }
    }

    function dfs(curr, g, limit, lastMove, path, startTime, maxTime) {
        // å¯å‘å¼å‡½æ•°
        const h = getGlobalHeuristicEnhanced(curr);
        const f = g + h;
        if (f > limit) return f;
        if (h === 0) return "FOUND";

        // é—´æ­‡æ€§æ£€æŸ¥æ—¶é—´ (æ¯1000èŠ‚ç‚¹æ£€æŸ¥ä¸€æ¬¡å¤ªæ…¢ï¼Œæ”¾åœ¨å¾ªç¯å¤–å±‚æ§åˆ¶ï¼Œè¿™é‡Œä»…åšè½»é‡é€’å½’)
        // ä½†ä¸ºäº†å½»åº•é˜²å¡æ­»ï¼Œæ¯å½“ g è¾ƒå°æ—¶æ£€æŸ¥ä¸€ä¸‹
        if (g < 5 && (Date.now() - startTime > maxTime)) return Infinity;

        let min = Infinity;
        const emptyIdx = curr.indexOf(0);
        
        // ä½¿ç”¨é¢„è®¡ç®—çš„é‚»å±…è¡¨
        const neighbors = NEIGHBOR_MAP[emptyIdx]; 
        
        for (let i = 0; i < neighbors.length; i++) {
            const nIdx = neighbors[i];
            const val = curr[nIdx];
            
            if (val === lastMove) continue; // é¿å…æ¥å›èµ°

            // Swap
            curr[emptyIdx] = val;
            curr[nIdx] = 0;
            path.push(val);

            const t = dfs(curr, g + 1, limit, val, path, startTime, maxTime);
            
            if (t === "FOUND") return "FOUND";
            if (t < min) min = t;

            // Backtrack
            path.pop();
            curr[nIdx] = val;
            curr[emptyIdx] = 0;
            
            // å¦‚æœå­æœç´¢è¿”å›è¶…æ—¶/ç†”æ–­ä¿¡å·
            if (min === Infinity && (Date.now() - startTime > maxTime)) return Infinity;
        }
        return min;
    }

    // --- å¢å¼ºç‰ˆå…¨å±€å¯å‘å‡½æ•°ï¼šManhattan + Linear Conflict ---
    function getGlobalHeuristicEnhanced(arr) {
        let h = 0;
        let conflict = 0;
        const size = 4;

        // 1. æ›¼å“ˆé¡¿è·ç¦»
        for (let i = 0; i < 16; i++) {
            let val = arr[i];
            if (val === 0) continue;
            let targetIdx = val - 1;
            
            let rCurr = (i >> 2); // i / 4
            let cCurr = (i & 3);  // i % 4
            let rTarg = (targetIdx >> 2);
            let cTarg = (targetIdx & 3);
            
            h += Math.abs(rCurr - rTarg) + Math.abs(cCurr - cTarg);

            // 2. è¡Œå†…çº¿æ€§å†²çªæ£€æµ‹
            // å¦‚æœå½“å‰å—å’Œç›®æ ‡å—éƒ½åœ¨åŒä¸€è¡Œ
            if (rCurr === rTarg) {
                // æ£€æŸ¥è¿™è¡Œå³ä¾§çš„å…¶ä»–å—
                for (let k = cCurr + 1; k < 4; k++) {
                    let otherVal = arr[rCurr * 4 + k];
                    if (otherVal === 0) continue;
                    let otherTarget = otherVal - 1;
                    let rOtherTarg = (otherTarget >> 2);
                    
                    // å¦‚æœå³ä¾§çš„å—ä¹Ÿå±äºè¿™ä¸€è¡Œï¼Œå¹¶ä¸”å®ƒçš„ç›®æ ‡åˆ—åœ¨å½“å‰å—ç›®æ ‡åˆ—çš„å·¦ä¾§ -> å†²çª
                    if (rOtherTarg === rCurr && (otherTarget & 3) < cTarg) {
                        conflict += 2;
                    }
                }
            }
            // åˆ—å†²çªæ£€æµ‹å¯ä»¥è¿›ä¸€æ­¥å¢åŠ ç²¾åº¦ï¼Œä½†åœ¨JSä¸­å¯èƒ½å¾—ä¸å¿å¤±ï¼Œè¡Œå†²çªæ€§ä»·æ¯”æœ€é«˜
        }
        return h + conflict;
    }

    // --- ä¼˜åŒ–åçš„ A* æ±‚è§£å™¨ (ä½¿ç”¨ MinHeap) ---
    function solveStage(startState, targetGoals, fixedIndices) {
        let heap = new MinHeap();
        let startH = getStageHeuristic(startState, targetGoals);
        
        heap.push({
            state: [...startState],
            g: 0,
            h: startH,
            f: 0 + startH, // f = g + h
            path: [],
            emptyIdx: startState.indexOf(0)
        });
        
        let closedSet = new Set();
        let fixedSet = new Set(fixedIndices);
        
        // é™åˆ¶æ­¥æ•°é˜²æ­¢ç‰¹æ®Šæƒ…å†µå¡æ­»
        let maxIter = 200000; // å¢åŠ è®¡ç®—æ­¥æ•°ä¸Šé™è‡³ 200,000ï¼Œè§£å†³å¤æ‚æƒ…å†µç®—ä¸å‡ºçš„é—®é¢˜

        while (heap.size() > 0 && maxIter-- > 0) {
            let current = heap.pop(); // O(logN) operation

            let stateStr = current.state.join(',');
            if (closedSet.has(stateStr)) continue;
            closedSet.add(stateStr);

            if (current.h === 0) {
                return { path: current.path, state: current.state };
            }

            // ä½¿ç”¨é¢„è®¡ç®—é‚»å±…
            const neighbors = NEIGHBOR_MAP[current.emptyIdx];
            
            for (let i = 0; i < neighbors.length; i++) {
                let nIdx = neighbors[i];
                if (fixedSet.has(nIdx)) continue; // é”å®šå—ä¸å¯åŠ¨

                let newState = [...current.state];
                let moveVal = newState[nIdx];
                
                newState[current.emptyIdx] = moveVal;
                newState[nIdx] = 0;

                // ç®€å•çš„çŠ¶æ€æŸ¥é‡æ£€æŸ¥ï¼Œåªæœ‰æœªè®¿é—®æ‰è®¡ç®—Hæ”¾å…¥å †
                if (!closedSet.has(newState.join(','))) {
                    let h = getStageHeuristic(newState, targetGoals);
                    let newG = current.g + 1;
                    heap.push({
                        state: newState,
                        g: newG,
                        h: h,
                        f: newG + h,
                        path: [...current.path, moveVal],
                        emptyIdx: nIdx
                    });
                }
            }
        }
        return null; // æœªæ‰¾åˆ°è§£
    }

    // --- é˜¶æ®µæ€§å¯å‘å‡½æ•° (ä¿æŒåŸæœ‰é€»è¾‘ï¼Œå·²åŒ…å«å†²çªæ£€æµ‹) ---
    function getStageHeuristic(arr, targets) {
        let h = 0;
        let conflict = 0;
        
        // é¢„å¤„ç†ç›®æ ‡æ•°æ®ç»“æ„ä»¥ä¾¿å¿«é€ŸæŸ¥æ‰¾
        // å®é™…ä½¿ç”¨ä¸­ targets å¯¹è±¡å¾ˆå°ï¼Œéå†å¼€é”€ä¸å¤§
        
        for (let tileStr in targets) {
            let tile = parseInt(tileStr);
            let currIdx = arr.indexOf(tile);
            if (currIdx === -1) continue;
            let targetIdx = targets[tile];
            
            let r1 = (currIdx >> 2), c1 = (currIdx & 3);
            let r2 = (targetIdx >> 2), c2 = (targetIdx & 3);
            
            h += Math.abs(r1 - r2) + Math.abs(c1 - c2);
        }

        // ç®€åŒ–ç‰ˆçº¿æ€§å†²çªè®¡ç®— (é’ˆå¯¹å±€éƒ¨ç›®æ ‡)
        // ä¸ºä¿æŒæ€§èƒ½ï¼Œæ­¤å¤„ä»…åšç®€å•ä¼°ç®—æˆ–æ²¿ç”¨ä¹‹å‰çš„é€»è¾‘
        // ä¹‹å‰çš„é€»è¾‘æ¯”è¾ƒé‡ï¼Œè¿™é‡Œç¨å¾®ç²¾ç®€ä¸€ä¸‹ï¼Œåªç®— H ä¹Ÿè¶³å¤Ÿè§£å†³å±€éƒ¨é—®é¢˜ï¼Œ
        // ä½†åŠ ä¸Šå†²çªæƒé‡(3.0)éå¸¸é‡è¦ï¼Œä¿æŒä¸å˜
        
        // å¤ç”¨ä¹‹å‰çš„é€»è¾‘...
        const rowGroups = {};
        for (let tileStr in targets) {
            let tile = parseInt(tileStr);
            let targetIdx = targets[tile];
            let tRow = Math.floor(targetIdx / 4);
            if (!rowGroups[tRow]) rowGroups[tRow] = [];
            rowGroups[tRow].push({tile: tile, tCol: targetIdx % 4});
        }

        for (let r in rowGroups) {
            let tRow = parseInt(r);
            let group = rowGroups[tRow];
            let inRowTiles = [];
            for (let c = 0; c < 4; c++) {
                let val = arr[tRow * 4 + c];
                let targetInfo = group.find(g => g.tile === val);
                if (targetInfo) inRowTiles.push({ val: val, currCol: c, tCol: targetInfo.tCol });
            }
            for (let i = 0; i < inRowTiles.length; i++) {
                for (let j = i + 1; j < inRowTiles.length; j++) {
                    let t1 = inRowTiles[i];
                    let t2 = inRowTiles[j];
                    if (t1.tCol > t2.tCol) conflict += 2;
                }
            }
        }
        
        return (h + conflict) * 3;
    }

    function displayPath(path) {
        const listEl = document.getElementById('step-list');
        listEl.innerHTML = '';
        
        document.querySelectorAll('.tile').forEach(t => t.classList.remove('hint'));

        if (!path || path.length === 0) {
            if (isGameComplete()) listEl.innerHTML = '<div class="empty-tip" style="color:green;">ğŸ‰ æ­å–œï¼å·²å®Œæˆï¼</div>';
            return;
        }

        path.forEach((val, i) => {
            const item = document.createElement('div');
            item.className = `step-item ${getLayerClass(val)} ${i === 0 ? 'active' : ''}`;
            item.innerText = val;
            listEl.appendChild(item);
            
            if (i === 0) {
                const tile = document.getElementById(`tile-${val}`);
                if (tile) tile.classList.add('hint');
            }
        });
        
        listEl.scrollLeft = 0;
    }

    function renderBoard() {
        const board = document.getElementById('board');
        board.innerHTML = '';
        state.forEach((val, idx) => {
            if (val === 0) return;
            const tile = document.createElement('div');
            
            tile.className = `tile ${getLayerClass(val)}`;
            if (lockedIndices.includes(idx)) tile.classList.add('locked');
            
            tile.id = `tile-${val}`;
            tile.innerText = val;
            tile.style.top = `calc(${Math.floor(idx / 4) * 25}% + 5px)`;
            tile.style.left = `calc(${(idx % 4) * 25}% + 5px)`;
            tile.onclick = () => handleMove(idx);
            board.appendChild(tile);
        });
        
        if (currentPath.length > 0) {
             const nextVal = currentPath[0];
             const tile = document.getElementById(`tile-${nextVal}`);
             if (tile) tile.classList.add('hint');
        }
    }

    function updateLockedUI(currentState, algoType) {
        lockedIndices = [];
        if (typeof currentState === 'string') { algoType = currentState; currentState = state; }
        if (algoType === 'advanced') return;

        const isCorrect = (v) => currentState[v-1] === v;
        
        if (algoType === 'intermediate') {
            const L1 = [1,2,3,4].every(v => isCorrect(v));
            if (L1) lockedIndices.push(0,1,2,3);
            
            if (L1) {
                const L2 = [5,6,7,8].every(v => isCorrect(v));
                if (L2) lockedIndices.push(4,5,6,7);
            }
            return;
        }

        if (isCorrect(1)) lockedIndices.push(0);
        if (isCorrect(1) && isCorrect(2)) lockedIndices.push(1);
        if (isCorrect(1) && isCorrect(2) && isCorrect(3) && isCorrect(4)) lockedIndices.push(2, 3);
        
        if (isCorrect(1) && isCorrect(2) && isCorrect(3) && isCorrect(4)) {
            if (isCorrect(5)) lockedIndices.push(4);
            if (isCorrect(5) && isCorrect(6)) lockedIndices.push(5);
            if (isCorrect(5) && isCorrect(6) && isCorrect(7) && isCorrect(8)) lockedIndices.push(6, 7);
        }
    }

    function updateUI() {
        document.getElementById('status').innerText = `æ­¥æ•°: ${moves}`;
        const algo = document.getElementById('algo-select').value;
        updateLockedUI(state, algo);
    }

    // ==========================================
    // æ°´å½©çº¸ç¢å±‘ç‰¹æ•ˆ
    // ==========================================
    const canvas = document.getElementById("confetti-canvas");
    const ctx = canvas.getContext("2d");
    let particles = [];
    let animationId = null;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const colors = ['#ff8a80', '#4fc3f7', '#aed581', '#ce93d8', '#ffb74d'];

    class Particle {
        constructor() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height - canvas.height;
            this.size = Math.random() * 15 + 10;
            this.speedX = Math.random() * 4 - 2;
            this.speedY = Math.random() * 5 + 3;
            this.color = colors[Math.floor(Math.random() * colors.length)];
            this.rotation = Math.random() * 360;
            this.rotationSpeed = Math.random() * 10 - 5;
            this.opacity = Math.random() * 0.5 + 0.5;
        }

        update() {
            this.y += this.speedY;
            this.x += this.speedX + Math.sin(this.y * 0.01); 
            this.rotation += this.rotationSpeed;
            if (this.y > canvas.height) {
                this.y = -50;
                this.x = Math.random() * canvas.width;
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation * Math.PI / 180);
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.opacity;
            ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size * 0.6);
            ctx.restore();
        }
    }

    function startConfetti() {
        if (animationId) return; 
        particles = [];
        for (let i = 0; i < 150; i++) {
            particles.push(new Particle());
        }
        animateConfetti();
    }

    function stopConfetti() {
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    }

    function animateConfetti() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach(p => {
            p.update();
            p.draw();
        });
        animationId = requestAnimationFrame(animateConfetti);
    }

    window.onload = initGame;
</script>

</body>
</html>