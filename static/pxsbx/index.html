<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¹³è¡Œå››è¾¹å½¢çš„é¢ç§¯</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background-color: #fff;
        }
        
        #canvas {
            display: block;
            cursor: crosshair;
        }
        
        /* å‰ªä¸€å‰ªæŒ‰é’®æ ·å¼ */
        #cutButton {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 1000;
            user-select: none;
        }
        
        #cutButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        #cutButton:active {
            transform: translateY(0);
        }
        
        #cutButton.active {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }
        
        /* ä¿å­˜æ–¹æ¡ˆæŒ‰é’®æ ·å¼ */
        #saveSchemeButton {
            position: fixed;
            bottom: 80px;
            right: 20px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 1000;
            user-select: none;
            display: none; /* é»˜è®¤éšè— */
        }
        
        #saveSchemeButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        #saveSchemeButton:active {
            transform: translateY(0);
        }
        
        /* åŒå±å¯¹æ¯”æŒ‰é’®æ ·å¼ */
        #compareButton {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 1000;
            user-select: none;
            display: none; /* é»˜è®¤éšè— */
        }
        
        #compareButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        #compareButton:active {
            transform: translateY(0);
        }
        
        /* åˆ†å±æ¨¡å¼æ ·å¼ */
        .split-screen-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f5f5f5;
            z-index: 2000;
            display: none;
            flex-direction: column;
        }
        
        .split-screen-header {
            background: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            flex-direction: column;
            justify-content: center;
            gap: 5px;
            padding: 10px 5px;
            height: 100%;
        }
        
        .split-screen-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }
        
        .split-mode-button,.clear-schemes-button,.close-split-button {
            padding: 12px 8px;
            background: #e5e7eb;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 18px;
            width: 100%;
            text-align: center;
        }
        
        .split-mode-button.active {
            background: #3b82f6;
            color: white;
        }
        
        .split-mode-button:hover {
            background: #d1d5db;
        }
        
        .split-mode-button.active:hover {
            background: #2563eb;
        }
        
        .close-split-button {
            background: #ef4444;
        }
        
        .close-split-button:hover {
            background: #dc2626;
        }
        
        .clear-schemes-button {
            background: #f59e0b;
        }
        
        .clear-schemes-button:hover {
            background: #d97706;
        }
        
        .split-screen-content {
            height: 100%;
            width: calc(100% - 100px);
            display: grid;
            gap: 2px;
            padding: 2px;
        }
        
        .split-screen-content.two-split {
            grid-template-columns: 1fr 1fr;
        }
        
        .split-screen-content.four-split {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
        }
        
        .split-panel {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        
        .split-panel-header {
            height: 40px;
            background: #f8fafc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #374151;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .split-panel-canvas {
            width: 100%;
            height: calc(100% - 40px);
            display: block;
        }
        
        /* è£åˆ‡æ¨¡å¼ä¸‹çš„å…‰æ ‡æ ·å¼ */
        #canvas.cut-mode {
            cursor: crosshair;
        }
        
        /* æ‹–åŠ¨æ¨¡å¼ä¸‹çš„å…‰æ ‡æ ·å¼ */
        #canvas.drag-mode {
            cursor: grab;
        }
        
        #canvas.drag-mode:active {
            cursor: grabbing;
        }
        
        /* æ“ä½œæŒ‰é’®æ ·å¼ */
        .action-buttons {
            position: absolute;
            display: flex;
            gap: 8px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1001;
        }
        
        .action-button {
            background: transparent;
            width: 48px;
            height: 48px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            transition: all 0.2s ease;
        }
        
        .action-button:hover {
            background: #e0e0e0;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <button id="cutButton">âœ‚ï¸ å‰ªä¸€å‰ª</button>
    <button id="saveSchemeButton">ğŸ’¾ ä¿å­˜æ–¹æ¡ˆ</button>
    <button id="compareButton">ğŸ“Š åŒå±å¯¹æ¯”</button>
    
    <!-- åˆ†å±å¯¹æ¯”å®¹å™¨ -->
    <div id="splitScreenContainer" class="split-screen-container">
        <div class="split-screen-header">
            <div class="split-screen-controls">
                <button id="twoSplitButton" class="split-mode-button active">ä¸¤æ ¼</button>
                <button id="fourSplitButton" class="split-mode-button">å››æ ¼</button>
                <button id="clearSchemesButton" class="clear-schemes-button">æ¸…é™¤</button>
                <button id="closeSplitButton" class="close-split-button">å…³é—­</button>
            </div>
        </div>
        <div id="splitScreenContent" class="split-screen-content two-split">
            <!-- åˆ†å±é¢æ¿å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const cutButton = document.getElementById('cutButton');
        const saveSchemeButton = document.getElementById('saveSchemeButton');
        const compareButton = document.getElementById('compareButton');
        const splitScreenContainer = document.getElementById('splitScreenContainer');
        const splitScreenContent = document.getElementById('splitScreenContent');
        const twoSplitButton = document.getElementById('twoSplitButton');
        const fourSplitButton = document.getElementById('fourSplitButton');
        const clearSchemesButton = document.getElementById('clearSchemesButton');
        const closeSplitButton = document.getElementById('closeSplitButton');
        
        // ç½‘æ ¼å‚æ•° - åŠ¨æ€è®¡ç®—
        function getGridSize() {
            // è·å–æµè§ˆå™¨è¾ƒçŸ­çš„è¾¹ï¼Œå¹³å‡åˆ†13ä»½ä½œä¸ºç½‘æ ¼å¤§å°
            const minDimension = Math.min(window.innerWidth, window.innerHeight);
            return Math.floor(minDimension / 13);
        }
        
        let gridSize = getGridSize(); // ç½‘æ ¼å¤§å°
        
        // è£åˆ‡æ¨¡å¼çŠ¶æ€
        let isCutMode = false;
        let cutLine = null; // å­˜å‚¨è£åˆ‡çº¿çš„èµ·ç‚¹å’Œç»ˆç‚¹
        let isDrawing = false; // æ˜¯å¦æ­£åœ¨ç»˜åˆ¶è£åˆ‡çº¿
        let isSplit = false; // æ˜¯å¦å·²ç»åˆ†å‰²
        let splitParts = []; // åˆ†å‰²åçš„å›¾å½¢éƒ¨åˆ†
        let partDragStates = []; // è®°å½•æ¯ä¸ªéƒ¨åˆ†çš„æ‹–åŠ¨çŠ¶æ€å­˜å‚¨æ¯ä¸ªéƒ¨åˆ†çš„æ‹–åŠ¨çŠ¶æ€ {hasBeenDragged: boolean}
        let isDragMode = false; // æ˜¯å¦å¤„äºæ‹–åŠ¨æ¨¡å¼
        let draggedPart = null; // å½“å‰è¢«æ‹–åŠ¨çš„éƒ¨åˆ†
        let selectedPart = null; // å½“å‰é€‰ä¸­çš„éƒ¨åˆ†
        
        // æ–¹æ¡ˆå­˜å‚¨ç›¸å…³
        let savedSchemes = []; // ä¿å­˜çš„æ–¹æ¡ˆåˆ—è¡¨
        let currentSplitMode = 'two'; // å½“å‰åˆ†å±æ¨¡å¼ï¼š'two' æˆ– 'four'
        
        // å¸é™„è·ç¦»é˜ˆå€¼
        const snapDistance = 40;
        
        // è®¾ç½® canvas å°ºå¯¸ä¸ºå…¨å±
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // é‡æ–°è®¡ç®—ç½‘æ ¼å¤§å°
            gridSize = getGridSize();
            drawGrid();
            drawParallelogram();
        }
        
        // ç»˜åˆ¶ç½‘æ ¼çº¿
        function drawGrid() {
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;
            
            // ç»˜åˆ¶å‚ç›´çº¿
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶æ°´å¹³çº¿
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // ç»˜åˆ¶å¹³è¡Œå››è¾¹å½¢
        function drawParallelogram() {
            // è®¡ç®—ç”»å¸ƒä¸­å¿ƒä½ç½®ï¼Œå¹¶å¯¹é½åˆ°ç½‘æ ¼äº¤ç‚¹
            const centerX = Math.floor(canvas.width / 2 / gridSize) * gridSize ;
            const centerY = Math.floor(canvas.height / 2 / gridSize) * gridSize;
            
            // å¹³è¡Œå››è¾¹å½¢çš„å°ºå¯¸ï¼ˆä»¥ç½‘æ ¼ä¸ºå•ä½ï¼‰
            const width = gridSize * 6; // å®½åº¦ä¸º6ä¸ªç½‘æ ¼
            const height = gridSize * 4; // é«˜åº¦ä¸º4ä¸ªç½‘æ ¼
            const skew = gridSize * -2; // å€¾æ–œåç§»é‡
            
            // è®¡ç®—å››ä¸ªé¡¶ç‚¹åæ ‡ï¼Œç¡®ä¿éƒ½åœ¨ç½‘æ ¼äº¤ç‚¹ä¸Š
            const x1 = centerX - width / 2;
            const y1 = centerY - height / 2;
            const x2 = centerX + width / 2;
            const y2 = centerY - height / 2;
            const x3 = centerX + width / 2 + skew;
            const y3 = centerY + height / 2;
            const x4 = centerX - width / 2 + skew;
            const y4 = centerY + height / 2;
            
            // å§‹ç»ˆç»˜åˆ¶åº•å±‚æ·¡ç°è‰²è™šçº¿è¾¹æ¡†ï¼ˆä¸å—åˆ†å‰²å½±å“ï¼‰
            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)'; // æ·¡ç°è‰²å¡«å……
            ctx.strokeStyle = '#999'; // ç°è‰²è¾¹æ¡†
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]); // è™šçº¿æ ·å¼
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.lineTo(x4, y4);
            ctx.closePath();
            
            ctx.fill();
            ctx.stroke();
            ctx.setLineDash([]); // é‡ç½®ä¸ºå®çº¿
            
            if (isSplit && splitParts.length === 2) {
                // ç»˜åˆ¶åˆ†å‰²åçš„ä¸¤éƒ¨åˆ†ï¼Œä½¿ç”¨ä¸åŒé¢œè‰²
                drawSplitPart(splitParts[0], 'rgba(152, 177, 228, 0.6)', '#2563eb', 0);
                drawSplitPart(splitParts[1], 'rgba(255, 182, 193, 0.6)', '#dc2626', 1);
            } else {
                // ç»˜åˆ¶å®Œæ•´çš„ä¸Šå±‚æ­£å¸¸å¹³è¡Œå››è¾¹å½¢
                ctx.fillStyle = 'rgba(152, 177, 228, 0.8)';
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 4;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.lineTo(x3, y3);
                ctx.lineTo(x4, y4);
                ctx.closePath();
                
                ctx.fill();
                ctx.stroke();
                
                // ç»˜åˆ¶é¡¶ç‚¹æ ‡è®°
                ctx.fillStyle = '#2563eb';
                const pointRadius = 4;
                
                [
                    [x1, y1], [x2, y2], [x3, y3], [x4, y4]
                ].forEach(([x, y]) => {
                    ctx.beginPath();
                    ctx.arc(x, y, pointRadius, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }
        
        // ç»˜åˆ¶åˆ†å‰²åçš„éƒ¨åˆ†
        function drawSplitPart(vertices, fillColor, strokeColor, partIndex) {
            if (vertices.length < 3) return;
            
            // å§‹ç»ˆä½¿ç”¨åŸå§‹çš„å¡«å……è‰²å’Œè¾¹æ¡†è‰²ï¼Œä¸å› æ‹–åŠ¨è€Œæ”¹å˜
            ctx.fillStyle = fillColor;
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 4;
            
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            
            ctx.fill();
            ctx.stroke();
            
            // ç»˜åˆ¶é¡¶ç‚¹æ ‡è®°
            ctx.fillStyle = strokeColor;
            const pointRadius = 4;
            
            vertices.forEach(vertex => {
                ctx.beginPath();
                ctx.arc(vertex.x, vertex.y, pointRadius, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // ç»˜åˆ¶è£åˆ‡çº¿
        function drawCutLine() {
            if (!cutLine) return;
            
            ctx.save();
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]); // è™šçº¿æ ·å¼
            
            ctx.beginPath();
            ctx.moveTo(cutLine.startX, cutLine.startY);
            ctx.lineTo(cutLine.endX, cutLine.endY);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // åˆ‡æ¢è£åˆ‡æ¨¡å¼
        function toggleCutMode() {
            // å¦‚æœå½“å‰å¤„äºæ‹–åŠ¨æ¨¡å¼æˆ–å·²åˆ†å‰²çŠ¶æ€ï¼Œç‚¹å‡»æŒ‰é’®é‡ç½®åˆ°åˆå§‹çŠ¶æ€
            if (isDragMode || isSplit) {
                // é‡ç½®æ‰€æœ‰çŠ¶æ€
                isCutMode = true; // é‡ç½®åè‡ªåŠ¨è¿›å…¥å‰ªä¸€å‰ªæ¨¡å¼
                isDragMode = false;
                isSplit = false;
                splitParts = [];
                partDragStates = []; // æ¸…é™¤æ‹–åŠ¨çŠ¶æ€
                cutLine = null;
                
                // éšè—ä¿å­˜æ–¹æ¡ˆæŒ‰é’®
                saveSchemeButton.style.display = 'none';
                
                // è®¾ç½®æŒ‰é’®ä¸ºå‰ªä¸€å‰ªæ¨¡å¼çŠ¶æ€
                cutButton.classList.add('active');
                cutButton.textContent = 'âœ‚ï¸ é€€å‡ºè£åˆ‡';
                canvas.classList.remove('drag-mode');
                canvas.classList.add('cut-mode');
                
                // éšè—æ“ä½œæŒ‰é’®
                hideActionButtons();
                
                redraw();
                return;
            }
            
            // æ­£å¸¸çš„åˆ‡æ¢è£åˆ‡æ¨¡å¼é€»è¾‘
            isCutMode = !isCutMode;
            
            if (isCutMode) {
                cutButton.classList.add('active');
                cutButton.textContent = 'âœ‚ï¸ é€€å‡ºè£åˆ‡';
                canvas.classList.add('cut-mode');
            } else {
                cutButton.classList.remove('active');
                cutButton.textContent = 'âœ‚ï¸ å‰ªä¸€å‰ª';
                canvas.classList.remove('cut-mode');
                cutLine = null; // æ¸…é™¤è£åˆ‡çº¿
                isSplit = false; // é‡ç½®åˆ†å‰²çŠ¶æ€
                splitParts = []; // æ¸…é™¤åˆ†å‰²éƒ¨åˆ†
                partDragStates = []; // æ¸…é™¤æ‹–åŠ¨çŠ¶æ€
                isDragMode = false; // é€€å‡ºæ‹–åŠ¨æ¨¡å¼
                
                // éšè—ä¿å­˜æ–¹æ¡ˆæŒ‰é’®
                saveSchemeButton.style.display = 'none';
                
                redraw(); // é‡æ–°ç»˜åˆ¶
            }
        }
        
        // é‡æ–°ç»˜åˆ¶æ•´ä¸ªç”»å¸ƒ
        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            
            drawParallelogram();
            if (cutLine) {
                drawCutLine();
            }
        }
        
        // åˆå§‹åŒ–
        resizeCanvas();
        
        // åŠ è½½ä¿å­˜çš„æ–¹æ¡ˆ
        loadSavedSchemes();
        
        // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°ç»˜åˆ¶
        window.addEventListener('resize', resizeCanvas);
        
        // æ·»åŠ æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        cutButton.addEventListener('click', toggleCutMode);
        
        // ä¿å­˜æ–¹æ¡ˆæŒ‰é’®äº‹ä»¶
        saveSchemeButton.addEventListener('click', saveCurrentScheme);
        
        // åŒå±å¯¹æ¯”æŒ‰é’®äº‹ä»¶
        compareButton.addEventListener('click', function() {
            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            compareButton.textContent = 'ğŸ“Š åŠ è½½ä¸­...';
            compareButton.disabled = true;
            
            // ä½¿ç”¨setTimeouté¿å…é˜»å¡UI
            setTimeout(() => {
                try {
                    // æ ¹æ®æ–¹æ¡ˆæ•°é‡è‡ªåŠ¨é€‰æ‹©åˆ†å±æ¨¡å¼
                    const autoMode = savedSchemes.length <= 2 ? 'two' : 'four';
                    showSplitScreen(autoMode);
                } finally {
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    compareButton.textContent = 'ğŸ“Š åŒå±å¯¹æ¯”';
                    compareButton.disabled = false;
                }
            }, 50);
        });
        
        // åˆ†å±æ¨¡å¼åˆ‡æ¢æŒ‰é’®äº‹ä»¶
        twoSplitButton.addEventListener('click', function() {
            switchSplitMode('two');
        });
        
        fourSplitButton.addEventListener('click', function() {
            switchSplitMode('four');
        });
        
        // å…³é—­åˆ†å±æŒ‰é’®äº‹ä»¶
        closeSplitButton.addEventListener('click', function() {
            hideSplitScreen();
        });
        
        // æ¸…é™¤æ–¹æ¡ˆæŒ‰é’®äº‹ä»¶
        clearSchemesButton.addEventListener('click', function() {
            clearAllSchemes();
        });
        
        // è·å–é¼ æ ‡/è§¦æ‘¸ä½ç½®çš„è¾…åŠ©å‡½æ•°
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }
        
        // é¼ æ ‡äº‹ä»¶å¤„ç†
        canvas.addEventListener('mousedown', function(e) {
            const pos = getEventPos(e);
            
            if (isCutMode) {
                // è£å‰ªæ¨¡å¼
                const snappedPos = applySnap(pos.x, pos.y);
                
                isDrawing = true;
                cutLine = {
                    startX: snappedPos.x,
                    startY: snappedPos.y,
                    endX: snappedPos.x,
                    endY: snappedPos.y
                };
            } else if (isDragMode) {
                // æ‹–åŠ¨æ¨¡å¼
                hideActionButtons();
                const partIndex = getClickedPart(pos.x, pos.y);
                if (partIndex !== null) {
                    draggedPart = partIndex;
                    selectedPart = partIndex;
                    
                    // æ ‡è®°è¯¥éƒ¨åˆ†å·²è¢«æ‹–åŠ¨ï¼ˆä»…åœ¨ç¬¬ä¸€æ¬¡æ‹–åŠ¨æ—¶ï¼‰
                    if (!partDragStates[partIndex].hasBeenDragged) {
                        partDragStates[partIndex].hasBeenDragged = true;
                    }
                }
            }
        });
        
        canvas.addEventListener('mousemove', function(e) {
            const pos = getEventPos(e);
            
            if (isCutMode && isDrawing) {
                // è£å‰ªæ¨¡å¼ä¸‹ç»˜åˆ¶è™šçº¿
                const snappedPos = applySnap(pos.x, pos.y);
                
                cutLine.endX = snappedPos.x;
                cutLine.endY = snappedPos.y;
                
                redraw();
            } else if (isDragMode && draggedPart !== null) {
                // æ‹–åŠ¨æ¨¡å¼ä¸‹ç§»åŠ¨å›¾å½¢ - åŸºäºé¡¶ç‚¹å¸é™„
                const part = splitParts[draggedPart];
                const currentCenterX = part.reduce((sum, v) => sum + v.x, 0) / part.length;
                const currentCenterY = part.reduce((sum, v) => sum + v.y, 0) / part.length;
                
                // è®¡ç®—é¼ æ ‡ç›¸å¯¹äºå›¾å½¢ä¸­å¿ƒçš„åç§»
                const deltaX = pos.x - currentCenterX;
                const deltaY = pos.y - currentCenterY;
                
                // å°è¯•ç§»åŠ¨å›¾å½¢å¹¶æ‰¾åˆ°æœ€ä½³å¸é™„ä½ç½®
                const bestSnapResult = findBestSnapForPart(draggedPart, deltaX, deltaY);
                
                if (bestSnapResult) {
                    // åº”ç”¨æœ€ä½³å¸é™„ä½ç½®
                    movePart(draggedPart, bestSnapResult.deltaX, bestSnapResult.deltaY);
                    redraw();
                }
            }
         });
         
         // æ˜¾ç¤ºåˆ†å‰²åå›¾å½¢çš„åæ ‡ä¿¡æ¯
         function displaySplitCoordinates() {
             if (!isSplit || splitParts.length !== 2) return;
             
             console.log('=== åˆ†å‰²åå›¾å½¢åæ ‡ä¿¡æ¯ ===');
             splitParts.forEach((part, index) => {
                 console.log(`ç¬¬${index + 1}éƒ¨åˆ†é¡¶ç‚¹åæ ‡:`);
                 part.forEach((vertex, vertexIndex) => {
                     console.log(`  é¡¶ç‚¹${vertexIndex + 1}: (${vertex.x.toFixed(1)}, ${vertex.y.toFixed(1)})`);
                 });
                 
                 // è®¡ç®—ä¸­å¿ƒç‚¹
                 const centerX = part.reduce((sum, v) => sum + v.x, 0) / part.length;
                 const centerY = part.reduce((sum, v) => sum + v.y, 0) / part.length;
                 console.log(`  ä¸­å¿ƒç‚¹: (${centerX.toFixed(1)}, ${centerY.toFixed(1)})`);
                 console.log('---');
             });
         }
        
        canvas.addEventListener('mouseup', function(e) {
            if (isCutMode && isDrawing) {
                // è£å‰ªæ¨¡å¼
                isDrawing = false;
                // æ‰§è¡Œåˆ†å‰²é€»è¾‘
                if (splitParallelogram()) {
                    // åˆ†å‰²æˆåŠŸåè‡ªåŠ¨é€€å‡ºè£å‰ªæ¨¡å¼å¹¶è¿›å…¥æ‹–åŠ¨æ¨¡å¼
                    isCutMode = false;
                    isDragMode = true;
                    cutButton.classList.remove('active');
                    cutButton.textContent = 'âœ‚ï¸ å‰ªä¸€å‰ª';
                    canvas.classList.remove('cut-mode');
                    canvas.classList.add('drag-mode');
                    redraw();
                }
            } else if (isDragMode && draggedPart !== null) {
                // æ‹–åŠ¨æ¨¡å¼
                const pos = getEventPos(e);
                
                // æ˜¾ç¤ºæ“ä½œæŒ‰é’®
                const part = splitParts[draggedPart];
                const centerX = part.reduce((sum, v) => sum + v.x, 0) / part.length;
                const centerY = part.reduce((sum, v) => sum + v.y, 0) / part.length;
                
                const rect = canvas.getBoundingClientRect();
                showActionButtons(draggedPart, rect.left + centerX, rect.top + centerY - 50);
                
                draggedPart = null;
            }
        });
        
        // è§¦æ‘¸äº‹ä»¶å¤„ç†
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const pos = getEventPos(e);
            
            if (isCutMode) {
                // è£å‰ªæ¨¡å¼
                const snappedPos = applySnap(pos.x, pos.y);
                
                isDrawing = true;
                cutLine = {
                    startX: snappedPos.x,
                    startY: snappedPos.y,
                    endX: snappedPos.x,
                    endY: snappedPos.y
                };
            } else if (isDragMode) {
                // æ‹–åŠ¨æ¨¡å¼
                hideActionButtons();
                const partIndex = getClickedPart(pos.x, pos.y);
                if (partIndex !== null) {
                    draggedPart = partIndex;
                    selectedPart = partIndex;
                    
                    // æ ‡è®°è¯¥éƒ¨åˆ†å·²è¢«æ‹–åŠ¨ï¼ˆä»…åœ¨ç¬¬ä¸€æ¬¡æ‹–åŠ¨æ—¶ï¼‰
                    if (!partDragStates[partIndex].hasBeenDragged) {
                        partDragStates[partIndex].hasBeenDragged = true;
                    }
                }
            }
        });
        
        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            const pos = getEventPos(e);
            
            if (isCutMode && isDrawing) {
                // è£å‰ªæ¨¡å¼ä¸‹ç»˜åˆ¶è™šçº¿
                const snappedPos = applySnap(pos.x, pos.y);
                
                cutLine.endX = snappedPos.x;
                cutLine.endY = snappedPos.y;
                
                redraw();
            } else if (isDragMode && draggedPart !== null) {
                // æ‹–åŠ¨æ¨¡å¼ä¸‹ç§»åŠ¨å›¾å½¢ - åŸºäºé¡¶ç‚¹å¸é™„
                const part = splitParts[draggedPart];
                const currentCenterX = part.reduce((sum, v) => sum + v.x, 0) / part.length;
                const currentCenterY = part.reduce((sum, v) => sum + v.y, 0) / part.length;
                
                // è®¡ç®—è§¦æ‘¸ç›¸å¯¹äºå›¾å½¢ä¸­å¿ƒçš„åç§»
                const deltaX = pos.x - currentCenterX;
                const deltaY = pos.y - currentCenterY;
                
                // å°è¯•ç§»åŠ¨å›¾å½¢å¹¶æ‰¾åˆ°æœ€ä½³å¸é™„ä½ç½®
                const bestSnapResult = findBestSnapForPart(draggedPart, deltaX, deltaY);
                
                if (bestSnapResult) {
                    // åº”ç”¨æœ€ä½³å¸é™„ä½ç½®
                    movePart(draggedPart, bestSnapResult.deltaX, bestSnapResult.deltaY);
                    redraw();
                }
            }
        });
        
        canvas.addEventListener('touchend', function(e) {
            e.preventDefault();
            
            if (isCutMode && isDrawing) {
                // è£å‰ªæ¨¡å¼
                isDrawing = false;
                // æ‰§è¡Œåˆ†å‰²é€»è¾‘
                if (splitParallelogram()) {
                    // åˆ†å‰²æˆåŠŸåè‡ªåŠ¨é€€å‡ºè£å‰ªæ¨¡å¼å¹¶è¿›å…¥æ‹–åŠ¨æ¨¡å¼
                    isCutMode = false;
                    isDragMode = true;
                    cutButton.classList.remove('active');
                    cutButton.textContent = 'âœ‚ï¸ å‰ªä¸€å‰ª';
                    canvas.classList.remove('cut-mode');
                    canvas.classList.add('drag-mode');
                    redraw();
                }
            } else if (isDragMode && draggedPart !== null) {
                // æ‹–åŠ¨æ¨¡å¼
                // æ˜¾ç¤ºæ“ä½œæŒ‰é’®
                const part = splitParts[draggedPart];
                const centerX = part.reduce((sum, v) => sum + v.x, 0) / part.length;
                const centerY = part.reduce((sum, v) => sum + v.y, 0) / part.length;
                
                const rect = canvas.getBoundingClientRect();
                showActionButtons(draggedPart, rect.left + centerX, rect.top + centerY - 50);
                
                draggedPart = null;
            }
        });
        
        // çº¿æ®µç›¸äº¤æ£€æµ‹
        function lineIntersection(p1, p2, p3, p4) {
            const x1 = p1.x, y1 = p1.y;
            const x2 = p2.x, y2 = p2.y;
            const x3 = p3.x, y3 = p3.y;
            const x4 = p4.x, y4 = p4.y;
            
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 1e-10) return null; // å¹³è¡Œçº¿
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
            
            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return {
                    x: x1 + t * (x2 - x1),
                    y: y1 + t * (y2 - y1)
                };
            }
            return null;
        }
        
        // åˆ†å‰²å¹³è¡Œå››è¾¹å½¢
        function splitParallelogram() {
            if (!cutLine) return;
            
            // è·å–å¹³è¡Œå››è¾¹å½¢çš„é¡¶ç‚¹
            const centerX = Math.floor(canvas.width / 2 / gridSize) * gridSize;
            const centerY = Math.floor(canvas.height / 2 / gridSize) * gridSize;
            const width = gridSize * 6;
            const height = gridSize * 4;
            const skew = gridSize * -2;
            
            const vertices = [
                { x: centerX - width / 2, y: centerY - height / 2 },
                { x: centerX + width / 2, y: centerY - height / 2 },
                { x: centerX + width / 2 + skew, y: centerY + height / 2 },
                { x: centerX - width / 2 + skew, y: centerY + height / 2 }
            ];
            
            // æ£€æµ‹è£åˆ‡çº¿ä¸å¹³è¡Œå››è¾¹å½¢è¾¹çš„äº¤ç‚¹
            const intersections = [];
            const cutLineStart = { x: cutLine.startX, y: cutLine.startY };
            const cutLineEnd = { x: cutLine.endX, y: cutLine.endY };
            
            for (let i = 0; i < vertices.length; i++) {
                const j = (i + 1) % vertices.length;
                const intersection = lineIntersection(
                    cutLineStart, cutLineEnd,
                    vertices[i], vertices[j]
                );
                if (intersection) {
                    intersections.push({
                        point: intersection,
                        edgeIndex: i
                    });
                }
            }
            
            // éœ€è¦è‡³å°‘ä¸¤ä¸ªäº¤ç‚¹æ‰èƒ½åˆ†å‰²
            if (intersections.length >= 2) {
                // æŒ‰è¾¹çš„é¡ºåºæ’åºäº¤ç‚¹
                intersections.sort((a, b) => a.edgeIndex - b.edgeIndex);
                
                const int1 = intersections[0];
                const int2 = intersections[1];
                
                // åˆ›å»ºä¸¤ä¸ªåˆ†å‰²éƒ¨åˆ†
                const part1 = [];
                const part2 = [];
                
                // ç¬¬ä¸€éƒ¨åˆ†ï¼šä»ç¬¬ä¸€ä¸ªäº¤ç‚¹åˆ°ç¬¬äºŒä¸ªäº¤ç‚¹ï¼ˆé¡ºæ—¶é’ˆï¼‰
                part1.push(int1.point);
                
                let currentIndex = (int1.edgeIndex + 1) % vertices.length;
                while (currentIndex !== (int2.edgeIndex + 1) % vertices.length) {
                    part1.push(vertices[currentIndex]);
                    currentIndex = (currentIndex + 1) % vertices.length;
                }
                part1.push(int2.point);
                
                // ç¬¬äºŒéƒ¨åˆ†ï¼šä»ç¬¬äºŒä¸ªäº¤ç‚¹åˆ°ç¬¬ä¸€ä¸ªäº¤ç‚¹ï¼ˆé¡ºæ—¶é’ˆï¼‰
                part2.push(int2.point);
                
                currentIndex = (int2.edgeIndex + 1) % vertices.length;
                while (currentIndex !== (int1.edgeIndex + 1) % vertices.length) {
                    part2.push(vertices[currentIndex]);
                    currentIndex = (currentIndex + 1) % vertices.length;
                }
                part2.push(int1.point);
                
                splitParts = [part1, part2];
                // åˆå§‹åŒ–æ‹–åŠ¨çŠ¶æ€
                partDragStates = [
                    { hasBeenDragged: false },
                    { hasBeenDragged: false }
                ];
                isSplit = true;
                
                // æ˜¾ç¤ºä¿å­˜æ–¹æ¡ˆæŒ‰é’®ï¼ˆä»…åœ¨æœªè¾¾åˆ°é™åˆ¶æ—¶æ˜¾ç¤ºï¼‰
                if (savedSchemes.length < 4) {
                    saveSchemeButton.style.display = 'block';
                }
                
                // æ˜¾ç¤ºåˆ†å‰²åçš„åæ ‡ä¿¡æ¯
                displaySplitCoordinates();
                
                return true;
            }
            
            return false;
        }
        
        // æœ¬åœ°å­˜å‚¨ç›¸å…³å‡½æ•°
        function loadSavedSchemes() {
            const saved = localStorage.getItem('parallelogramSchemes');
            if (saved) {
                savedSchemes = JSON.parse(saved);
                updateCompareButtonVisibility();
            }
        }
        
        function saveCurrentScheme() {
            if (!isSplit || splitParts.length !== 2) return;
            
            // æ£€æŸ¥æ˜¯å¦å·²è¾¾åˆ°æœ€å¤§æ–¹æ¡ˆæ•°é‡é™åˆ¶
            if (savedSchemes.length >= 4) {
                showNotification('æœ€å¤šåªèƒ½ä¿å­˜4ä¸ªæ–¹æ¡ˆï¼Œè¯·å…ˆæ¸…é™¤ä¸€äº›æ–¹æ¡ˆåå†ä¿å­˜');
                return;
            }
            
            const scheme = {
                id: Date.now(),
                timestamp: new Date().toLocaleString(),
                splitParts: JSON.parse(JSON.stringify(splitParts)), // æ·±æ‹·è´
                cutLine: JSON.parse(JSON.stringify(cutLine))
            };
            
            savedSchemes.push(scheme);
            localStorage.setItem('parallelogramSchemes', JSON.stringify(savedSchemes));
            
            // ä¿å­˜æˆåŠŸåéšè—ä¿å­˜æŒ‰é’®
            saveSchemeButton.style.display = 'none';
            
            // æ›´æ–°åŒå±å¯¹æ¯”æŒ‰é’®çš„æ˜¾ç¤ºçŠ¶æ€
            updateCompareButtonVisibility();
            
            // æ˜¾ç¤ºä¿å­˜æˆåŠŸæç¤º
            showNotification(`æ–¹æ¡ˆä¿å­˜æˆåŠŸï¼(${savedSchemes.length}/4)`);
        }
        
        function updateCompareButtonVisibility() {
            if (savedSchemes.length >= 2) {
                compareButton.style.display = 'block';
            } else {
                compareButton.style.display = 'none';
            }
        }
        
        function showNotification(message) {
            // åˆ›å»ºé€šçŸ¥å…ƒç´ 
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 45%;
                right: 20px;
                background: #10b981;
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                font-size: 18px;
                z-index: 1001;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                transform: translateX(100%);
                transition: transform 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // åŠ¨ç”»æ˜¾ç¤º
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // 3ç§’åè‡ªåŠ¨éšè—
            setTimeout(() => {
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }
        
        // æ¸…é™¤æ‰€æœ‰ä¿å­˜çš„æ–¹æ¡ˆ
        function clearAllSchemes() {
            if (savedSchemes.length === 0) {
                showNotification('æ²¡æœ‰éœ€è¦æ¸…é™¤çš„æ–¹æ¡ˆ');
                return;
            }
            
            // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
            const confirmed = confirm(`ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰ ${savedSchemes.length} ä¸ªä¿å­˜çš„æ–¹æ¡ˆå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`);
            
            if (confirmed) {
                // æ¸…ç©ºæ•°ç»„å’Œæœ¬åœ°å­˜å‚¨
                savedSchemes.length = 0;
                localStorage.removeItem('splitSchemes');
                
                // æ›´æ–°UIçŠ¶æ€
                updateCompareButtonVisibility();
                hideSplitScreen();
                
                showNotification('æ‰€æœ‰æ–¹æ¡ˆå·²æ¸…é™¤');
            }
        }
        
        // è·å–æ‰€æœ‰å¯å¸é™„çš„ç‚¹ï¼ˆç½‘æ ¼äº¤ç‚¹å’Œå¹³è¡Œå››è¾¹å½¢é¡¶ç‚¹ï¼‰
        // ä¸ºå›¾å½¢éƒ¨åˆ†å¯»æ‰¾æœ€ä½³å¸é™„ä½ç½®
        function findBestSnapForPart(partIndex, deltaX, deltaY) {
            if (partIndex < 0 || partIndex >= splitParts.length) return null;
            
            const part = splitParts[partIndex];
            let bestSnapResult = null;
            let minSnapDistance = snapDistance;
            
            // è®¡ç®—ç§»åŠ¨åçš„é¡¶ç‚¹ä½ç½®
            const movedVertices = part.map(vertex => ({
                x: vertex.x + deltaX,
                y: vertex.y + deltaY
            }));
            
            // è·å–æ‰€æœ‰å¯å¸é™„çš„ç‚¹
            const snapPoints = getSnapPoints();
            
            // å¯¹æ¯ä¸ªç§»åŠ¨åçš„é¡¶ç‚¹ï¼Œå¯»æ‰¾æœ€è¿‘çš„å¸é™„ç‚¹
            movedVertices.forEach((movedVertex, vertexIndex) => {
                snapPoints.forEach(snapPoint => {
                    const distance = Math.sqrt(
                        (movedVertex.x - snapPoint.x) ** 2 + 
                        (movedVertex.y - snapPoint.y) ** 2
                    );
                    
                    if (distance < minSnapDistance) {
                        // è®¡ç®—ä¸ºäº†è®©è¿™ä¸ªé¡¶ç‚¹å¸é™„åˆ°ç›®æ ‡ç‚¹éœ€è¦çš„åç§»é‡
                        const snapDeltaX = snapPoint.x - part[vertexIndex].x;
                        const snapDeltaY = snapPoint.y - part[vertexIndex].y;
                        
                        bestSnapResult = {
                            deltaX: snapDeltaX,
                            deltaY: snapDeltaY,
                            snapPoint: snapPoint,
                            vertexIndex: vertexIndex,
                            distance: distance
                        };
                        minSnapDistance = distance;
                    }
                });
            });
            
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¸é™„ç‚¹ï¼Œä½†ç”¨æˆ·ä»åœ¨æ‹–åŠ¨ï¼Œåˆ™ä½¿ç”¨å¹³æ»‘çš„ç§»åŠ¨
            if (!bestSnapResult) {
                // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•é¡¶ç‚¹æ¥è¿‘å¸é™„é˜ˆå€¼ï¼Œå¦‚æœæœ‰åˆ™è¿›è¡Œéƒ¨åˆ†å¸é™„
                let hasPartialSnap = false;
                const partialSnapThreshold = snapDistance * 1.5; // æ‰©å¤§æ£€æµ‹èŒƒå›´
                
                movedVertices.forEach((movedVertex, vertexIndex) => {
                    snapPoints.forEach(snapPoint => {
                        const distance = Math.sqrt(
                            (movedVertex.x - snapPoint.x) ** 2 + 
                            (movedVertex.y - snapPoint.y) ** 2
                        );
                        
                        if (distance < partialSnapThreshold && !hasPartialSnap) {
                            // ä½¿ç”¨æ¸è¿›å¼å¸é™„ï¼Œè·ç¦»è¶Šè¿‘å¸é™„åŠ›è¶Šå¼º
                            const snapStrength = 1 - (distance / partialSnapThreshold);
                            const snapDeltaX = snapPoint.x - part[vertexIndex].x;
                            const snapDeltaY = snapPoint.y - part[vertexIndex].y;
                            
                            bestSnapResult = {
                                deltaX: deltaX + (snapDeltaX - deltaX) * snapStrength * 0.3,
                                deltaY: deltaY + (snapDeltaY - deltaY) * snapStrength * 0.3
                            };
                            hasPartialSnap = true;
                        }
                    });
                });
                
                // å¦‚æœæ²¡æœ‰éƒ¨åˆ†å¸é™„ï¼Œè¿”å›åŸå§‹ç§»åŠ¨
                if (!hasPartialSnap) {
                    return {
                        deltaX: deltaX,
                        deltaY: deltaY
                    };
                }
            }
            
            return bestSnapResult;
        }
        
        // è·å–æ‰€æœ‰å¸é™„ç‚¹ï¼ˆåªåŒ…æ‹¬ç½‘æ ¼äº¤ç‚¹å’Œå›¾å½¢é¡¶ç‚¹ï¼‰
        function getSnapPoints() {
            const snapPoints = [];
            
            // æ·»åŠ ç½‘æ ¼äº¤ç‚¹
            for (let x = 0; x <= canvas.width; x += gridSize) {
                for (let y = 0; y <= canvas.height; y += gridSize) {
                    snapPoints.push({ x, y, type: 'grid' });
                }
            }
            
            // å¦‚æœå¤„äºæ‹–åŠ¨æ¨¡å¼ï¼Œæ·»åŠ åˆ†å‰²åå›¾å½¢çš„é¡¶ç‚¹
            if (isDragMode && splitParts.length > 0) {
                splitParts.forEach((part, partIndex) => {
                    // è·³è¿‡å½“å‰æ­£åœ¨æ‹–åŠ¨çš„éƒ¨åˆ†
                    if (partIndex === draggedPart) return;
                    
                    // æ·»åŠ é¡¶ç‚¹
                    part.forEach(vertex => {
                        snapPoints.push({ x: vertex.x, y: vertex.y, type: 'vertex' });
                    });
                });
            } else {
                // æ·»åŠ åŸå§‹å¹³è¡Œå››è¾¹å½¢é¡¶ç‚¹
                const centerX = Math.floor(canvas.width / 2 / gridSize) * gridSize;
                const centerY = Math.floor(canvas.height / 2 / gridSize) * gridSize;
                const width = gridSize * 6;
                const height = gridSize * 4;
                const skew = gridSize * -2;
                
                const vertices = [
                    { x: centerX - width / 2, y: centerY - height / 2 },
                    { x: centerX + width / 2, y: centerY - height / 2 },
                    { x: centerX + width / 2 + skew, y: centerY + height / 2 },
                    { x: centerX - width / 2 + skew, y: centerY + height / 2 }
                ];
                
                vertices.forEach(vertex => {
                    snapPoints.push({ x: vertex.x, y: vertex.y, type: 'vertex' });
                });
            }
            
            return snapPoints;
        }
        
        // å¯»æ‰¾æœ€è¿‘çš„å¸é™„ç‚¹
        function findNearestSnapPoint(x, y) {
            const snapPoints = getSnapPoints();
            let nearestPoint = null;
            let minDistance = snapDistance;
            
            snapPoints.forEach(point => {
                const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestPoint = point;
                }
            });
            
            return nearestPoint;
        }
        
        // åº”ç”¨å¸é™„
        function applySnap(x, y) {
            const snapPoint = findNearestSnapPoint(x, y);
            return snapPoint ? { x: snapPoint.x, y: snapPoint.y } : { x, y };
        }
        
        // æ£€æµ‹ç‚¹æ˜¯å¦åœ¨å¤šè¾¹å½¢å†…
        function isPointInPolygon(point, vertices) {
            let inside = false;
            for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                if (((vertices[i].y > point.y) !== (vertices[j].y > point.y)) &&
                    (point.x < (vertices[j].x - vertices[i].x) * (point.y - vertices[i].y) / (vertices[j].y - vertices[i].y) + vertices[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }
        
        // è·å–è¢«ç‚¹å‡»çš„åˆ†å‰²éƒ¨åˆ†
        function getClickedPart(x, y) {
            if (!isSplit || splitParts.length !== 2) return null;
            
            for (let i = 0; i < splitParts.length; i++) {
                if (isPointInPolygon({ x, y }, splitParts[i])) {
                    return i;
                }
            }
            return null;
        }
        
        // ç§»åŠ¨åˆ†å‰²éƒ¨åˆ†
        function movePart(partIndex, deltaX, deltaY) {
            if (partIndex < 0 || partIndex >= splitParts.length) return;
            
            splitParts[partIndex] = splitParts[partIndex].map(vertex => ({
                x: vertex.x + deltaX,
                y: vertex.y + deltaY
            }));
        }
        
        // æ—‹è½¬åˆ†å‰²éƒ¨åˆ†
        function rotatePart(partIndex) {
            if (partIndex < 0 || partIndex >= splitParts.length) return;
            
            const part = splitParts[partIndex];
            // è®¡ç®—ä¸­å¿ƒç‚¹
            const centerX = part.reduce((sum, v) => sum + v.x, 0) / part.length;
            const centerY = part.reduce((sum, v) => sum + v.y, 0) / part.length;
            
            // ç»•ä¸­å¿ƒç‚¹æ—‹è½¬90åº¦
            splitParts[partIndex] = part.map(vertex => {
                const dx = vertex.x - centerX;
                const dy = vertex.y - centerY;
                return {
                    x: centerX - dy,
                    y: centerY + dx
                };
            });
        }
        
        // å·¦å³å¯¹ç§°äº¤æ¢åˆ†å‰²éƒ¨åˆ†
        function flipPart(partIndex) {
            if (partIndex < 0 || partIndex >= splitParts.length) return;
            
            const part = splitParts[partIndex];
            // è®¡ç®—ä¸­å¿ƒç‚¹
            const centerX = part.reduce((sum, v) => sum + v.x, 0) / part.length;
            
            // å·¦å³å¯¹ç§°
            splitParts[partIndex] = part.map(vertex => ({
                x: 2 * centerX - vertex.x,
                y: vertex.y
            }));
        }
        
        // æ˜¾ç¤ºæ“ä½œæŒ‰é’®
        function showActionButtons(partIndex, x, y) {
            hideActionButtons(); // å…ˆéšè—ä¹‹å‰çš„æŒ‰é’®
            
            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'action-buttons';
            buttonsContainer.style.position = 'absolute';
            buttonsContainer.style.left = x + 'px';
            buttonsContainer.style.top = y + 'px';
            buttonsContainer.style.transform = 'translateX(-50%)';
            
            // æ—‹è½¬æŒ‰é’®
            const rotateButton = document.createElement('button');
            rotateButton.className = 'action-button';
            rotateButton.innerHTML = 'ğŸ”„';
            rotateButton.title = 'æ—‹è½¬90åº¦';
            rotateButton.onclick = function(e) {
                e.stopPropagation();
                rotatePart(partIndex);
                redraw();
                hideActionButtons();
            };
            
            // æ°´å¹³ç¿»è½¬æŒ‰é’®
            const flipButton = document.createElement('button');
            flipButton.className = 'action-button';
            flipButton.innerHTML = 'â†”ï¸';
            flipButton.title = 'æ°´å¹³ç¿»è½¬';
            flipButton.onclick = function(e) {
                e.stopPropagation();
                flipPart(partIndex);
                redraw();
                hideActionButtons();
            };
            
            buttonsContainer.appendChild(rotateButton);
            buttonsContainer.appendChild(flipButton);
            document.body.appendChild(buttonsContainer);
        }
        
        // éšè—æ“ä½œæŒ‰é’®
        function hideActionButtons() {
            const existingButtons = document.querySelector('.action-buttons');
            if (existingButtons) {
                existingButtons.remove();
            }
        }
        
        // è®¡ç®—å›¾å½¢è¾¹çº¿ä¸ç½‘æ ¼çº¿å¯¹é½çš„å¸é™„ç‚¹
        // è®¡ç®—çº¿æ®µä¸ç½‘æ ¼çº¿çš„äº¤ç‚¹
        function getLineGridIntersection(start, end, gridValue, direction) {
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            
            if (direction === 'vertical') {
                // ä¸å‚ç›´ç½‘æ ¼çº¿ x = gridValue çš„äº¤ç‚¹
                if (dx === 0) return null; // çº¿æ®µæœ¬èº«æ˜¯å‚ç›´çš„
                
                const t = (gridValue - start.x) / dx;
                if (t >= 0 && t <= 1) {
                    const y = start.y + t * dy;
                    // ç¡®ä¿äº¤ç‚¹åœ¨ç”»å¸ƒèŒƒå›´å†…
                    if (y >= 0 && y <= canvas.height) {
                        return { x: gridValue, y: y };
                    }
                }
            } else if (direction === 'horizontal') {
                // ä¸æ°´å¹³ç½‘æ ¼çº¿ y = gridValue çš„äº¤ç‚¹
                if (dy === 0) return null; // çº¿æ®µæœ¬èº«æ˜¯æ°´å¹³çš„
                
                const t = (gridValue - start.y) / dy;
                if (t >= 0 && t <= 1) {
                    const x = start.x + t * dx;
                    // ç¡®ä¿äº¤ç‚¹åœ¨ç”»å¸ƒèŒƒå›´å†…
                    if (x >= 0 && x <= canvas.width) {
                        return { x: x, y: gridValue };
                    }
                }
            }
            
            return null;
        }
        
        // åˆ†å±ç›¸å…³å‡½æ•°
        function showSplitScreen(autoMode = null) {
            // å¦‚æœæŒ‡å®šäº†è‡ªåŠ¨æ¨¡å¼ï¼Œåˆ™åˆ‡æ¢åˆ°è¯¥æ¨¡å¼
            if (autoMode) {
                switchSplitMode(autoMode);
            }
            
            splitScreenContainer.style.display = 'block';
            generateSplitPanels();
        }
        
        function hideSplitScreen() {
            splitScreenContainer.style.display = 'none';
        }
        
        function switchSplitMode(mode) {
            currentSplitMode = mode;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            twoSplitButton.classList.toggle('active', mode === 'two');
            fourSplitButton.classList.toggle('active', mode === 'four');
            
            // æ›´æ–°å®¹å™¨ç±»å
            splitScreenContent.className = `split-screen-content ${mode === 'two' ? 'two-split' : 'four-split'}`;
            
            // é‡æ–°ç”Ÿæˆé¢æ¿
            generateSplitPanels();
        }
        
        function generateSplitPanels() {
            // æ¸…ç©ºç°æœ‰é¢æ¿
            splitScreenContent.innerHTML = '';
            
            const maxPanels = currentSplitMode === 'two' ? 2 : 4;
            const schemesToShow = savedSchemes.slice(-maxPanels); // æ˜¾ç¤ºæœ€æ–°çš„æ–¹æ¡ˆ
            
            // ä½¿ç”¨DocumentFragmentæ‰¹é‡æ“ä½œDOMï¼Œæé«˜æ€§èƒ½
            const fragment = document.createDocumentFragment();
            
            schemesToShow.forEach((scheme, index) => {
                const panel = createSplitPanel(scheme, index);
                fragment.appendChild(panel);
            });
            
            // å¦‚æœæ–¹æ¡ˆæ•°é‡ä¸è¶³ï¼Œå¡«å……ç©ºé¢æ¿
            while (fragment.children.length < maxPanels) {
                const emptyPanel = createEmptyPanel(fragment.children.length);
                fragment.appendChild(emptyPanel);
            }
            
            // ä¸€æ¬¡æ€§æ·»åŠ æ‰€æœ‰é¢æ¿
            splitScreenContent.appendChild(fragment);
        }
        
        function createSplitPanel(scheme, index) {
            const panel = document.createElement('div');
            panel.className = 'split-panel';
            
            const header = document.createElement('div');
            header.className = 'split-panel-header';
            header.textContent = `æ–¹æ¡ˆ ${index + 1}`;
            
            const canvas = document.createElement('canvas');
            canvas.className = 'split-panel-canvas';
            
            panel.appendChild(header);
            panel.appendChild(canvas);
            
            // ä½¿ç”¨requestAnimationFrameä¼˜åŒ–æ¸²æŸ“æ—¶æœº
            requestAnimationFrame(() => {
                const rect = canvas.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                    drawSchemeOnCanvas(canvas, scheme);
                }
            });
            
            return panel;
        }
        
        function createEmptyPanel(index) {
            const panel = document.createElement('div');
            panel.className = 'split-panel';
            panel.style.display = 'flex';
            panel.style.alignItems = 'center';
            panel.style.justifyContent = 'center';
            panel.style.color = '#9ca3af';
            panel.style.fontSize = '16px';
            panel.textContent = 'æš‚æ— æ–¹æ¡ˆ';
            
            return panel;
        }
        
        function drawSchemeOnCanvas(canvas, scheme) {
            const ctx = canvas.getContext('2d');
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // è®¡ç®—åŸå§‹ç½‘æ ¼å¤§å°å’Œå¹³è¡Œå››è¾¹å½¢å°ºå¯¸
            const originalGridSize = getGridSize();
            const parallelogramWidth = originalGridSize * 6; // 6æ ¼å®½
            const parallelogramHeight = originalGridSize * 4; // 4æ ¼é«˜
            
            // è®¡ç®—éœ€è¦æ˜¾ç¤ºçš„åŒºåŸŸå¤§å°ï¼ˆå¹³è¡Œå››è¾¹å½¢ + å‘¨å›´çš„ç½‘æ ¼ï¼‰
            const displayWidth = parallelogramWidth + originalGridSize * 6; // å‡å°‘ç½‘æ ¼èŒƒå›´
            const displayHeight = parallelogramHeight + originalGridSize * 4; // å‡å°‘ç½‘æ ¼èŒƒå›´
            
            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼Œç¡®ä¿æ•´ä¸ªæ˜¾ç¤ºåŒºåŸŸèƒ½é€‚åº”canvas
            const scaleX = canvasWidth / displayWidth;
            const scaleY = canvasHeight / displayHeight;
            const scale = Math.min(scaleX, scaleY) * 0.9; // ç•™ä¸€äº›è¾¹è·
            
            // è®¡ç®—ç¼©æ”¾åçš„ç½‘æ ¼å¤§å°
            const scaledGridSize = originalGridSize * scale;
            
            // è®¡ç®—åç§»é‡ä½¿å›¾å½¢å±…ä¸­
            const scaledDisplayWidth = displayWidth * scale;
            const scaledDisplayHeight = displayHeight * scale;
            const offsetX = (canvasWidth - scaledDisplayWidth) / 2;
            const offsetY = (canvasHeight - scaledDisplayHeight) / 2;
            
            ctx.save();
            ctx.translate(offsetX, offsetY);
            
            // ä¼˜åŒ–ç½‘æ ¼ç»˜åˆ¶ - åªç»˜åˆ¶å¿…è¦çš„ç½‘æ ¼çº¿ï¼Œå‡å°‘ç»˜åˆ¶æ¬¡æ•°
            if (scaledGridSize > 8) { // åªæœ‰å½“ç½‘æ ¼è¶³å¤Ÿå¤§æ—¶æ‰ç»˜åˆ¶
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 0.5;
                
                // æ‰¹é‡ç»˜åˆ¶ç½‘æ ¼çº¿ï¼Œå‡å°‘beginPathè°ƒç”¨
                ctx.beginPath();
                
                // ç»˜åˆ¶å‚ç›´ç½‘æ ¼çº¿ - é™åˆ¶æ•°é‡
                const maxVerticalLines = Math.min(12, Math.floor(scaledDisplayWidth / scaledGridSize));
                for (let i = 0; i <= maxVerticalLines; i++) {
                    const x = i * scaledGridSize;
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, scaledDisplayHeight);
                }
                
                // ç»˜åˆ¶æ°´å¹³ç½‘æ ¼çº¿ - é™åˆ¶æ•°é‡
                const maxHorizontalLines = Math.min(8, Math.floor(scaledDisplayHeight / scaledGridSize));
                for (let i = 0; i <= maxHorizontalLines; i++) {
                    const y = i * scaledGridSize;
                    ctx.moveTo(0, y);
                    ctx.lineTo(scaledDisplayWidth, y);
                }
                
                ctx.stroke();
            }
            
            // è®¡ç®—å¹³è¡Œå››è¾¹å½¢åœ¨ç¼©æ”¾åç”»å¸ƒä¸­çš„ä¸­å¿ƒä½ç½®
            const centerX = scaledDisplayWidth / 2;
            const centerY = scaledDisplayHeight / 2;
            
            // è®¡ç®—ç¼©æ”¾åçš„å¹³è¡Œå››è¾¹å½¢é¡¶ç‚¹ï¼ˆä¿æŒ6Ã—4æ ¼çš„å°ºå¯¸ï¼‰
            const scaledWidth = scaledGridSize * 6;
            const scaledHeight = scaledGridSize * 4;
            const scaledSkew = scaledGridSize * -2;
            
            const scaledVertices = [
                { x: centerX - scaledWidth / 2, y: centerY - scaledHeight / 2 },
                { x: centerX + scaledWidth / 2, y: centerY - scaledHeight / 2 },
                { x: centerX + scaledWidth / 2 + scaledSkew, y: centerY + scaledHeight / 2 },
                { x: centerX - scaledWidth / 2 + scaledSkew, y: centerY + scaledHeight / 2 }
            ];
            
            // ç»˜åˆ¶åŸå§‹å¹³è¡Œå››è¾¹å½¢è½®å»“
            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            ctx.beginPath();
            ctx.moveTo(scaledVertices[0].x, scaledVertices[0].y);
            for (let i = 1; i < scaledVertices.length; i++) {
                ctx.lineTo(scaledVertices[i].x, scaledVertices[i].y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.setLineDash([]);
            
            // ç»˜åˆ¶åˆ†å‰²åçš„å›¾å½¢
            if (scheme.splitParts && scheme.splitParts.length === 2) {
                // è®¡ç®—åŸå§‹å›¾å½¢çš„ä¸­å¿ƒç‚¹å’Œç¼©æ”¾æ¯”ä¾‹
                const originalCenterX = Math.floor(window.innerWidth / 2 / originalGridSize) * originalGridSize;
                const originalCenterY = Math.floor(window.innerHeight / 2 / originalGridSize) * originalGridSize;
                
                // ç¬¬ä¸€éƒ¨åˆ† - è“è‰²
                ctx.fillStyle = 'rgba(152, 177, 228, 0.6)';
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 3;
                
                const part1 = scheme.splitParts[0];
                ctx.beginPath();
                
                part1.forEach((vertex, index) => {
                    // å°†åŸå§‹åæ ‡è½¬æ¢ä¸ºç¼©æ”¾åçš„åæ ‡
                    const relativeX = vertex.x - originalCenterX;
                    const relativeY = vertex.y - originalCenterY;
                    const scaledX = centerX + relativeX * scale;
                    const scaledY = centerY + relativeY * scale;
                    
                    if (index === 0) {
                        ctx.moveTo(scaledX, scaledY);
                    } else {
                        ctx.lineTo(scaledX, scaledY);
                    }
                });
                
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // ç¬¬äºŒéƒ¨åˆ† - çº¢è‰²
                ctx.fillStyle = 'rgba(255, 182, 193, 0.6)';
                ctx.strokeStyle = '#dc2626';
                
                const part2 = scheme.splitParts[1];
                ctx.beginPath();
                
                part2.forEach((vertex, index) => {
                    // å°†åŸå§‹åæ ‡è½¬æ¢ä¸ºç¼©æ”¾åçš„åæ ‡
                    const relativeX = vertex.x - originalCenterX;
                    const relativeY = vertex.y - originalCenterY;
                    const scaledX = centerX + relativeX * scale;
                    const scaledY = centerY + relativeY * scale;
                    
                    if (index === 0) {
                        ctx.moveTo(scaledX, scaledY);
                    } else {
                        ctx.lineTo(scaledX, scaledY);
                    }
                });
                
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            // ç»˜åˆ¶è£åˆ‡çº¿
            if (scheme.cutLine) {
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                
                // å°†åŸå§‹è£åˆ‡çº¿åæ ‡è½¬æ¢ä¸ºç¼©æ”¾åçš„åæ ‡
                const originalCenterX = Math.floor(window.innerWidth / 2 / originalGridSize) * originalGridSize;
                const originalCenterY = Math.floor(window.innerHeight / 2 / originalGridSize) * originalGridSize;
                
                const startRelativeX = scheme.cutLine.startX - originalCenterX;
                const startRelativeY = scheme.cutLine.startY - originalCenterY;
                const endRelativeX = scheme.cutLine.endX - originalCenterX;
                const endRelativeY = scheme.cutLine.endY - originalCenterY;
                
                const scaledStartX = centerX + startRelativeX * scale;
                const scaledStartY = centerY + startRelativeY * scale;
                const scaledEndX = centerX + endRelativeX * scale;
                const scaledEndY = centerY + endRelativeY * scale;
                
                ctx.beginPath();
                ctx.moveTo(scaledStartX, scaledStartY);
                ctx.lineTo(scaledEndX, scaledEndY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            ctx.restore();
        }
        
        // ç‚¹å‡»ç”»å¸ƒå…¶ä»–åŒºåŸŸéšè—æ“ä½œæŒ‰é’®
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.action-buttons') && !e.target.closest('canvas')) {
                hideActionButtons();
            }
        });
    </script>
</body>
</html>