<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>轴对称演示</title>
  <style>
    body { 
      font-family: "微软雅黑", Arial, sans-serif; 
      background: #f6faff; 
      margin: 0;
      padding: 10px;
      min-height: 100vh;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }
    h2 { 
      text-align: center; 
      margin: 0 0 15px 0;
      color: #1976d2;
      font-size: clamp(18px, 5vw, 24px);
      font-weight: normal;
    }
    .container { 
      flex: 1;
      display: flex;
      gap: 20px;
      padding: 0 10px;
    }
    .parallelogram-box { 
      flex: 1;
      min-width: 0;
    }
    .right-column {
      width: 200px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-top: 1rem;
    }
    .svg-wrap {
      background: #fff; 
      border-radius: 10px; 
      box-shadow: 0 2px 8px #0001;
      width: 100%;
      height: 100%;
    }
    svg {
      width: 100%;
      height: 100%;
    }
    .buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    button {
      width: 90px;
      height: 90px;
      padding: 0;
      font-size: 24px;
      border-radius: 10px;
      border: none;
      background: #1976d2;
      color: #fff;
      cursor: pointer;
      transition: all 0.2s;
      -webkit-tap-highlight-color: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    button:hover {
      background: #1565c0;
      transform: translateY(-2px);
    }
    button:active {
      transform: translateY(0);
    }
    #resetBtn {
      background: #2196f3;
    }
    #resetBtn:hover {
      background: #1e88e5;
    }
    #foldBtn {
      background: #f57c00;
    }
    #foldBtn:hover {
      background: #ef6c00;
    }
    .tuxing {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      justify-content: center;
    }
    .shape {
      width: 100%;
      aspect-ratio: 1;
      min-width: 60px;
      max-width: 120px;
      margin: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      cursor: pointer;
      transition: transform 0.2s;
      -webkit-tap-highlight-color: transparent;
    }
    .shape:hover {
      transform: scale(1.1);
    }
    .shape:active {
      transform: scale(0.95);
    }
    .shape svg {
      width: 100%;
      height: 100%;
    }
    .shape-name {
      position: absolute;
      bottom: -10px;
      font-size: clamp(12px, 3vw, 14px);
      color: #333;
      width: 100%;
      text-align: center;
      font-weight: normal;
    }
    @media screen and (max-width: 768px) {
      .container {
        flex-direction: column;
      }
      .right-column {
        width: 100%;
      }
      .tuxing {
        grid-template-columns: repeat(3, 1fr);
      }
      h2{display: none;}
      button{height:50px;}
      .parallelogram-box{flex:unset}
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="parallelogram-box">
      <div class="svg-wrap">
        <svg id="svg" style="touch-action:none;">
          <polygon id="poly" fill="#add8e6" stroke="#1976d2" stroke-width="3" style="opacity:0.8"/>
          <polygon id="halfPoly" fill="#fdfdfd" stroke="#1976d2" stroke-width="3" style="opacity:0.8;display:none"/>
          <polygon id="foldPoly" fill="#add8e6" stroke="#1976d2" stroke-width="3" style="opacity:0.8;display:none"/>
          <line id="axisTouchArea" stroke="transparent" stroke-width="10" stroke-linecap="round" style="cursor:grab"/>
          <line id="axis" stroke="#f57c00" stroke-width="4" stroke-linecap="round" stroke-dasharray="15,10" style="pointer-events:none"/>
        </svg>
      </div>
    </div>

    <div class="right-column">

      <h2>轴对称演示</h2>
      <div class="buttons">
        <button id="resetBtn">重置</button>
        <button id="foldBtn">折叠</button>
      </div>
      
      <div class="tuxing">
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <rect x="20" y="30" width="60" height="40" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">长方形</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <rect x="25" y="25" width="50" height="50" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">正方形</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <polygon points="35,35 65,35 70,65 20,65" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">梯形</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <polygon points="20,65 80,65 65,35 35,35" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">等腰梯形</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <polygon points="30,25 80,65 20,75" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">三角形</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <polygon points="50,25 90,75 10,75" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">等腰三角形</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <polygon points="20,35 70,35 80,65 30,65" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">平行四边形</div>
        </div>
      </div>
    </div>
  </div>
  <script>
    // 平行四边形参数（大且居中）
    const para = { x: 150, y: 150, w: 500, h: 300, skew: 100 };
    // 对称轴参数（初始为画布中线，长度比平行四边形宽）
    let axis = { x1: 50, y1: 300, x2: 750, y2: 300 };

    const svg = document.getElementById('svg');
    const poly = document.getElementById('poly');
    const halfPoly = document.getElementById('halfPoly');
    const foldPoly = document.getElementById('foldPoly');
    const axisLine = document.getElementById('axis');
    const axisTouchArea = document.getElementById('axisTouchArea');

    // 图形数据定义
    const shapes = {
      rect: {
        name: '长方形',
        getPoints: (w, h) => {
          const width = w * 0.5;
          const height = h * 0.4;
          const cx = w / 2;  // 中心点x坐标
          const cy = h / 2;  // 中心点y坐标
          return [
            [cx - width/2, cy - height/2],  // 左上
            [cx + width/2, cy - height/2],  // 右上
            [cx + width/2, cy + height/2],  // 右下
            [cx - width/2, cy + height/2]   // 左下
          ];
        }
      },
      square: {
        name: '正方形',
        getPoints: (w, h) => {
          const size = Math.min(w, h) * 0.4;
          const cx = w / 2;
          const cy = h / 2;
          return [
            [cx - size/2, cy - size/2],
            [cx + size/2, cy - size/2],
            [cx + size/2, cy + size/2],
            [cx - size/2, cy + size/2]
          ];
        }
      },
      trapezoid: {
        name: '梯形',
        getPoints: (w, h) => {
          const cx = w / 2;  // 中心点x坐标
          const cy = h / 2;  // 中心点y坐标
          const topWidth = w * 0.25;    // 上底宽度
          const bottomWidth = w * 0.5;  // 下底宽度
          const height = h * 0.3;      // 高度
          return [
            [cx - topWidth/2 + w * 0.1, cy - height/2],    // 左上（向右偏移）
            [cx + topWidth/2 + w * 0.1, cy - height/2],    // 右上（向右偏移）
            [cx + bottomWidth/2, cy + height/2],  // 右下
            [cx - bottomWidth/2, cy + height/2]   // 左下
          ];
        }
      },
      isoTrapezoid: {
        name: '等腰梯形',
        getPoints: (w, h) => {
          const cx = w / 2;
          const cy = h / 2;
          const topWidth = w * 0.3;
          const bottomWidth = w * 0.6;  // 增加底边长度
          const height = h * 0.3;
          const indent = (bottomWidth - topWidth) / 2;
          return [
            [cx - topWidth/2, cy - height/2],
            [cx + topWidth/2, cy - height/2],
            [cx + bottomWidth/2, cy + height/2],
            [cx - bottomWidth/2, cy + height/2]
          ];
        }
      },
      triangle: {
        name: '三角形',
        getPoints: (w, h) => {
          const cx = w / 2;
          const cy = h / 2;
          const width = w * 0.5;
          const height = h * 0.4;
          return [
            [cx - width * 0.2, cy - height/2],  // 左上
            [cx + width * 0.5, cy + height * 0.15],  // 右
            [cx - width * 0.3, cy + height/2]   // 左下
          ];
        }
      },
      isoTriangle: {
        name: '等腰三角形',
        getPoints: (w, h) => {
          const cx = w / 2;
          const cy = h / 2;
          const width = w * 0.8;  // 增加底边长度到接近整个宽度
          const height = h * 0.4;
          return [
            [cx, cy - height/2],
            [cx + width/2, cy + height/2],
            [cx - width/2, cy + height/2]
          ];
        }
      },
      parallelogram: {
        name: '平行四边形',
        getPoints: (w, h) => {
          const x = w * 0.2;
          const y = h * 0.3;
          const width = w * 0.5;
          const height = h * 0.4;
          const skew = w * 0.1;
          return [
            [x, y],
            [x + width, y],
            [x + width + skew, y + height],
            [x + skew, y + height]
          ];
        }
      }
    };

    let currentShape = 'parallelogram';
    
    // 更新图形
    function updateShape(shapeName) {
      currentShape = shapeName;
      const svg = document.getElementById('svg');
      const box = svg.getBoundingClientRect();
      const w = box.width;
      const h = box.height;
      
      if (shapes[shapeName]) {
        para.points = shapes[shapeName].getPoints(w, h);
      }
      
      drawShape();
      setAxisPosition();
    }

    // 修改绘制函数
    function drawShape() {
      const points = para.points || getPoints();
      poly.setAttribute('points', points.map(p => p.join(',')).join(' '));
    }

    // 为每个图形添加点击事件
    document.querySelectorAll('.shape').forEach((shape, index) => {
      shape.onclick = () => {
        const shapeNames = Object.keys(shapes);
        if (index < shapeNames.length) {
          updateShape(shapeNames[index]);
        }
      };
    });

    // 修改原有的 getPoints 函数为平行四边形专用
    function getPoints() {
      const svg = document.getElementById('svg');
      const box = svg.getBoundingClientRect();
      const w = box.width;
      const h = box.height;
      
      const x = w * 0.2;
      const y = h * 0.3;
      const width = w * 0.5;
      const height = h * 0.4;
      const skew = w * 0.1;
      
      return [
        [x, y],
        [x + width, y],
        [x + width + skew, y + height],
        [x + skew, y + height]
      ];
    }

    // 画平行四边形
    function drawParallelogram() {
      const pts = getPoints();
      poly.setAttribute('points', pts.map(p => p.join(',')).join(' '));
    }

    // 画对称轴
    function drawAxis() {
      axisLine.setAttribute('x1', axis.x1);
      axisLine.setAttribute('y1', axis.y1);
      axisLine.setAttribute('x2', axis.x2);
      axisLine.setAttribute('y2', axis.y2);
      axisTouchArea.setAttribute('x1', axis.x1);
      axisTouchArea.setAttribute('y1', axis.y1);
      axisTouchArea.setAttribute('x2', axis.x2);
      axisTouchArea.setAttribute('y2', axis.y2);
    }

    drawParallelogram();
    drawAxis();

    // 拖动和旋转
    let draggingAxis = false, draggingEnd = null, dragStart = {}, axisStart = {};
    let touchId = null;

    // 获取SVG坐标
    function getSVGPoint(clientX, clientY) {
      const pt = svg.createSVGPoint();
      pt.x = clientX;
      pt.y = clientY;
      const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
      return [svgP.x, svgP.y];
    }

    // 判断点是否在端点附近
    function isNear(clientX, clientY, px, py, r = 20) {
      const [x, y] = getSVGPoint(clientX, clientY);
      return Math.hypot(x - px, y - py) < r;
    }

    // 添加自动吸附功能
    function snapAxis(x1, y1, x2, y2) {
      const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
      const snapThreshold = 5; // 吸附阈值（度）
      
      // 水平和垂直吸附
      if (Math.abs(angle) < snapThreshold || Math.abs(angle - 180) < snapThreshold || Math.abs(angle + 180) < snapThreshold) {
        return { x1, y1, x2, y2: y1 }; // 水平
      }
      if (Math.abs(angle - 90) < snapThreshold || Math.abs(angle + 90) < snapThreshold) {
        return { x1, y1, x2: x1, y2 }; // 垂直
      }

      // 获取图形的所有顶点
      const pts = para.points || getPoints();
      
      // 检查是否接近任意两点连线
      for (let i = 0; i < pts.length; i++) {
        for (let j = i + 1; j < pts.length; j++) {
          const p1 = pts[i];
          const p2 = pts[j];
          // 计算当前轴的中点
          const axisMidX = (x1 + x2) / 2;
          const axisMidY = (y1 + y2) / 2;
          // 计算两点连线的角度
          const vertexAngle = Math.atan2(p2[1] - p1[1], p2[1] - p1[0]) * 180 / Math.PI;
          // 计算当前轴与两点连线的角度差
          const angleDiff = Math.abs(angle - vertexAngle) % 180;
          
          if (angleDiff < snapThreshold || Math.abs(angleDiff - 180) < snapThreshold) {
            // 计算轴的长度
            const axisLength = Math.hypot(x2 - x1, y2 - y1);
            // 计算新的轴的端点
            const newAngle = vertexAngle * Math.PI / 180;
            return {
              x1: axisMidX - axisLength/2 * Math.cos(newAngle),
              y1: axisMidY - axisLength/2 * Math.sin(newAngle),
              x2: axisMidX + axisLength/2 * Math.cos(newAngle),
              y2: axisMidY + axisLength/2 * Math.sin(newAngle)
            };
          }
        }
      }
      
      return { x1, y1, x2, y2 };
    }

    // 添加角度吸附函数
    function snapAngle(angle) {
      // 转换为度数
      const degrees = angle * 180 / Math.PI;
      // 检查是否接近 0°, 90°, 180°, 270°
      const snapAngles = [0, 90, 180, 270];
      const threshold = 5; // 吸附阈值（度）
      
      for (let snapAngle of snapAngles) {
        const diff = Math.abs(((degrees % 360) + 360) % 360 - snapAngle);
        if (diff < threshold || diff > 360 - threshold) {
          return snapAngle * Math.PI / 180;
        }
      }
      return angle;
    }

    // 线段拖动（支持鼠标和触摸）
    function onAxisDown(e) {
      e.preventDefault();
      let clientX, clientY;
      if (e.type.startsWith('touch')) {
        const touch = e.changedTouches[0];
        touchId = touch.identifier;
        clientX = touch.clientX;
        clientY = touch.clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      // 判断是否在端点附近
      if (isNear(clientX, clientY, axis.x1, axis.y1)) {
        draggingEnd = 'start';
      } else if (isNear(clientX, clientY, axis.x2, axis.y2)) {
        draggingEnd = 'end';
      } else {
        draggingAxis = true;
      }

      const [x, y] = getSVGPoint(clientX, clientY);
      dragStart = { x, y };
      axisStart = { ...axis };
      document.body.style.cursor = draggingAxis ? 'grabbing' : 'crosshair';
    }

    function onAxisMove(e) {
      if (!draggingAxis && !draggingEnd) return;
      let clientX, clientY;
      if (e.type.startsWith('touch')) {
        const touch = Array.from(e.changedTouches).find(t => t.identifier === touchId);
        if (!touch) return;
        clientX = touch.clientX;
        clientY = touch.clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      const [x, y] = getSVGPoint(clientX, clientY);
      
      if (draggingAxis) {
        // 整体平移
        const dx = x - dragStart.x;
        const dy = y - dragStart.y;
        axis.x1 = axisStart.x1 + dx;
        axis.y1 = axisStart.y1 + dy;
        axis.x2 = axisStart.x2 + dx;
        axis.y2 = axisStart.y2 + dy;
      } else if (draggingEnd) {
        // 端点拖动（旋转）
        const mx = (axisStart.x1 + axisStart.x2) / 2;
        const my = (axisStart.y1 + axisStart.y2) / 2;
        const len = Math.hypot(x - mx, y - my);
        let angle = Math.atan2(y - my, x - mx);
        
        // 只保留角度吸附
        angle = snapAngle(angle);

        if (draggingEnd === 'start') {
          axis.x1 = mx + len * Math.cos(angle);
          axis.y1 = my + len * Math.sin(angle);
          axis.x2 = mx + len * Math.cos(angle + Math.PI);
          axis.y2 = my + len * Math.sin(angle + Math.PI);
        } else {
          axis.x2 = mx + len * Math.cos(angle);
          axis.y2 = my + len * Math.sin(angle);
          axis.x1 = mx + len * Math.cos(angle + Math.PI);
          axis.y1 = my + len * Math.sin(angle + Math.PI);
        }
      }
      drawAxis();
    }

    function onAxisUp(e) {
      draggingAxis = false;
      draggingEnd = null;
      document.body.style.cursor = '';
    }

    // 事件监听
    axisTouchArea.addEventListener('mousedown', onAxisDown);
    axisTouchArea.addEventListener('touchstart', onAxisDown, {passive: false});
    window.addEventListener('mousemove', onAxisMove);
    window.addEventListener('touchmove', onAxisMove, {passive: false});
    window.addEventListener('mouseup', onAxisUp);
    window.addEventListener('touchend', onAxisUp);

    // 计算线段交点
    function lineIntersection(p1, p2, q1, q2) {
      const a1 = p2[1] - p1[1];
      const b1 = p1[0] - p2[0];
      const c1 = a1 * p1[0] + b1 * p1[1];
      const a2 = q2[1] - q1[1];
      const b2 = q1[0] - q2[0];
      const c2 = a2 * q1[0] + b2 * q1[1];
      const det = a1 * b2 - a2 * b1;
      if (Math.abs(det) < 1e-10) return null; // 平行
      const x = (b2 * c1 - b1 * c2) / det;
      const y = (a1 * c2 - a2 * c1) / det;
      // 检查是否在线段上
      function onSegment(p, q, r) {
        return (
          Math.min(p[0], r[0]) - 1e-6 <= q[0] && q[0] <= Math.max(p[0], r[0]) + 1e-6 &&
          Math.min(p[1], r[1]) - 1e-6 <= q[1] && q[1] <= Math.max(p[1], r[1]) + 1e-6
        );
      }
      if (onSegment(p1, [x, y], p2) && onSegment(q1, [x, y], q2)) {
        return [x, y];
      }
      return null;
    }

    // 点关于直线的对称点
    function reflectPoint(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1, dy = y2 - y1;
      const a = dy, b = -dx, c = dx*y1 - dy*x1;
      const d = (a*px + b*py + c) / (a*a + b*b);
      return [px - 2*a*d, py - 2*b*d];
    }

    document.getElementById('foldBtn').onclick = () => {
      const pts = para.points || getPoints();
      const { x1, y1, x2, y2 } = axis;
      const axisA = [x1, y1], axisB = [x2, y2];

      // 1. 找到所有交点
      let intersections = [];
      let interIdx = [];
      for (let i = 0; i < pts.length; i++) {
        const j = (i + 1) % pts.length;
        const inter = lineIntersection(pts[i], pts[j], axisA, axisB);
        if (inter) {
          intersections.push(inter);
          interIdx.push(i);
        }
      }
      if (intersections.length !== 2) {
        // 轴未穿过图形两条边，无法对折
        halfPoly.style.display = 'none';
        foldPoly.style.display = 'none';
        return;
      }

      // 2. 按顺序分割图形为两部分
      // 以第一个交点为起点，顺时针收集点，直到第二个交点
      let halfPoints = [intersections[0]];
      let idx = (interIdx[0] + 1) % pts.length;
      while (idx !== (interIdx[1] + 1) % pts.length) {
        halfPoints.push(pts[idx]);
        idx = (idx + 1) % pts.length;
      }
      halfPoints.push(intersections[1]);

      // 3. 生成折过去的点
      const foldPoints = halfPoints.map(p => reflectPoint(p[0], p[1], x1, y1, x2, y2));

      // 4. 显示半透明原一半
      halfPoly.style.display = '';
      halfPoly.setAttribute('points', halfPoints.map(p => p.join(',')).join(' '));

      // 5. 动画：foldPoly 从原位平滑变到镜像位
      foldPoly.style.display = '';
      foldPoly.setAttribute('points', halfPoints.map(p => p.join(',')).join(' '));

      let t = 0;
      function animate() {
        t += 0.04;
        if (t > 1) t = 1;
        const curr = halfPoints.map((p, i) => [
          p[0] + (foldPoints[i][0] - p[0]) * t,
          p[1] + (foldPoints[i][1] - p[1]) * t
        ]);
        foldPoly.setAttribute('points', curr.map(p => p.join(',')).join(' '));
        if (t < 1) {
          requestAnimationFrame(animate);
        }
      }
      animate();
    };

    // 添加控制按钮功能
    function setAxisPosition() {
      const svg = document.getElementById('svg');
      const box = svg.getBoundingClientRect();
      const w = box.width;
      const h = box.height;
      
      // 计算平行四边形的实际边界
      const paraLeft = w * 0.2;
      const paraRight = paraLeft + w * 0.5 + w * 0.1;
      const paraTop = h * 0.3;
      const paraBottom = paraTop + h * 0.4;
      const paraCenterX = (paraLeft + paraRight) / 2;
      const paraCenterY = (paraTop + paraBottom) / 2;
      
      // 固定长度为平行四边形宽度的1.3倍
      const axisLength = (paraRight - paraLeft) * 1.3;
      const halfLen = axisLength / 2;
      
      // 重置到水平位置
      axis = { 
        x1: paraCenterX - halfLen * 0.8, 
        y1: paraCenterY, 
        x2: paraCenterX + halfLen * 0.8, 
        y2: paraCenterY 
      };
      
      drawAxis();
      // 隐藏折叠效果
      halfPoly.style.display = 'none';
      foldPoly.style.display = 'none';
    }

    document.getElementById('resetBtn').onclick = setAxisPosition;

    // 自适应窗口大小
    function updateParallelogram() {
      const svg = document.getElementById('svg');
      const box = svg.getBoundingClientRect();
      
      if (currentShape === 'parallelogram') {
        drawShape();
      } else if (shapes[currentShape]) {
        para.points = shapes[currentShape].getPoints(box.width, box.height);
        drawShape();
      }
      
      setAxisPosition();
    }

    // 监听窗口大小变化
    const resizeObserver = new ResizeObserver(entries => {
      for (let entry of entries) {
        if (entry.target === document.querySelector('.svg-wrap')) {
          updateParallelogram();
        }
      }
    });

    resizeObserver.observe(document.querySelector('.svg-wrap'));
    
    // 初始化
    updateParallelogram();
  </script>
</body>
</html>
