<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>轴对称演示</title>
  <style>
    body { 
      font-family: "微软雅黑", Arial, sans-serif; 
      background: #f6faff; 
      margin: 0;
      padding: 10px;
      min-height: 100vh;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }
    h2 { 
      text-align: center; 
      margin: 0 0 15px 0;
      color: #1976d2;
      font-size: clamp(18px, 5vw, 24px);
      font-weight: normal;
    }
    .container { 
      flex: 1;
      display: flex;
      gap: 20px;
      padding: 0 10px;
    }
    .parallelogram-box { 
      flex: 1;
      min-width: 0;
    }
    .right-column {
      width: 200px;
      display: flex;
      flex-direction: column;
      margin-top: 1rem;
    }
    .svg-wrap {
      background: #fff; 
      border-radius: 10px; 
      box-shadow: 0 2px 8px #0001;
      width: 100%;
      height: 100%;
    }
    svg {
      width: 100%;
      height: 100%;
    }
    .buttons {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    .show-btn-wrap {
      display: flex;
      justify-content: center;
      margin-bottom: 15px;
    }
    button {
      width: 100%;
      height: 60px;
      padding: 0;
      font-size: 24px;
      border-radius: 10px;
      border: none;
      background: #1976d2;
      color: #fff;
      cursor: pointer;
      transition: all 0.2s;
      -webkit-tap-highlight-color: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    button:hover {
      background: #1565c0;
      transform: translateY(-2px);
    }
    button:active {
      transform: translateY(0);
    }
    #resetBtn {
      background: #2196f3;
    }
    #resetBtn:hover {
      background: #1e88e5;
    }
    #showBtn {
      background: #2196f3;
    }
    #showBtn:hover {
      background: #1e88e5;
    }
    #foldBtn {
      background: #f57c00;
      grid-column: 1 / -1;
    }
    #foldBtn:hover {
      background: #ef6c00;
    }
    .tuxing {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      justify-content: center;
    }
    .shape {
      width: 100%;
      aspect-ratio: 1;
      min-width: 60px;
      max-width: 120px;
      margin: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      cursor: pointer;
      transition: transform 0.2s;
      -webkit-tap-highlight-color: transparent;
    }
    .shape:hover {
      transform: scale(1.1);
    }
    .shape:active {
      transform: scale(0.95);
    }
    .shape svg {
      width: 100%;
      height: 100%;
    }
    .shape-name {
      position: absolute;
      bottom: -5px;
      font-size: clamp(12px, 3vw, 14px);
      color: #333;
      width: 100%;
      text-align: center;
      font-weight: normal;
    }
    @media screen and (max-width: 768px) {
      .container {
        flex-direction: column;
      }
      .right-column {
        width: 100%;
      }
      .tuxing {
        grid-template-columns: repeat(4, 1fr);
      }
      h2{display: none;}
      button{height:45px;font-size:20px;}
      .parallelogram-box{flex:unset}
      #showBtn {
        width: 110px;
      }
    }
    /* 修改对称轴样式 */
    .symmetry-axis {
      stroke: #ff9800;
      stroke-width: 3;
      stroke-dasharray: 8,8;
      pointer-events: none;
      opacity: 0.8;
    }
    @media screen and (max-width: 768px) {
      .symmetry-axis {
        stroke-width: 2;
        stroke-dasharray: 6,6;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="parallelogram-box">
      <div class="svg-wrap">
        <svg id="svg" style="touch-action:none;">
          <polygon id="poly" fill="#add8e6" stroke="#1976d2" stroke-width="3" style="opacity:0.8"/>
          <polygon id="halfPoly" fill="#fdfdfd" stroke="#1976d2" stroke-width="3" style="opacity:0.8;display:none"/>
          <polygon id="foldPoly" fill="#add8e6" stroke="#1976d2" stroke-width="3" style="opacity:0.8;display:none"/>
          <line id="axisTouchArea" stroke="transparent" stroke-width="10" stroke-linecap="round" style="cursor:grab"/>
          <line id="axis" stroke="#f57c00" stroke-width="4" stroke-linecap="round" stroke-dasharray="15,10" style="pointer-events:none"/>
          <g id="symmetryAxes"></g>
        </svg>
      </div>
    </div>

    <div class="right-column">
      <h2>轴对称演示</h2>
      <div class="buttons">
        <button id="showBtn">显示</button>
        <button id="resetBtn">重置</button>
        <button id="foldBtn">折叠</button>
      </div>
      <div class="tuxing">
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <rect x="20" y="30" width="60" height="40" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">长方形</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <rect x="25" y="25" width="50" height="50" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">正方形</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <polygon points="35,35 65,35 70,65 20,65" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">梯形</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <polygon points="20,65 80,65 65,35 35,35" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">等腰梯形</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <polygon points="30,25 80,65 20,75" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">三角形</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <polygon points="50,25 90,75 10,75" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">等腰三角形</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <polygon points="20,35 70,35 80,65 30,65" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">平行四边形</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <polygon points="50,25 59.405202,43.438122 79.405202,43.438122 63.258598,55.123757 71.405202,73.561878 50,63.676243 28.594798,73.561878 36.741402,55.123757 20.594798,43.438122 40.594798,43.438122" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">五角星</div>
        </div>
        <div class="shape">
          <svg viewBox="0 0 100 100">
            <polygon points="35,25 65,25 80,50 65,75 35,75 20,50" fill="#add8e6" stroke="#1976d2" stroke-width="2" style="opacity:0.8"/>
          </svg>
          <div class="shape-name">正六边形</div>
        </div>
      </div>
    </div>
  </div>
  <script>
    // 平行四边形参数（大且居中）
    const para = { x: 150, y: 150, w: 500, h: 300, skew: 100 };
    // 对称轴参数（初始为画布中线，长度比平行四边形宽）
    let axis = { x1: 50, y1: 300, x2: 750, y2: 300 };

    const svg = document.getElementById('svg');
    const poly = document.getElementById('poly');
    const halfPoly = document.getElementById('halfPoly');
    const foldPoly = document.getElementById('foldPoly');
    const axisLine = document.getElementById('axis');
    const axisTouchArea = document.getElementById('axisTouchArea');

    // 图形数据定义
    const shapes = {
      rect: {
        name: '长方形',
        getPoints: (w, h) => {
          const width = w * 0.5;
          const height = h * 0.4;
          const cx = w / 2;
          const cy = h / 2;
          return [
            [cx - width/2, cy - height/2],
            [cx + width/2, cy - height/2],
            [cx + width/2, cy + height/2],
            [cx - width/2, cy + height/2]
          ];
        }
      },
      square: {
        name: '正方形',
        getPoints: (w, h) => {
          const size = Math.min(w, h) * 0.4;
          const cx = w / 2;
          const cy = h / 2;
          return [
            [cx - size/2, cy - size/2],
            [cx + size/2, cy - size/2],
            [cx + size/2, cy + size/2],
            [cx - size/2, cy + size/2]
          ];
        }
      },
      trapezoid: {
        name: '梯形',
        getPoints: (w, h) => {
          const cx = w / 2;  // 中心点x坐标
          const cy = h / 2;  // 中心点y坐标
          const topWidth = w * 0.25;    // 上底宽度
          const bottomWidth = w * 0.5;  // 下底宽度
          const height = h * 0.3;      // 高度
          return [
            [cx - topWidth/2 + w * 0.1, cy - height/2],    // 左上（向右偏移）
            [cx + topWidth/2 + w * 0.1, cy - height/2],    // 右上（向右偏移）
            [cx + bottomWidth/2, cy + height/2],  // 右下
            [cx - bottomWidth/2, cy + height/2]   // 左下
          ];
        }
      },
      isoTrapezoid: {
        name: '等腰梯形',
        getPoints: (w, h) => {
          const cx = w / 2;
          const cy = h / 2;
          const topWidth = w * 0.3;
          const bottomWidth = w * 0.6;  // 增加底边长度
          const height = h * 0.3;
          const indent = (bottomWidth - topWidth) / 2;
          return [
            [cx - topWidth/2, cy - height/2],
            [cx + topWidth/2, cy - height/2],
            [cx + bottomWidth/2, cy + height/2],
            [cx - bottomWidth/2, cy + height/2]
          ];
        }
      },
      triangle: {
        name: '三角形',
        getPoints: (w, h) => {
          const cx = w / 2;
          const cy = h / 2;
          const scale = Math.min(w, h) * 1; // 放大系数
          // 使用与按钮上完全相同的坐标比例
          const basePoints = [
            [30,25], [80,65], [20,75]
          ];
          // 等比例转换坐标
          return basePoints.map(([x, y]) => [
            cx + (x - 50) * scale / 100,
            cy + (y - 50) * scale / 100
          ]);
        }
      },
      isoTriangle: {
        name: '等腰三角形',
        getPoints: (w, h) => {
          const cx = w / 2;
          const cy = h / 2;
          const width = w * 0.6;  // 增加底边长度到接近整个宽度
          const height = h * 0.3;
          return [
            [cx, cy - height/2],
            [cx + width/2, cy + height/2],
            [cx - width/2, cy + height/2]
          ];
        }
      },
      parallelogram: {
        name: '平行四边形',
        getPoints: (w, h) => {
          const x = w * 0.2;
          const y = h * 0.3;
          const width = w * 0.5;
          const height = h * 0.4;
          const skew = w * 0.1;
          return [
            [x, y],
            [x + width, y],
            [x + width + skew, y + height],
            [x + skew, y + height]
          ];
        }
      },
      star: {
        name: '五角星',
        getPoints: (w, h) => {
          const cx = w / 2;
          const cy = h / 2;
          const scale = Math.min(w, h) * 0.4; // 调整大小
          const points = [];
          
          // 生成标准的正五角星
          const outerRadius = scale;
          const innerRadius = outerRadius * 0.382; // 黄金分割比
          const startAngle = -Math.PI / 2; // 从正上方开始
          
          for (let i = 0; i < 10; i++) {
            // 交替使用外圈和内圈半径
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = startAngle + (i * Math.PI) / 5;
            points.push([
              cx + radius * Math.cos(angle),
              cy + radius * Math.sin(angle)
            ]);
          }
          
          return points;
        }
      },
      hexagon: {
        name: '正六边形',
        getPoints: (w, h) => {
          const cx = w / 2;
          const cy = h / 2;
          const scale = Math.min(w, h) * 0.8; // 放大系数
          // 使用与按钮上完全相同的坐标比例
          const basePoints = [
            [35,25], [65,25], [80,50], [65,75], [35,75], [20,50]
          ];
          // 等比例转换坐标
          return basePoints.map(([x, y]) => [
            cx + (x - 50) * scale / 100,
            cy + (y - 50) * scale / 100
          ]);
        }
      }
    };

    let currentShape = 'parallelogram';
    
    // 更新图形
    function updateShape(shapeName) {
      currentShape = shapeName;
      const svg = document.getElementById('svg');
      const box = svg.getBoundingClientRect();
      const w = box.width;
      const h = box.height;
      
      if (shapes[shapeName]) {
        para.points = shapes[shapeName].getPoints(w, h);
      }
      
      drawShape();
      setAxisPosition();
      
      // 重置显示状态
      if (showingAxes) {
        showingAxes = false;
        hideSymmetryAxes();
        document.getElementById('showBtn').textContent = '显示';
        document.getElementById('axis').style.display = '';
        document.getElementById('axisTouchArea').style.display = '';
      }
    }

    // 修改绘制函数
    function drawShape() {
      const points = para.points || getPoints();
      poly.setAttribute('points', points.map(p => p.join(',')).join(' '));
    }

    // 为每个图形添加点击事件
    document.querySelectorAll('.shape').forEach((shape, index) => {
      shape.onclick = () => {
        const shapeNames = Object.keys(shapes);
        if (index < shapeNames.length) {
          updateShape(shapeNames[index]);
        }
      };
    });

    // 修改原有的 getPoints 函数为平行四边形专用
    function getPoints() {
      const svg = document.getElementById('svg');
      const box = svg.getBoundingClientRect();
      const w = box.width;
      const h = box.height;
      
      const x = w * 0.2;
      const y = h * 0.3;
      const width = w * 0.5;
      const height = h * 0.4;
      const skew = w * 0.1;
      
      return [
        [x, y],
        [x + width, y],
        [x + width + skew, y + height],
        [x + skew, y + height]
      ];
    }

    // 画平行四边形
    function drawParallelogram() {
      const pts = getPoints();
      poly.setAttribute('points', pts.map(p => p.join(',')).join(' '));
    }

    // 画对称轴
    function drawAxis() {
      axisLine.setAttribute('x1', axis.x1);
      axisLine.setAttribute('y1', axis.y1);
      axisLine.setAttribute('x2', axis.x2);
      axisLine.setAttribute('y2', axis.y2);
      axisTouchArea.setAttribute('x1', axis.x1);
      axisTouchArea.setAttribute('y1', axis.y1);
      axisTouchArea.setAttribute('x2', axis.x2);
      axisTouchArea.setAttribute('y2', axis.y2);
    }

    drawParallelogram();
    drawAxis();

    // 拖动和旋转
    let draggingAxis = false, draggingEnd = null, dragStart = {}, axisStart = {};
    let touchId = null;

    // 获取SVG坐标
    function getSVGPoint(clientX, clientY) {
      const pt = svg.createSVGPoint();
      pt.x = clientX;
      pt.y = clientY;
      const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
      return [svgP.x, svgP.y];
    }

    // 判断点是否在端点附近
    function isNear(clientX, clientY, px, py, r = 20) {
      const [x, y] = getSVGPoint(clientX, clientY);
      return Math.hypot(x - px, y - py) < r;
    }

    // 添加自动吸附功能
    function snapAxis(x1, y1, x2, y2) {
      const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
      const snapThreshold = 5; // 吸附阈值（度）
      
      // 水平和垂直吸附
      if (Math.abs(angle) < snapThreshold || Math.abs(angle - 180) < snapThreshold || Math.abs(angle + 180) < snapThreshold) {
        return { x1, y1, x2, y2: y1 }; // 水平
      }
      if (Math.abs(angle - 90) < snapThreshold || Math.abs(angle + 90) < snapThreshold) {
        return { x1, y1, x2: x1, y2 }; // 垂直
      }

      // 获取图形的所有顶点
      const pts = para.points || getPoints();
      
      // 检查是否接近任意两点连线
      for (let i = 0; i < pts.length; i++) {
        for (let j = i + 1; j < pts.length; j++) {
          const p1 = pts[i];
          const p2 = pts[j];
          // 计算当前轴的中点
          const axisMidX = (x1 + x2) / 2;
          const axisMidY = (y1 + y2) / 2;
          // 计算两点连线的角度
          const vertexAngle = Math.atan2(p2[1] - p1[1], p2[1] - p1[0]) * 180 / Math.PI;
          // 计算当前轴与两点连线的角度差
          const angleDiff = Math.abs(angle - vertexAngle) % 180;
          
          if (angleDiff < snapThreshold || Math.abs(angleDiff - 180) < snapThreshold) {
            // 计算轴的长度
            const axisLength = Math.hypot(x2 - x1, y2 - y1);
            // 计算新的轴的端点
            const newAngle = vertexAngle * Math.PI / 180;
            return {
              x1: axisMidX - axisLength/2 * Math.cos(newAngle),
              y1: axisMidY - axisLength/2 * Math.sin(newAngle),
              x2: axisMidX + axisLength/2 * Math.cos(newAngle),
              y2: axisMidY + axisLength/2 * Math.sin(newAngle)
            };
          }
        }
      }
      
      return { x1, y1, x2, y2 };
    }

    // 添加角度吸附函数
    function snapAngle(angle) {
      // 转换为度数
      const degrees = angle * 180 / Math.PI;
      // 检查是否接近 0°, 90°, 180°, 270°
      const snapAngles = [0, 90, 180, 270];
      const threshold = 5; // 吸附阈值（度）
      
      for (let snapAngle of snapAngles) {
        const diff = Math.abs(((degrees % 360) + 360) % 360 - snapAngle);
        if (diff < threshold || diff > 360 - threshold) {
          return snapAngle * Math.PI / 180;
        }
      }
      return angle;
    }

    // 线段拖动（支持鼠标和触摸）
    function onAxisDown(e) {
      e.preventDefault();
      let clientX, clientY;
      if (e.type.startsWith('touch')) {
        const touch = e.changedTouches[0];
        touchId = touch.identifier;
        clientX = touch.clientX;
        clientY = touch.clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      // 判断是否在端点附近
      if (isNear(clientX, clientY, axis.x1, axis.y1)) {
        draggingEnd = 'start';
      } else if (isNear(clientX, clientY, axis.x2, axis.y2)) {
        draggingEnd = 'end';
      } else {
        draggingAxis = true;
      }

      const [x, y] = getSVGPoint(clientX, clientY);
      dragStart = { x, y };
      axisStart = { ...axis };
      document.body.style.cursor = draggingAxis ? 'grabbing' : 'crosshair';
    }

    function onAxisMove(e) {
      if (!draggingAxis && !draggingEnd) return;
      let clientX, clientY;
      if (e.type.startsWith('touch')) {
        const touch = Array.from(e.changedTouches).find(t => t.identifier === touchId);
        if (!touch) return;
        clientX = touch.clientX;
        clientY = touch.clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      const [x, y] = getSVGPoint(clientX, clientY);
      
      if (draggingAxis) {
        // 整体平移
        const dx = x - dragStart.x;
        const dy = y - dragStart.y;
        axis.x1 = axisStart.x1 + dx;
        axis.y1 = axisStart.y1 + dy;
        axis.x2 = axisStart.x2 + dx;
        axis.y2 = axisStart.y2 + dy;
      } else if (draggingEnd) {
        // 端点拖动（旋转）
        const mx = (axisStart.x1 + axisStart.x2) / 2;
        const my = (axisStart.y1 + axisStart.y2) / 2;
        const len = Math.hypot(x - mx, y - my);
        let angle = Math.atan2(y - my, x - mx);
        
        // 只保留角度吸附
        angle = snapAngle(angle);

        if (draggingEnd === 'start') {
          axis.x1 = mx + len * Math.cos(angle);
          axis.y1 = my + len * Math.sin(angle);
          axis.x2 = mx + len * Math.cos(angle + Math.PI);
          axis.y2 = my + len * Math.sin(angle + Math.PI);
        } else {
          axis.x2 = mx + len * Math.cos(angle);
          axis.y2 = my + len * Math.sin(angle);
          axis.x1 = mx + len * Math.cos(angle + Math.PI);
          axis.y1 = my + len * Math.sin(angle + Math.PI);
        }
      }
      drawAxis();
    }

    function onAxisUp(e) {
      draggingAxis = false;
      draggingEnd = null;
      document.body.style.cursor = '';
    }

    // 事件监听
    axisTouchArea.addEventListener('mousedown', onAxisDown);
    axisTouchArea.addEventListener('touchstart', onAxisDown, {passive: false});
    window.addEventListener('mousemove', onAxisMove);
    window.addEventListener('touchmove', onAxisMove, {passive: false});
    window.addEventListener('mouseup', onAxisUp);
    window.addEventListener('touchend', onAxisUp);

    // 计算线段交点
    function lineIntersection(p1, p2, q1, q2) {
      // 处理垂直线段的特殊情况
      if (Math.abs(q1[0] - q2[0]) < 1e-10) { // 对称轴垂直
        const x = q1[0];
        // 检查是否在另一条线段的 x 范围内
        if (Math.min(p1[0], p2[0]) <= x && x <= Math.max(p1[0], p2[0])) {
          // 计算 y 坐标
          const slope = (p2[1] - p1[1]) / (p2[0] - p1[0]);
          if (Math.abs(p2[0] - p1[0]) < 1e-10) { // 如果两条线段都垂直
            return null;
          }
          const y = p1[1] + slope * (x - p1[0]);
          // 检查 y 是否在两条线段的 y 范围内
          if (Math.min(q1[1], q2[1]) <= y && y <= Math.max(q1[1], q2[1]) &&
              Math.min(p1[1], p2[1]) <= y && y <= Math.max(p1[1], p2[1])) {
            return [x, y];
          }
        }
        return null;
      }
      if (Math.abs(p1[0] - p2[0]) < 1e-10) { // 图形边垂直
        const x = p1[0];
        // 检查是否在对称轴的 x 范围内
        if (Math.min(q1[0], q2[0]) <= x && x <= Math.max(q1[0], q2[0])) {
          // 计算 y 坐标
          const slope = (q2[1] - q1[1]) / (q2[0] - q1[0]);
          const y = q1[1] + slope * (x - q1[0]);
          // 检查 y 是否在两条线段的 y 范围内
          if (Math.min(q1[1], q2[1]) <= y && y <= Math.max(q1[1], q2[1]) &&
              Math.min(p1[1], p2[1]) <= y && y <= Math.max(p1[1], p2[1])) {
            return [x, y];
          }
        }
        return null;
      }

      const a1 = p2[1] - p1[1];
      const b1 = p1[0] - p2[0];
      const c1 = a1 * p1[0] + b1 * p1[1];
      const a2 = q2[1] - q1[1];
      const b2 = q1[0] - q2[0];
      const c2 = a2 * q1[0] + b2 * q1[1];
      const det = a1 * b2 - a2 * b1;
      if (Math.abs(det) < 1e-10) return null; // 平行
      const x = (b2 * c1 - b1 * c2) / det;
      const y = (a1 * c2 - a2 * c1) / det;
      // 检查是否在线段上
      function onSegment(p, q, r) {
        return (
          Math.min(p[0], r[0]) - 1e-6 <= q[0] && q[0] <= Math.max(p[0], r[0]) + 1e-6 &&
          Math.min(p[1], r[1]) - 1e-6 <= q[1] && q[1] <= Math.max(p[1], r[1]) + 1e-6
        );
      }
      if (onSegment(p1, [x, y], p2) && onSegment(q1, [x, y], q2)) {
        return [x, y];
      }
      return null;
    }

    // 点关于直线的对称点
    function reflectPoint(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1, dy = y2 - y1;
      const a = dy, b = -dx, c = dx*y1 - dy*x1;
      const d = (a*px + b*py + c) / (a*a + b*b);
      return [px - 2*a*d, py - 2*b*d];
    }

    document.getElementById('foldBtn').onclick = () => {
      const pts = para.points || getPoints();
      const { x1, y1, x2, y2 } = axis;
      const axisA = [x1, y1], axisB = [x2, y2];

      // 1. 找到所有交点
      let intersections = [];
      let interIdx = [];
      for (let i = 0; i < pts.length; i++) {
        const j = (i + 1) % pts.length;
        const inter = lineIntersection(pts[i], pts[j], axisA, axisB);
        if (inter) {
          intersections.push(inter);
          interIdx.push(i);
        }
      }
      if (intersections.length !== 2) {
        // 轴未穿过图形两条边，无法对折
        halfPoly.style.display = 'none';
        foldPoly.style.display = 'none';
        return;
      }

      // 2. 按顺序分割图形为两部分
      // 以第一个交点为起点，顺时针收集点，直到第二个交点
      let halfPoints = [intersections[0]];
      let idx = (interIdx[0] + 1) % pts.length;
      while (idx !== (interIdx[1] + 1) % pts.length) {
        halfPoints.push(pts[idx]);
        idx = (idx + 1) % pts.length;
      }
      halfPoints.push(intersections[1]);

      // 3. 生成折过去的点
      const foldPoints = halfPoints.map(p => reflectPoint(p[0], p[1], x1, y1, x2, y2));

      // 4. 显示半透明原一半
      halfPoly.style.display = '';
      halfPoly.setAttribute('points', halfPoints.map(p => p.join(',')).join(' '));

      // 5. 动画：foldPoly 从原位平滑变到镜像位
      foldPoly.style.display = '';
      foldPoly.setAttribute('points', halfPoints.map(p => p.join(',')).join(' '));

      let t = 0;
      function animate() {
        t += 0.04;
        if (t > 1) t = 1;
        const curr = halfPoints.map((p, i) => [
          p[0] + (foldPoints[i][0] - p[0]) * t,
          p[1] + (foldPoints[i][1] - p[1]) * t
        ]);
        foldPoly.setAttribute('points', curr.map(p => p.join(',')).join(' '));
        if (t < 1) {
          requestAnimationFrame(animate);
        }
      }
      animate();
    };

    // 添加控制按钮功能
    function setAxisPosition() {
      const svg = document.getElementById('svg');
      const box = svg.getBoundingClientRect();
      const w = box.width;
      const h = box.height;
      
      // 计算平行四边形的实际边界
      const paraLeft = w * 0.2;
      const paraRight = paraLeft + w * 0.5 + w * 0.1;
      const paraTop = h * 0.3;
      const paraBottom = paraTop + h * 0.4;
      const paraCenterX = (paraLeft + paraRight) / 2;
      const paraCenterY = (paraTop + paraBottom) / 2;
      
      // 固定长度为平行四边形宽度的1.3倍
      const axisLength = (paraRight - paraLeft) * 1.3;
      const halfLen = axisLength / 2;
      
      // 重置到水平位置
      axis = { 
        x1: paraCenterX - halfLen * 0.8, 
        y1: paraCenterY, 
        x2: paraCenterX + halfLen * 0.8, 
        y2: paraCenterY 
      };
      
      drawAxis();
      // 隐藏折叠效果
      halfPoly.style.display = 'none';
      foldPoly.style.display = 'none';
    }

    document.getElementById('resetBtn').onclick = () => {
      // 重置对称轴位置
      setAxisPosition();
      
      // 清除折叠效果
      halfPoly.style.display = 'none';
      foldPoly.style.display = 'none';
      
      // 取消任何正在进行的动画
      if (window.foldAnimation) {
        cancelAnimationFrame(window.foldAnimation);
      }

      // 重置显示状态
      if (showingAxes) {
        showingAxes = false;
        hideSymmetryAxes();
        document.getElementById('showBtn').textContent = '显示';
        document.getElementById('axis').style.display = '';
        document.getElementById('axisTouchArea').style.display = '';
      }
    };

    // 自适应窗口大小
    function updateParallelogram() {
      const svg = document.getElementById('svg');
      const box = svg.getBoundingClientRect();
      
      if (currentShape === 'parallelogram') {
        drawShape();
      } else if (shapes[currentShape]) {
        para.points = shapes[currentShape].getPoints(box.width, box.height);
        drawShape();
      }
      
      setAxisPosition();
    }

    // 监听窗口大小变化
    const resizeObserver = new ResizeObserver(entries => {
      for (let entry of entries) {
        if (entry.target === document.querySelector('.svg-wrap')) {
          updateParallelogram();
        }
      }
    });

    resizeObserver.observe(document.querySelector('.svg-wrap'));
    
    // 初始化
    updateParallelogram();

    // 计算两点之间的距离
    function distance(p1, p2) {
      return Math.hypot(p2[0] - p1[0], p2[1] - p1[1]);
    }

    // 计算两点的中点
    function midpoint(p1, p2) {
      return [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
    }

    // 判断两个点是否近似相等
    function pointsEqual(p1, p2, tolerance = 1) {
      return distance(p1, p2) < tolerance;
    }

    // 计算当前图形的所有对称轴
    function findSymmetryAxes() {
      const pts = para.points || getPoints();
      const n = pts.length;
      const axes = [];
      const svg = document.getElementById('svg');
      const box = svg.getBoundingClientRect();
      // 增加轴的长度，使其超出图形
      const scale = Math.max(box.width, box.height) * 1.5;

      // 检查一条线是否是对称轴
      function isSymmetryAxis(x1, y1, x2, y2) {
        if (Math.abs(x2 - x1) < 1e-6 && Math.abs(y2 - y1) < 1e-6) return false;
        
        for (let i = 0; i < pts.length; i++) {
          const p = pts[i];
          const reflected = reflectPoint(p[0], p[1], x1, y1, x2, y2);
          
          let found = false;
          for (let j = 0; j < pts.length; j++) {
            if (pointsEqual(reflected, pts[j], 2)) {
              found = true;
              break;
            }
          }
          if (!found) return false;
        }
        return true;
      }

      // 根据图形类型添加可能的对称轴
      switch (currentShape) {
        case 'square':
          const center = pts.reduce((acc, p) => [acc[0] + p[0], acc[1] + p[1]], [0, 0])
                           .map(v => v / n);
          // 水平和垂直中线
          axes.push({x1: center[0], y1: center[1] - scale, x2: center[0], y2: center[1] + scale});
          axes.push({x1: center[0] - scale, y1: center[1], x2: center[0] + scale, y2: center[1]});
          // 对角线
          const diagonalScale = scale * Math.SQRT2;
          axes.push({
            x1: center[0] - diagonalScale/2, 
            y1: center[1] - diagonalScale/2, 
            x2: center[0] + diagonalScale/2, 
            y2: center[1] + diagonalScale/2
          });
          axes.push({
            x1: center[0] + diagonalScale/2, 
            y1: center[1] - diagonalScale/2, 
            x2: center[0] - diagonalScale/2, 
            y2: center[1] + diagonalScale/2
          });
          break;

        case 'rect':
          const rectCenter = pts.reduce((acc, p) => [acc[0] + p[0], acc[1] + p[1]], [0, 0])
                              .map(v => v / n);
          axes.push({x1: rectCenter[0], y1: rectCenter[1] - scale, x2: rectCenter[0], y2: rectCenter[1] + scale});
          axes.push({x1: rectCenter[0] - scale, y1: rectCenter[1], x2: rectCenter[0] + scale, y2: rectCenter[1]});
          break;

        case 'hexagon':
          const hexCenter = pts.reduce((acc, p) => [acc[0] + p[0], acc[1] + p[1]], [0, 0])
                             .map(v => v / n);
          // 计算正六边形的大小作为缩放基准
          const hexRadius = distance(hexCenter, pts[0]);
          const hexScale = hexRadius * 2; // 使对称轴长度为直径的两倍
          
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI) / 6;
            axes.push({
              x1: hexCenter[0] + Math.cos(angle) * hexScale,
              y1: hexCenter[1] + Math.sin(angle) * hexScale,
              x2: hexCenter[0] + Math.cos(angle + Math.PI) * hexScale,
              y2: hexCenter[1] + Math.sin(angle + Math.PI) * hexScale
            });
          }
          break;

        case 'star':
          // 五角星：5条对称轴
          const starCenter = pts.reduce((acc, p) => [acc[0] + p[0], acc[1] + p[1]], [0, 0])
                              .map(v => v / pts.length);
          // 计算五角星的大小作为缩放基准
          const starRadius = Math.max(...pts.map(p => distance(starCenter, p)));
          const starScale = starRadius * 2.5; // 增加对称轴长度
          
          // 调整角度计算，使对称轴从顶点到对边中点
          // 五角星的第一个顶点朝上，每个顶点之间相差 72 度（2π/5）
          // 第一条对称轴垂直向下，之后每次旋转 36 度（π/5）
          for (let i = 0; i < 5; i++) {
            // 从垂直向下开始，每次旋转 36 度
            const angle = Math.PI / 2 + (i * Math.PI) / 5;
            axes.push({
              x1: starCenter[0] + Math.cos(angle) * starScale,
              y1: starCenter[1] + Math.sin(angle) * starScale,
              x2: starCenter[0] + Math.cos(angle + Math.PI) * starScale,
              y2: starCenter[1] + Math.sin(angle + Math.PI) * starScale
            });
          }
          break;

        case 'isoTriangle':
          // 等腰三角形：顶点到底边中点
          const base = midpoint(pts[1], pts[2]);
          const dx = base[0] - pts[0][0];
          const dy = base[1] - pts[0][1];
          const len = Math.hypot(dx, dy);
          if (len > 0) {
            const ux = dx / len;
            const uy = dy / len;
            axes.push({
              x1: pts[0][0] - ux * scale,
              y1: pts[0][1] - uy * scale,
              x2: pts[0][0] + ux * scale,
              y2: pts[0][1] + uy * scale
            });
          }
          break;

        case 'isoTrapezoid':
          // 等腰梯形：上下底中点连线
          const topMid = midpoint(pts[2], pts[3]); // 上底中点
          const bottomMid = midpoint(pts[0], pts[1]); // 下底中点
          const tdx = topMid[0] - bottomMid[0];
          const tdy = topMid[1] - bottomMid[1];
          const tlen = Math.hypot(tdx, tdy);
          if (tlen > 0) {
            const tux = tdx / tlen;
            const tuy = tdy / tlen;
            axes.push({
              x1: bottomMid[0] - tux * scale,
              y1: bottomMid[1] - tuy * scale,
              x2: bottomMid[0] + tux * scale,
              y2: bottomMid[1] + tuy * scale
            });
          }
          break;

        default:
          // 对于其他图形，检查所有可能的对称轴
          for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
              const mid = midpoint(pts[i], pts[j]);
              const dx = pts[j][0] - pts[i][0];
              const dy = pts[j][1] - pts[i][1];
              const len = Math.hypot(dx, dy);
              if (len < 1e-6) continue;

              const ux = -dy / len;
              const uy = dx / len;
              const x1 = mid[0] - ux * scale;
              const y1 = mid[1] - uy * scale;
              const x2 = mid[0] + ux * scale;
              const y2 = mid[1] + uy * scale;

              if (isSymmetryAxis(x1, y1, x2, y2)) {
                axes.push({x1, y1, x2, y2});
              }
            }
          }
      }

      return filterUniqueAxes(axes);
    }

    // 过滤重复的对称轴
    function filterUniqueAxes(axes) {
      const unique = [];
      const tolerance = 5; // 容差值

      outer: for (const axis1 of axes) {
        for (const axis2 of unique) {
          // 检查两条线是否重合
          const d1 = distance([axis1.x1, axis1.y1], [axis2.x1, axis2.y1]);
          const d2 = distance([axis1.x2, axis1.y2], [axis2.x2, axis2.y2]);
          const d3 = distance([axis1.x1, axis1.y1], [axis2.x2, axis2.y2]);
          const d4 = distance([axis1.x2, axis1.y2], [axis2.x1, axis2.y1]);
          
          if ((d1 < tolerance && d2 < tolerance) || (d3 < tolerance && d4 < tolerance)) {
            continue outer;
          }
        }
        unique.push(axis1);
      }
      return unique;
    }

    // 显示所有对称轴
    function showSymmetryAxes() {
      const axes = findSymmetryAxes();
      const axesGroup = document.getElementById('symmetryAxes');
      axesGroup.innerHTML = '';
      
      axes.forEach(axis => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', axis.x1);
        line.setAttribute('y1', axis.y1);
        line.setAttribute('x2', axis.x2);
        line.setAttribute('y2', axis.y2);
        line.setAttribute('class', 'symmetry-axis');
        axesGroup.appendChild(line);
      });
    }

    // 隐藏所有对称轴
    function hideSymmetryAxes() {
      const axesGroup = document.getElementById('symmetryAxes');
      axesGroup.innerHTML = '';
    }

    // 修改显示按钮事件处理
    let showingAxes = false;
    document.getElementById('showBtn').onclick = () => {
      showingAxes = !showingAxes;
      if (showingAxes) {
        showSymmetryAxes();
        document.getElementById('showBtn').textContent = '隐藏';
        // 隐藏可拖动的对称轴
        document.getElementById('axis').style.display = 'none';
        document.getElementById('axisTouchArea').style.display = 'none';
      } else {
        hideSymmetryAxes();
        document.getElementById('showBtn').textContent = '显示';
        // 显示可拖动的对称轴
        document.getElementById('axis').style.display = '';
        document.getElementById('axisTouchArea').style.display = '';
      }
    };
  </script>
</body>
</html>
