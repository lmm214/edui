<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能面积分析</title>
    <style>
        :root {
            --bg-dark: #050510;
            --bg-panel: rgba(10, 15, 30, 0.7);
            --border-color: rgba(64, 224, 208, 0.3);
            /* Turquoise dim */
            --accent-cyan: #00f3ff;
            --accent-orange: #ff9e00;
            --text-primary: #e0e0ff;
            --text-dim: #6070a0;
            --font-tech: 'Courier New', Courier, monospace;
            --font-ui: system-ui, -apple-system, blinkmacsystemfont, 'Segoe UI', roboto, oxygen, ubuntu, cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            --glow-cyan: 0 0 10px rgba(0, 243, 255, 0.5);
            --glow-orange: 0 0 10px rgba(255, 158, 0, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-primary);
            font-family: var(--font-ui);
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Sci-Fi Grid Background */
        .bg-grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                linear-gradient(rgba(0, 243, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            z-index: -1;
            perspective: 1000px;
            transform-style: preserve-3d;
            /* Optional: Add a slight tilt or movement */
        }

        .bg-grid::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, transparent 0%, var(--bg-dark) 90%);
        }

        .app-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 0;
        }

        /* 1. Header Bar (Cyber Panel) */
        .cyber-header {
            position: relative;
            height: 80px;
            flex-shrink: 0;
            background: var(--bg-panel);
            border-bottom: 3px solid var(--accent-cyan);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.1);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 32px;
            z-index: 100;
        }

        /* Header Left: Stats */
        .header-stats {
            display: flex;
            align-items: center;
            gap: 32px;
        }

        .stat-group {
            display: flex;
            align-items: baseline;
            gap: 12px;
        }

        .stat-group .label {
            font-family: var(--font-tech);
            font-size: 1.4rem;
            color: #fff;
            letter-spacing: 1px;
        }

        .stat-group .value {
            font-family: var(--font-tech);
            font-size: 3rem;
            font-weight: 700;
            line-height: 1;
        }

        .divider {
            width: 1px;
            height: 24px;
            background: var(--border-color);
        }

        .highlight-cyan {
            color: var(--accent-cyan);
            text-shadow: var(--glow-cyan);
        }

        .highlight-orange {
            color: var(--accent-orange);
            text-shadow: var(--glow-orange);
        }


        /* Header Right: Actions */
        .header-actions {
            display: flex;
            gap: 16px;
        }

        .cyber-btn-sm {
            position: relative;
            padding: 8px 24px;
            height: 40px;
            background: rgba(0, 243, 255, 0.05);
            border: 1px solid var(--accent-cyan);
            color: var(--accent-cyan);
            font-family: var(--font-tech);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s;
            /* Slanted shape */
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cyber-btn-sm:hover {
            background: var(--accent-cyan);
            color: #000;
            box-shadow: 0 0 15px var(--accent-cyan);
        }

        .cyber-btn-sm:active {
            transform: scale(0.95);
        }

        /* 2. Workspace */
        .workspace {
            flex: 1;
            width: 100%;
            position: relative;
            padding: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .canvas-wrapper {
            position: relative;
            padding: 4px;
            /* Frame thickness */
            background: rgba(0, 0, 0, 0.3);
            width: auto;
            height: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 4. Scan Effect */
        .scan-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            overflow: hidden;
            background: rgba(0, 243, 255, 0.05);
            /* Green tint during scan */
        }

        .scan-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background: var(--accent-cyan);
            box-shadow: 0 0 15px 4px var(--accent-cyan);
            top: 0;
            animation: scanAnimation 1.5s ease-in-out infinite;
            opacity: 1;
        }

        @keyframes scanAnimation {
            0% {
                top: -5%;
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            100% {
                top: 105%;
                opacity: 0;
            }
        }

        .hidden {
            display: none !important;
        }

        .hidden-slide {
            opacity: 0;
            transform: translateY(-20px);
            pointer-events: none;
        }

        #statsBar {
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            color: var(--text-dim);
            font-family: var(--font-tech);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            width: 100%;
        }

        .empty-state h2 {
            font-size: 1.2rem;
            letter-spacing: 2px;
            animation: blinkText 2s infinite;
        }

        @keyframes blinkText {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Load Overlay */
        #loadingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            color: var(--accent-cyan);
            font-family: var(--font-tech);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid transparent;
            border-top: 3px solid var(--accent-cyan);
            border-left: 3px solid var(--accent-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
            box-shadow: 0 0 15px var(--accent-cyan);
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* Responsive Adjustments */
        @media screen and (max-width: 768px) {
            .cyber-header {
                height: auto;
                min-height: 100px;
                flex-direction: column;
                justify-content: center;
                padding: 12px 16px;
                gap: 16px;
            }

            .header-stats {
                gap: 20px;
                width: 100%;
                justify-content: center;
            }

            .stat-group .label {
                font-size: 1.4rem;
            }

            .stat-group .value {
                font-size: 1.8rem;
            }

            .divider {
                height: 20px;
            }

            .header-actions {
                width: 100%;
                gap: 10px;
            }

            .cyber-btn-sm {
                flex: 1;
                font-size: 0.75rem;
                padding: 0 12px;
                white-space: nowrap;
            }

            .workspace {
                padding: 12px;
            }
        }

        @media screen and (max-width: 480px) {
            .header-stats {
                gap: 12px;
            }

            .stat-group {
                gap: 6px;
            }

            .stat-group .value {
                font-size: 1.5rem;
            }

            .cyber-btn-sm {
                padding: 0 8px;
                letter-spacing: 0;
            }
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Top Header Bar -->
        <header class="cyber-header">
            <!-- Left: Stats -->
            <div class="header-stats" id="statsBar">
                <div class="stat-group">
                    <span class="label">整格</span>
                    <span class="value highlight-cyan" id="fullCount">0</span>
                </div>
                <div class="divider"></div>
                <div class="stat-group">
                    <span class="label">半格</span>
                    <span class="value highlight-orange" id="partialCount">0</span>
                </div>
            </div>

            <!-- Right: Actions -->
            <div class="header-actions">
                <button class="cyber-btn-sm" id="btnUpload">
                    <span>更换图片</span>
                </button>
                <button class="cyber-btn-sm" id="btnScan">
                    <span>智能识别</span>
                </button>
                <!-- Removed standalone "Stats" button since stats are now always visible on left -->
            </div>
        </header>

        <!-- Main Workspace -->
        <main class="workspace">
            <div class="canvas-wrapper cyber-border">
                <canvas id="analysisCanvas"></canvas>

                <!-- Scanning Effect Overlay -->
                <div id="scanOverlay" class="scan-overlay hidden">
                    <div class="scan-line"></div>
                </div>

                <div id="loadingOverlay" class="hidden">
                    <div class="spinner"></div>
                    <p>系统分析中...</p>
                </div>

                <div id="emptyState" class="empty-state">
                    <div class="tech-icon-large"></div>
                    <h2>等待上传图片</h2>
                </div>
            </div>
        </main>

        <!-- Hidden File Input -->
        <input type="file" id="imageUpload" accept="image/*" style="display: none;">
    </div>

    <!-- Background Decoration -->
    <div class="bg-grid"></div>

    <script>
        const canvas = document.getElementById('analysisCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const fileInput = document.getElementById('imageUpload');
        const btnUpload = document.getElementById('btnUpload');
        const btnScan = document.getElementById('btnScan');
        const btnStats = document.getElementById('btnStats');
        const statsBar = document.getElementById('statsBar');
        const fullCountEl = document.getElementById('fullCount');
        const partialCountEl = document.getElementById('partialCount');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const emptyState = document.getElementById('emptyState');
        const scanOverlay = document.getElementById('scanOverlay');

        // 应用状态
        let originalImage = null;
        let imageWidth = 0;
        let imageHeight = 0;
        let isProcessing = false;

        // 网格与结果数据
        let gridW = 0;
        let gridH = 0;
        let offsetX = 0;
        let offsetY = 0;
        let fullSquares = [];
        let partialSquares = [];

        // 动画状态
        let visibleSquares = []; // 当前显示的方格列表 (用于动画)
        let animationId = null;
        let isAnimating = false;

        // 配置参数
        const CONFIG = {
            fullSquareThreshold: 0.99, // 判定为"整格"的阈值：只要非白像素比例超过 99%
            partialSquareThreshold: 0.01, // 判定为"半格"的阈值：只要非白像素比例超过 1%
        };

        // 初始化
        function init() {
            // 1. 按钮事件监听
            btnUpload.addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', handleImageUpload);

            btnScan.addEventListener('click', () => {
                if (!originalImage) return;
                runSmartScan();
            });



            // 2. 拖拽上传
            const dropZone = document.querySelector('.canvas-wrapper');
            dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.style.borderColor = '#3b82f6'; });
            dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.style.borderColor = 'transparent'; });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.style.borderColor = 'transparent';
                if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
            });

            // 3. 自动加载默认图片
            const defaultImage = new Image();
            defaultImage.onload = () => {
                originalImage = defaultImage;
                imageWidth = defaultImage.width;
                imageHeight = defaultImage.height;
                fitImageToCanvas();
                emptyState.classList.add('hidden');

                // 预先静默分析，准备数据
                analyzeImage(true);
                // 初始加载时不播放动画，只显示整洁的图片，等待用户点击"智能识别"
                draw();
            };
            defaultImage.src = "tu1.png";
        }

        // ---------------------------------------------------------
        // 文件处理逻辑
        // ---------------------------------------------------------

        function handleImageUpload(e) {
            if (e.target.files && e.target.files[0]) {
                handleFile(e.target.files[0]);
            }
        }

        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    imageWidth = img.width;
                    imageHeight = img.height;

                    fitImageToCanvas();
                    emptyState.classList.add('hidden');

                    fitImageToCanvas();
                    emptyState.classList.add('hidden');

                    // 新图片加载后，重置状态
                    // 只有在用户点击"智能识别"后才展示分析结果
                    gridW = 0;
                    gridH = 0; // 重置网格数据
                    visibleSquares = [];
                    draw();

                    // 预先执行分析算法
                    setTimeout(() => analyzeImage(true), 100);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function fitImageToCanvas() {
            canvas.width = imageWidth;
            canvas.height = imageHeight;

            // 自动缩放逻辑：计算工作区可用空间
            const workspace = document.querySelector('.workspace');

            // 安全检查
            if (!workspace) return;

            // 获取精确的内边距
            const style = window.getComputedStyle(workspace);
            const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
            const paddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);

            const cw = workspace.clientWidth - paddingX;
            const ch = workspace.clientHeight - paddingY;

            // 计算缩放比例
            // 确保图片完全适应容器内
            const scale = Math.min(cw / imageWidth, ch / imageHeight);

            // 计算显示尺寸
            const displayW = Math.floor(imageWidth * scale);
            const displayH = Math.floor(imageHeight * scale);

            canvas.style.width = `${displayW}px`;
            canvas.style.height = `${displayH}px`;

            // 调整覆盖层尺寸以匹配图片
            scanOverlay.style.width = `${displayW}px`;
            scanOverlay.style.height = `${displayH}px`;
        }


        // ---------------------------------------------------------
        // 智能扫描逻辑 (视觉效果)
        // ---------------------------------------------------------

        function runSmartScan() {
            // 1. 确保已有分析数据
            if (gridW === 0 || gridH === 0) {
                // 如果尚未分析，立即执行
                analyzeImage(false);
                // 强制同步执行分析
                if (gridW === 0 || gridH === 0) {
                    // 如果仍未检测到网格，尝试强制重新检测
                    autoDetectGrid();
                    analyzeGridContent();
                }
            }

            // 2. 启动视觉特效
            // 显示扫描光效
            scanOverlay.classList.remove('hidden');

            // 重置视图
            visibleSquares = [];
            draw(); // 仅绘制底图

            // 扫描期间隐藏统计栏
            statsBar.classList.add('hidden-slide');

            // 3. 准备动画队列
            // 合并所有方格
            const all = [
                ...fullSquares.map(s => ({ ...s, type: 'full' })),
                ...partialSquares.map(s => ({ ...s, type: 'partial' }))
            ];

            // 打乱顺序，营造随机弹出的效果
            shuffleArray(all);

            // 4. 执行动画序列
            // 扫描特效持续约 1.5 秒
            // 随后方格逐个弹出
            setTimeout(() => {
                // 停止扫描光效
                scanOverlay.classList.add('hidden');

                // 开始方格弹出动画
                startPopAnimation(all);

            }, 1500);
        }

        function startPopAnimation(queue) {
            if (isAnimating) cancelAnimationFrame(animationId);
            isAnimating = true;

            let index = 0;
            const total = queue.length;
            // 控制动画总时长约 1-2 秒
            // 计算每帧弹出的方格数量
            const batchSize = Math.max(1, Math.ceil(total / 60));

            function loop() {
                if (index >= total) {
                    isAnimating = false;
                    // 动画结束后显示统计栏
                    updateStatsUI();
                    statsBar.classList.remove('hidden-slide');
                    return;
                }

                // 批量添加方格
                for (let i = 0; i < batchSize && index < total; i++) {
                    visibleSquares.push(queue[index]);
                    index++;
                }

                draw();

                // 实时更新统计数字
                // (数字跳动效果)
                updateLiveStatsFromVisible();

                animationId = requestAnimationFrame(loop);
            }

            loop();
        }

        function updateLiveStatsFromVisible() {
            let f = 0, p = 0;
            for (let s of visibleSquares) {
                if (s.type === 'full') f++;
                else p++;
            }
            fullCountEl.textContent = f;
            partialCountEl.textContent = p;
        }

        function updateStatsUI() {
            fullCountEl.textContent = fullSquares.length;
            partialCountEl.textContent = partialSquares.length;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }


        // ---------------------------------------------------------
        // 核心分析逻辑 (后端算法)
        // ---------------------------------------------------------

        function analyzeImage(silent = false) {
            if (!originalImage) return;
            autoDetectGrid();
            if (gridW > 0 && gridH > 0) {
                analyzeGridContent();
            }
            if (!silent) {
                draw();
            }
        }

        // ... (Keep existing detectGridAutomatically, estimatePeriod, etc.) ...
        // I will paste them below but simplified/cleaned if needed.
        // Actually, I need to include them intact.

        // 自动检测网格 (核心算法)
        function autoDetectGrid() {
            const w = imageWidth;
            const h = imageHeight;
            ctx.drawImage(originalImage, 0, 0);
            const frame = ctx.getImageData(0, 0, w, h);
            const data = frame.data;

            // 1. 投影计算：分别计算水平和垂直方向的像素灰度反转值之和
            // 黑色网格线在白色背景上会产生明显的波峰
            const rowSums = new Float32Array(h).fill(0);
            const colSums = new Float32Array(w).fill(0);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = (y * w + x) * 4;
                    // 计算亮度 (R+G+B)/3 近似值
                    const b = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    const val = 255 - b; // 反转：深色为高数值，白色背景为低数值
                    rowSums[y] += val;
                    colSums[x] += val;
                }
            }

            // 2. 周期估算：利用自相关分析找到网格的重复周期 (即网格大小)
            const estSizeX = estimatePeriod(colSums, w);
            const estSizeY = estimatePeriod(rowSums, h);

            // 独立检测：分别确定宽 (GridW) 和高 (GridH)，支持矩形网格
            gridW = (estSizeX > 10) ? Math.round(estSizeX) : 0;
            gridH = (estSizeY > 10) ? Math.round(estSizeY) : 0;

            // 容错处理：如果只检测到一个维度，尝试应用到另一维度 (假设正方形)
            if (gridW > 0 && gridH === 0) gridH = gridW;
            if (gridH > 0 && gridW === 0) gridW = gridH;

            // 如果网格太小 (小于10像素)，视为检测失败
            if (gridW < 10 || gridH < 10) return;

            // 3. 相位对齐：确定网格的起始偏移量
            offsetX = findPhase(colSums, gridW);
            offsetY = findPhase(rowSums, gridH);
        }

        // 估算周期 (自相关算法)
        // arr: 投影数据数组, len: 数据长度
        function estimatePeriod(arr, len) {
            let bestLag = 0;
            let maxCorr = -1;
            const minP = 15; // 最小搜索周期 (像素)
            // 最大搜索范围设为图片尺寸的 1/3，以支持较大的矩形网格
            const maxP = Math.floor(len / 3);

            for (let lag = minP; lag < maxP; lag++) {
                let sum = 0;
                let count = 0;
                const step = 2; // 步进优化性能
                for (let i = 0; i < len - lag; i += step) {
                    sum += arr[i] * arr[i + lag];
                    count++;
                }
                const avg = sum / count;
                if (avg > maxCorr) {
                    maxCorr = avg;
                    bestLag = lag;
                }
            }

            // Peak finding refinement
            const smoothed = [];
            for (let i = 0; i < len; i++) smoothed[i] = arr[i];
            const peaks = [];
            const threshold = arr.reduce((a, b) => a + b, 0) / len * 1.5;
            for (let i = 1; i < len - 1; i++) {
                if (smoothed[i] > smoothed[i - 1] && smoothed[i] > smoothed[i + 1] && smoothed[i] > threshold) {
                    peaks.push(i);
                }
            }
            if (peaks.length < 2) return bestLag;
            const diffs = [];
            for (let i = 1; i < peaks.length; i++) diffs.push(peaks[i] - peaks[i - 1]);
            const modeMap = {};
            let maxFreq = 0;
            let mode = 0;
            diffs.forEach(d => {
                const k = d; // Use exact diff to allow odd numbers
                modeMap[k] = (modeMap[k] || 0) + 1;
                if (modeMap[k] > maxFreq) { maxFreq = modeMap[k]; mode = k; }
            });
            return mode > 0 ? mode : bestLag;
        }

        // 确定相位偏移 (即网格线的起始位置)
        function findPhase(arr, period) {
            let bestOff = 0;
            let maxSum = -1;
            // 在一个周期内滑动，找到投影和最大的位置 (即网格线最明显的位置)
            for (let off = 0; off < period; off++) {
                let sum = 0;
                for (let k = 0; off + k * period < arr.length; k++) {
                    sum += arr[off + k * period];
                }
                if (sum > maxSum) { maxSum = sum; bestOff = off; }
            }
            return bestOff;
        }

        function analyzeGridContent() {
            fullSquares = [];
            partialSquares = [];
            const w = imageWidth;
            const h = imageHeight;
            const data = ctx.getImageData(0, 0, w, h).data;
            // 内缩边距：分析每个格子时，向内收缩一定比例 (10%)，从而避开边框上的网格线干扰
            const paddingX = Math.max(2, Math.floor(gridW * 0.1));
            const paddingY = Math.max(2, Math.floor(gridH * 0.1));

            for (let y = offsetY - gridH; y < h; y += gridH) {
                for (let x = offsetX - gridW; x < w; x += gridW) {
                    const cellX = Math.round(x);
                    const cellY = Math.round(y);
                    const innerX = cellX + paddingX;
                    const innerY = cellY + paddingY;
                    const innerW = gridW - (paddingX * 2);
                    const innerH = gridH - (paddingY * 2);

                    if (innerW <= 1 || innerH <= 1) continue;

                    let nonWhitePx = 0;
                    let checkedPx = 0;

                    for (let iy = 0; iy < innerH; iy++) {
                        const py = innerY + iy;
                        if (py < 0 || py >= h) continue;
                        for (let ix = 0; ix < innerW; ix++) {
                            const px = innerX + ix;
                            if (px < 0 || px >= w) continue;
                            const idx = (py * w + px) * 4;
                            const r = data[idx];
                            const g = data[idx + 1];
                            const b = data[idx + 2];
                            // 综合颜色分析算法：区分 "淡色内容" 和 "白色背景"
                            const maxCh = Math.max(r, g, b);
                            const minCh = Math.min(r, g, b);
                            const saturation = maxCh - minCh; // 饱和度

                            // 颜色偏差计算：RGB通道之间的差异
                            // 淡橙色/淡色内容通常有 R>B 或 G>B 的倾向，会产生偏差
                            // 纯中性色 (白/灰/黑) 的 RGB 值非常接近，偏差极小
                            const colorBias = Math.max(Math.abs(r - g), Math.abs(g - b), Math.abs(b - r));

                            // 判定为 "内容" (非背景) 的条件：
                            // 1. 饱和度 > 18 (识别鲜艳颜色)
                            // 2. 颜色偏差 > 15 (识别淡色但有色相的区域，如浅橙色)
                            // 同时排除极低饱和度的灰色网格线干扰
                            const isContent = (saturation > 18) || (colorBias > 15);

                            if (isContent) nonWhitePx++;
                            checkedPx++;
                        }
                    }
                    if (checkedPx === 0) continue;
                    const ratio = nonWhitePx / checkedPx;

                    if (ratio > CONFIG.fullSquareThreshold) {
                        fullSquares.push({ x: cellX, y: cellY, w: gridW, h: gridH });
                    } else if (ratio > CONFIG.partialSquareThreshold) {
                        partialSquares.push({ x: cellX, y: cellY, w: gridW, h: gridH });
                    }
                }
            }
            // Note: We don't update UI numbers here immediately if we want animation, 
            // unless initial load.
        }

        function draw() {
            if (!originalImage) return;

            ctx.clearRect(0, 0, imageWidth, imageHeight);
            ctx.drawImage(originalImage, 0, 0);

            // Draw only Visible Squares (controlled by animation or state)
            // If not animating and visibleSquares is empty, show all?
            // No, logic is: visibleSquares is source of truth for display.
            // Init sets visibleSquares?

            // Wait, on initial load if we want to show result static:
            // We should populate visibleSquares = [...full, ...partial].

            if (visibleSquares.length === 0 && (fullSquares.length > 0 || partialSquares.length > 0) && !isAnimating) {
                // 默认状态：扫描前保持图片整洁，不显示结果
            }

            // 绘制网格线
            if (gridW > 0 && gridH > 0) {
                // 设置网格样式 (Cyberpunk 风格)
                ctx.strokeStyle = 'rgba(0,0, 0, 0.3)'; // 半透明黑色

                // 绘制垂直线
                // 动态线宽：设置为网格宽度的 5% (最少2px)，保证在不同网格大小下显示协调
                const lwX = Math.max(1, Math.floor(gridW * 0.05));
                ctx.lineWidth = lwX;
                ctx.beginPath();
                for (let x = (offsetX % gridW) - gridW; x <= imageWidth; x += gridW) {
                    ctx.moveTo(x, 0); ctx.lineTo(x, imageHeight);
                }
                ctx.stroke();

                // 绘制水平线
                const lwY = Math.max(1, Math.floor(gridH * 0.05));
                ctx.lineWidth = lwY;
                ctx.beginPath();
                for (let y = (offsetY % gridH) - gridH; y <= imageHeight; y += gridH) {
                    ctx.moveTo(0, y); ctx.lineTo(imageWidth, y);
                }
                ctx.stroke();
            }

            // Draw Squares
            visibleSquares.forEach(sq => {
                if (sq.type === 'full') {
                    ctx.fillStyle = 'rgba(74, 222, 128, 0.4)'; // Green
                    ctx.fillRect(sq.x, sq.y, sq.w, sq.h);
                } else {
                    ctx.fillStyle = 'rgba(250, 204, 21, 0.4)'; // Yellow
                    ctx.fillRect(sq.x, sq.y, sq.w, sq.h);
                }
            });
        }

        // Resize handler
        window.addEventListener('resize', fitImageToCanvas);

        // Start
        init();
    </script>
</body>

</html>