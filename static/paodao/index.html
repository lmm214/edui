<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>双侧同心圆刻度</title>
  <style>
    html, body { height: 100%; margin: 0; background: #ffffff; }
    /* 全屏 Canvas */
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background-image: linear-gradient(to top, #cfd9df 0%, #e2ebf0 100%);
      touch-action: none; /* 禁用默认触摸滚动/缩放，便于拖动 */
    }
    /* 右上角设置按钮与面板 */
    .settings-btn {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 10;
      padding: 8px 12px;
      border: none;
      border-radius: 8px;
      background: #1677ff;
      color: #fff;
      font: 600 14px system-ui, -apple-system, Segoe UI, Helvetica, Arial, sans-serif;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      cursor: pointer;
    }
    .settings-panel {
      position: fixed;
      top: 56px;
      right: 16px;
      z-index: 10;
      width: 240px;
      padding: 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.85);
      backdrop-filter: saturate(180%) blur(12px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.18);
      color: #333;
      font: 14px system-ui, -apple-system, Segoe UI, Helvetica, Arial, sans-serif;
    }
    .settings-panel .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin: 8px 0;
    }
    .settings-panel label { font-weight: 600; }
    .settings-panel input[type="number"] {
      width: 96px;
      padding: 6px 8px;
      border: 1px solid #d9d9d9;
      border-radius: 8px;
      outline: none;
    }
    /* 去除内部保存/关闭按钮，改为外部按钮切换 */
  </style>
  </head>
<body>
  <canvas id="c"></canvas>
  <button id="settingsBtn" class="settings-btn">设置</button>
  <div id="settingsPanel" class="settings-panel" hidden>
    <div class="row">
      <label for="innerDivInput">内圈份数</label>
      <input id="innerDivInput" type="number" min="2" max="60" step="1" />
    </div>
    <div class="row">
      <label for="outerDivInput">外圈份数</label>
      <input id="outerDivInput" type="number" min="2" max="60" step="1" />
    </div>
  </div>
  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const START_ANGLE = -Math.PI / 2; // 12点方向
    const SNAP_TOL = 0.15; // 吸附角度阈值（弧度，约8.6°）

    // 左侧状态：角度与拖拽指针ID支持同时拖动
    const state = {
      innerAngle: START_ANGLE,
      outerAngle: START_ANGLE,
      draggingInnerId: null,
      draggingOuterId: null,
      innerTickIndex: 0,
      outerTickIndex: 0,
      // 用于方向感知高亮：累计相对12点的步数（可为负）
      innerTotalSteps: 0,
      outerTotalSteps: 0,
      // 右侧独立显示的数字（0-8），与左侧不同步
      rightCount: 0,
      // 右侧交互与高亮状态
      rInnerAngle: START_ANGLE,
      rOuterAngle: START_ANGLE,
      rDraggingInnerId: null,
      rDraggingOuterId: null,
      rInnerTickIndex: 0,
      rOuterTickIndex: 0,
      rInnerTotalSteps: 0,
      rOuterTotalSteps: 0,
    };

    // 分份数配置（持久化）
    const CONFIG_KEY = 'ringDivisions';
    function loadConfig() {
      try {
        const raw = localStorage.getItem(CONFIG_KEY);
        if (raw) {
          const obj = JSON.parse(raw);
          const inner = Math.max(2, Math.min(60, parseInt(obj.innerDiv, 10) || 8));
          const outer = Math.max(2, Math.min(60, parseInt(obj.outerDiv, 10) || 10));
          return { innerDiv: inner, outerDiv: outer };
        }
      } catch (_) {}
      return { innerDiv: 8, outerDiv: 10 };
    }
    function saveConfig(cfg) {
      try { localStorage.setItem(CONFIG_KEY, JSON.stringify(cfg)); } catch (_) {}
    }
    let config = loadConfig();

    function resizeAndDraw() {
      const dpr = window.devicePixelRatio || 1;
      const w = window.innerWidth;
      const h = window.innerHeight;
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      // 重置并按 DPR 缩放，保证清晰
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);
      draw();
    }

    function drawTicks(cx, cy, radius, divisions, tickIn, tickOut, startAngle = START_ANGLE) {
      const step = 2 * Math.PI / divisions;
      ctx.beginPath();
      for (let i = 0; i < divisions; i++) {
        const a = startAngle + i * step;
        const x1 = cx + Math.cos(a) * (radius - tickIn);
        const y1 = cy + Math.sin(a) * (radius - tickIn);
        const x2 = cx + Math.cos(a) * (radius + tickOut);
        const y2 = cy + Math.sin(a) * (radius + tickOut);
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
      }
      ctx.stroke();
    }
    function drawArcSegment(cx, cy, radius, fromAngle, toAngle, color, lineWidth = 4) {
      // 从 fromAngle 到 toAngle 的部分弧线高亮
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      const ccw = toAngle < fromAngle;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, fromAngle, toAngle, ccw);
      ctx.stroke();
    }

    function drawSide(cx, cy, outerDiv, innerDiv, opts = {}) {
      const {
        innerAngle = START_ANGLE,
        outerAngle = START_ANGLE,
        dotOffset = 16,
        dotRadius = 12,
        highlightInner = true,
        highlightOuter = true,
        drawDots = true,
        innerHighlightAngle = innerAngle,
        outerHighlightAngle = outerAngle,
      } = opts;

      const margin = 150; // 边距
      const halfW = canvas.clientWidth / 2;
      const maxRadius = Math.min(halfW, canvas.clientHeight) / 2 - margin;
      const outerR = Math.max(20, maxRadius);
      const gap = Math.max(4, outerR * 0.01); // 两圆“紧贴”的视觉间距
      const innerR = outerR - gap;

      // 基础圆（灰色）
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#333';
      ctx.beginPath();
      ctx.arc(cx, cy, outerR, 0, Math.PI * 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(cx, cy, innerR, 0, Math.PI * 2);
      ctx.stroke();

      // 刻度线：内圆向内刻度（淡蓝），外圆向外刻度（淡红），起始点为顶部
      ctx.lineWidth = 3;
      //ctx.strokeStyle = '#91caff'; // 内圆刻度淡蓝
      drawTicks(cx, cy, innerR, innerDiv, 12, 0, START_ANGLE);
      //ctx.strokeStyle = '#ffa39e'; // 外圆刻度淡红
      drawTicks(cx, cy, outerR, outerDiv, 0, 12, START_ANGLE);

      // 局部弧线高亮：从 12 点方向到当前点位（考虑方向）
      if (highlightInner) {
        drawArcSegment(cx, cy, innerR, START_ANGLE, innerHighlightAngle, '#1677ff', 5);
      }
      if (highlightOuter) {
        drawArcSegment(cx, cy, outerR, START_ANGLE, outerHighlightAngle, '#ff4d4f', 5);
      }

      if (drawDots) {
        // 以角度沿圆边移动的蓝/红点（保持在内侧/外侧偏移）
        const innerX = cx + Math.cos(innerAngle) * (innerR - dotOffset);
        const innerY = cy + Math.sin(innerAngle) * (innerR - dotOffset);
        const outerX = cx + Math.cos(outerAngle) * (outerR + dotOffset);
        const outerY = cy + Math.sin(outerAngle) * (outerR + dotOffset);

        // 蓝点
        ctx.fillStyle = '#1677ff';
        ctx.beginPath();
        ctx.arc(innerX, innerY, dotRadius, 0, Math.PI * 2);
        ctx.fill();

        // 红点
        ctx.fillStyle = '#ff4d4f';
        ctx.beginPath();
        ctx.arc(outerX, outerY, dotRadius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function nearestSnapAngle(angle, divisions) {
      const step = 2 * Math.PI / divisions;
      const k = Math.round((angle - START_ANGLE) / step);
      const snap = START_ANGLE + k * step;
      return Math.abs(angle - snap) <= SNAP_TOL ? snap : angle;
    }

    function angleToTick(angle, divisions) {
      const step = 2 * Math.PI / divisions;
      return Math.round((angle - START_ANGLE) / step);
    }
    function tickToAngle(k, divisions) {
      const step = 2 * Math.PI / divisions;
      return START_ANGLE + k * step;
    }
    function mod(n, m) {
      return ((n % m) + m) % m;
    }

    function getLeftGeometry() {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      const leftCx = w * 0.25;
      const cy = h * 0.5;
      const margin = 150;
      const halfW = w / 2;
      const maxRadius = Math.min(halfW, h) / 2 - margin;
      const outerR = Math.max(20, maxRadius);
      const gap = Math.max(8, outerR * 0.01);
      const innerR = outerR - gap;
      return { leftCx, cy, outerR, innerR };
    }

    function getRightGeometry() {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      const rightCx = w * 0.75;
      const cy = h * 0.5;
      const margin = 150;
      const halfW = w / 2;
      const maxRadius = Math.min(halfW, h) / 2 - margin;
      const outerR = Math.max(20, maxRadius);
      const gap = Math.max(8, outerR * 0.01);
      const innerR = outerR - gap;
      return { rightCx, cy, outerR, innerR };
    }

    function draw() {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0, 0, w, h);
      const leftCx = w * 0.25;
      const rightCx = w * 0.75;
      const cy = h * 0.5;
      const innerStep = 2 * Math.PI / config.innerDiv;
      const outerStep = 2 * Math.PI / config.outerDiv;
      // 左侧：支持拖拽与局部弧线高亮
      drawSide(leftCx, cy, config.outerDiv, config.innerDiv, {
        innerAngle: state.innerAngle,
        outerAngle: state.outerAngle,
        highlightInner: true,
        highlightOuter: true,
        drawDots: true,
        innerHighlightAngle: START_ANGLE + innerStep * state.innerTotalSteps,
        outerHighlightAngle: START_ANGLE + outerStep * state.outerTotalSteps,
      });
      // 右侧：同向联动拖拽与局部弧线高亮
      drawSide(rightCx, cy, config.outerDiv, config.innerDiv, {
        innerAngle: state.rInnerAngle,
        outerAngle: state.rOuterAngle,
        highlightInner: true,
        highlightOuter: true,
        drawDots: true,
        innerHighlightAngle: START_ANGLE + innerStep * state.rInnerTotalSteps,
        outerHighlightAngle: START_ANGLE + outerStep * state.rOuterTotalSteps,
      });

      // 计算用于标签的几何（两侧相同半径）
      const { outerR } = getLeftGeometry();
      // 左侧显示内圆累计的大格数（0-8）
      const leftCount = Math.min(config.innerDiv, Math.abs(state.innerTotalSteps));
      // 右侧为独立数字（0-50），不与左侧同步
      const rightCount = Math.max(0, Math.min(50, state.rightCount));

      // 在两侧圆心绘制数字标签（更大字号）
      drawCenterLabelText(leftCx, cy, leftCount, '#333');
      drawCenterLabelText(rightCx, cy, rightCount, '#333');
    }

    window.addEventListener('resize', resizeAndDraw);
    resizeAndDraw();

    // 统一的指针事件处理函数（鼠标/触控笔/触摸统一使用）
    function onPointerDown(e) {
      const iDiv = config.innerDiv;
      const oDiv = config.outerDiv;
      const { leftCx, cy, outerR, innerR } = getLeftGeometry();
      const { rightCx, outerR: rOuterR, innerR: rInnerR } = getRightGeometry();
      const dotOffset = 16;
      const dotRadius = 12;
      const innerX = leftCx + Math.cos(state.innerAngle) * (innerR - dotOffset);
      const innerY = cy + Math.sin(state.innerAngle) * (innerR - dotOffset);
      const outerX = leftCx + Math.cos(state.outerAngle) * (outerR + dotOffset);
      const outerY = cy + Math.sin(state.outerAngle) * (outerR + dotOffset);
      const rInnerX = rightCx + Math.cos(state.rInnerAngle) * (rInnerR - dotOffset);
      const rInnerY = cy + Math.sin(state.rInnerAngle) * (rInnerR - dotOffset);
      const rOuterX = rightCx + Math.cos(state.rOuterAngle) * (rOuterR + dotOffset);
      const rOuterY = cy + Math.sin(state.rOuterAngle) * (rOuterR + dotOffset);

      const dxIn = e.clientX - innerX;
      const dyIn = e.clientY - innerY;
      const dxOut = e.clientX - outerX;
      const dyOut = e.clientY - outerY;
      const dxRIn = e.clientX - rInnerX;
      const dyRIn = e.clientY - rInnerY;
      const dxROut = e.clientX - rOuterX;
      const dyROut = e.clientY - rOuterY;
      const hitRadius = dotRadius + 8;

      const tryCapture = (pid) => {
        if (canvas.setPointerCapture && typeof pid === 'number') {
          try { canvas.setPointerCapture(pid); } catch (_) {}
        }
      };

      if (dxIn * dxIn + dyIn * dyIn <= hitRadius * hitRadius) {
        state.draggingInnerId = e.pointerId;
        tryCapture(e.pointerId);
        state.innerTickIndex = mod(angleToTick(state.innerAngle, iDiv), iDiv);
        state.outerTickIndex = mod(angleToTick(state.outerAngle, oDiv), oDiv);
      } else if (dxOut * dxOut + dyOut * dyOut <= hitRadius * hitRadius) {
        state.draggingOuterId = e.pointerId;
        tryCapture(e.pointerId);
        state.innerTickIndex = mod(angleToTick(state.innerAngle, iDiv), iDiv);
        state.outerTickIndex = mod(angleToTick(state.outerAngle, oDiv), oDiv);
      } else if (dxRIn * dxRIn + dyRIn * dyRIn <= hitRadius * hitRadius) {
        state.rDraggingInnerId = e.pointerId;
        tryCapture(e.pointerId);
        state.rInnerTickIndex = mod(angleToTick(state.rInnerAngle, iDiv), iDiv);
        state.rOuterTickIndex = mod(angleToTick(state.rOuterAngle, oDiv), oDiv);
      } else if (dxROut * dxROut + dyROut * dyROut <= hitRadius * hitRadius) {
        state.rDraggingOuterId = e.pointerId;
        tryCapture(e.pointerId);
        state.rInnerTickIndex = mod(angleToTick(state.rInnerAngle, iDiv), iDiv);
        state.rOuterTickIndex = mod(angleToTick(state.rOuterAngle, oDiv), oDiv);
      } else {
        // 如果点击在右侧圆区域，则独立调整右侧数字（循环 0→50）
        const dxR = e.clientX - rightCx;
        const dyR = e.clientY - cy;
        if (dxR * dxR + dyR * dyR <= rOuterR * rOuterR) {
          if (e.shiftKey) {
            state.rightCount = (state.rightCount - 1 + 51) % 51; // 0..50
          } else {
            state.rightCount = (state.rightCount + 1) % 51; // 0..50
          }
        }
      }
      draw();
    }

    function onPointerMove(e) {
      const iDiv = config.innerDiv;
      const oDiv = config.outerDiv;
      const { leftCx, cy } = getLeftGeometry();
      const { rightCx } = getRightGeometry();
      if (state.draggingInnerId === e.pointerId) {
        let angle = Math.atan2(e.clientY - cy, e.clientX - leftCx);
        angle = nearestSnapAngle(angle, iDiv);
        const newK = mod(angleToTick(angle, iDiv), iDiv);
        let deltaK = newK - state.innerTickIndex;
        {
          const half = Math.floor(iDiv / 2);
          if (deltaK > half) deltaK -= iDiv;
          if (deltaK < -half) deltaK += iDiv;
        }
        state.innerTickIndex = newK;
        state.innerAngle = tickToAngle(newK, iDiv);
        state.outerTickIndex = mod(state.outerTickIndex - deltaK, oDiv);
        state.outerAngle = tickToAngle(state.outerTickIndex, oDiv);
        state.innerTotalSteps += deltaK;
        state.outerTotalSteps -= deltaK;
        draw();
      }
      if (state.draggingOuterId === e.pointerId) {
        let angle = Math.atan2(e.clientY - cy, e.clientX - leftCx);
        angle = nearestSnapAngle(angle, oDiv);
        const newK = mod(angleToTick(angle, oDiv), oDiv);
        let deltaK = newK - state.outerTickIndex;
        {
          const half = Math.floor(oDiv / 2);
          if (deltaK > half) deltaK -= oDiv;
          if (deltaK < -half) deltaK += oDiv;
        }
        state.outerTickIndex = newK;
        state.outerAngle = tickToAngle(newK, oDiv);
        state.innerTickIndex = mod(state.innerTickIndex - deltaK, iDiv);
        state.innerAngle = tickToAngle(state.innerTickIndex, iDiv);
        state.outerTotalSteps += deltaK;
        state.innerTotalSteps -= deltaK;
        draw();
      }

      // 右侧拖拽：同方向同步一大格（红点或蓝点）
      if (state.rDraggingInnerId === e.pointerId) {
        let angle = Math.atan2(e.clientY - cy, e.clientX - rightCx);
        angle = nearestSnapAngle(angle, iDiv);
        const newK = mod(angleToTick(angle, iDiv), iDiv);
        let deltaK = newK - state.rInnerTickIndex;
        {
          const half = Math.floor(iDiv / 2);
          if (deltaK > half) deltaK -= iDiv;
          if (deltaK < -half) deltaK += iDiv;
        }
        state.rInnerTickIndex = newK;
        state.rInnerAngle = tickToAngle(newK, iDiv);
        state.rOuterTickIndex = mod(state.rOuterTickIndex + deltaK, oDiv);
        state.rOuterAngle = tickToAngle(state.rOuterTickIndex, oDiv);
        state.rInnerTotalSteps += deltaK;
        state.rOuterTotalSteps += deltaK;
        state.rightCount = Math.min(50, state.rightCount + Math.abs(deltaK));
        draw();
      }
      if (state.rDraggingOuterId === e.pointerId) {
        let angle = Math.atan2(e.clientY - cy, e.clientX - rightCx);
        angle = nearestSnapAngle(angle, oDiv);
        const newK = mod(angleToTick(angle, oDiv), oDiv);
        let deltaK = newK - state.rOuterTickIndex;
        {
          const half = Math.floor(oDiv / 2);
          if (deltaK > half) deltaK -= oDiv;
          if (deltaK < -half) deltaK += oDiv;
        }
        state.rOuterTickIndex = newK;
        state.rOuterAngle = tickToAngle(newK, oDiv);
        state.rInnerTickIndex = mod(state.rInnerTickIndex + deltaK, iDiv);
        state.rInnerAngle = tickToAngle(state.rInnerTickIndex, iDiv);
        state.rOuterTotalSteps += deltaK;
        state.rInnerTotalSteps += deltaK;
        state.rightCount = Math.min(50, state.rightCount + Math.abs(deltaK));
        draw();
      }
    }

    // 绑定指针事件（鼠标/触控笔/触摸）
    canvas.addEventListener('pointerdown', onPointerDown);
    canvas.addEventListener('pointermove', onPointerMove);

    function endDrag(e) {
      let changed = false;
      if (state.draggingInnerId === e.pointerId) {
        state.draggingInnerId = null;
        changed = true;
      }
      if (state.draggingOuterId === e.pointerId) {
        state.draggingOuterId = null;
        changed = true;
      }
      if (state.rDraggingInnerId === e.pointerId) {
        state.rDraggingInnerId = null;
        changed = true;
      }
      if (state.rDraggingOuterId === e.pointerId) {
        state.rDraggingOuterId = null;
        changed = true;
      }
      if (changed) draw();
    }

    canvas.addEventListener('pointerup', endDrag);
    canvas.addEventListener('pointercancel', endDrag);
    canvas.addEventListener('pointerleave', endDrag);

    // 触摸事件适配：将 touch 事件映射为“伪指针事件”复用同一逻辑
    function touchToPointerLike(touch, e) {
      return {
        clientX: touch.clientX,
        clientY: touch.clientY,
        pointerId: touch.identifier,
        shiftKey: !!e.shiftKey,
      };
    }
    function onTouchStart(e) {
      e.preventDefault(); // 禁止滚动，优先拖动
      for (const t of Array.from(e.changedTouches)) {
        onPointerDown(touchToPointerLike(t, e));
      }
    }
    function onTouchMove(e) {
      e.preventDefault();
      for (const t of Array.from(e.changedTouches)) {
        onPointerMove(touchToPointerLike(t, e));
      }
    }
    function onTouchEnd(e) {
      for (const t of Array.from(e.changedTouches)) {
        endDrag(touchToPointerLike(t, e));
      }
    }
    canvas.addEventListener('touchstart', onTouchStart, { passive: false });
    canvas.addEventListener('touchmove', onTouchMove, { passive: false });
    canvas.addEventListener('touchend', onTouchEnd);
    canvas.addEventListener('touchcancel', onTouchEnd);

    // 文本标签绘制：在圆正上方居中显示
    function drawLabelText(cx, cy, outerR, text, color = '#333') {
      ctx.save();
      ctx.fillStyle = color;
      ctx.font = '600 28px system-ui, -apple-system, Segoe UI, Helvetica, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(String(text), cx, cy - outerR - 16);
      ctx.restore();
    }

    // 文本标签绘制：在圆心居中显示（更大字号）
    function drawCenterLabelText(cx, cy, text, color = '#333') {
      ctx.save();
      ctx.fillStyle = color;
      ctx.font = '80px system-ui, -apple-system, Segoe UI, Helvetica, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(text), cx, cy);
      ctx.restore();
    }

    // 设置面板交互
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsPanel = document.getElementById('settingsPanel');
    const innerInput = document.getElementById('innerDivInput');
    const outerInput = document.getElementById('outerDivInput');
    function setButtonLabel() {
      settingsBtn.textContent = settingsPanel.hidden ? '设置' : '关闭';
    }
    function openPanel() {
      innerInput.value = config.innerDiv;
      outerInput.value = config.outerDiv;
      settingsPanel.hidden = false;
      setButtonLabel();
    }
    function closePanel() {
      settingsPanel.hidden = true;
      setButtonLabel();
    }
    function togglePanel() {
      if (settingsPanel.hidden) openPanel(); else closePanel();
    }
    settingsBtn.addEventListener('click', togglePanel);

    function commitDivisions(nextInner, nextOuter) {
      const inner = Math.max(2, Math.min(60, Math.round(Number(nextInner) || 8)));
      const outer = Math.max(2, Math.min(60, Math.round(Number(nextOuter) || 10)));
      config.innerDiv = inner;
      config.outerDiv = outer;
      saveConfig(config);
      // 依据新分份数重新计算当前角度对应的索引
      state.innerTickIndex = mod(angleToTick(state.innerAngle, inner), inner);
      state.outerTickIndex = mod(angleToTick(state.outerAngle, outer), outer);
      state.rInnerTickIndex = mod(angleToTick(state.rInnerAngle, inner), inner);
      state.rOuterTickIndex = mod(angleToTick(state.rOuterAngle, outer), outer);
      draw();
    }
    // 输入实时更新与保存
    innerInput.addEventListener('input', () => {
      commitDivisions(innerInput.value, outerInput.value);
    });
    outerInput.addEventListener('input', () => {
      commitDivisions(innerInput.value, outerInput.value);
    });
    // 初始化时确保按钮文字正确
    setButtonLabel();
  </script>
</body>
</html>