<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>正方形三角形相遇问题</title>

    <style>
        body {
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
            margin: 0;
            overflow: hidden;
            background: #f8fafc;
            color: #334155;
        }

        #app {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #ffffff;
        }

        .canvas-container {
            width: 100%;
            height: 70vh;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .action-controls {
            position: fixed;
            bottom: 3rem;
            display: flex;
            gap: 1.5rem;
            z-index: 20;
        }

        .slider-controls {
            position: fixed;
            bottom: 8.5rem;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            z-index: 20;
        }

        .slider-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        button {
            padding: 10px 20px;
            min-width: 180px;
            border-radius: 24px;
            font-weight: 800;
            font-size: 1.25rem;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }

        .btn-primary {
            background: #0f172a;
            color: white;
            box-shadow: 0 10px 20px rgba(15, 23, 42, 0.15);
        }

        .btn-primary:active {
            transform: scale(0.95);
        }

        .btn-secondary {
            background: #ffffff;
            color: #0f172a;
            border: 2px solid #e2e8f0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.02);
        }

        .btn-secondary:hover {
            border-color: #cbd5e1;
            background: #f8fafc;
        }

        .btn-secondary:hover {
            background: #f8fafc;
            color: #1e293b;
            border-color: #cbd5e1;
        }

        .time-display {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 0.75rem 2.5rem;
            border-radius: 100px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0;
            font-size: 1.25rem;
            font-weight: 700;
            color: #1e293b;
            z-index: 10;
        }

        /* SVG Styles */
        .shape {
            transition: fill 0.3s ease;
            vector-effect: non-scaling-stroke;
        }

        .shape-square {
            fill: none;
            stroke: #3b82f6;
            stroke-width: 3px;
        }

        .shape-triangle {
            fill: none;
            stroke: #ef4444;
            stroke-width: 3px;
        }

        .shape-overlap {
            fill: rgba(245, 158, 11, 0.4);
            stroke: #f59e0b;
            stroke-width: 1px;
            mix-blend-mode: normal;
            filter: drop-shadow(0 0 8px rgba(245, 158, 11, 0.3));
        }

        .ground-line {
            stroke: #94a3b8;
            stroke-width: 2;
            stroke-linecap: round;
            vector-effect: non-scaling-stroke;
        }

        .labels-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .label-text {
            position: absolute;
            font-size: 18px;
            font-family: 'Inter', sans-serif;
            color: #1e293b;
            font-weight: 700;
            user-select: none;
            transform: translate(-50%, -50%);
            white-space: nowrap;
            text-shadow: 0 0 4px rgba(255, 255, 255, 0.8), 0 0 8px rgba(255, 255, 255, 0.5);
        }

        .dimension-line {
            stroke: #64748b;
            stroke-width: 1;
            vector-effect: non-scaling-stroke;
        }

        .dimension-text {
            font-size: 14px;
            fill: #64748b;
            text-anchor: middle;
        }

        /* Slider Styling */
        input[type="range"] {
            -webkit-appearance: none;
            width: 400px;
            height: 12px;
            background: #f1f5f9;
            border-radius: 20px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            background: #0f172a;
            cursor: pointer;
            border-radius: 50%;
            border: 4px solid #ffffff;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
    </style>
</head>

<body>

    <div id="app">
        <div class="time-display" id="timeHeader">0.0 秒</div>

        <div class="canvas-container">
            <canvas id="geometryCanvas"></canvas>
            <!-- HTML Overlay for text labels -->
            <div id="labelsLayer" class="labels-container"></div>
        </div>

        <div class="slider-controls">
            <div class="slider-label">进度</div>
            <input type="range" id="timeSlider" min="0" max="10.5" step="0.5" value="0">
        </div>

        <div class="action-controls">
            <button id="resetBtn" class="btn-secondary">
                <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5"
                        d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15">
                    </path>
                </svg>
                重置
            </button>

            <button id="playPauseBtn" class="btn-primary">
                <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z" />
                </svg>
                <span>开始运动</span>
            </button>
        </div>
    </div>

    <script>
        // --- Constants & Config ---
        const SQUARE_SIDE = 6;
        const TRI_BASE = 20;
        const TRI_HEIGHT = 10;
        const GAP = 16;
        const SPEED = 2; // cm/s -> 4s overlap for 16cm gap

        const INITIAL_SQ_X = 0;
        const INITIAL_TRI_X = SQUARE_SIDE + GAP; // 6 + 16 = 22

        const MAX_TIME = 10.5;

        // Viewport config to keep things large and centered
        // Total logical width from B(0) to G(42) is ~42.
        // Viewport config to zoom in even more
        const VIEW_WIDTH = 42;  // Zoomed in from 50 (Total logical range is 42 units)
        const VIEW_HEIGHT = 35;
        const VIEW_OFF_X = 0;
        const GROUND_Y = 20;    // Raised ground slightly to middle-bottom

        // --- State ---
        let state = {
            t: 0, // seconds
            isPlaying: false,
            lastFrameTime: 0
        };

        // --- DOM Elements ---
        const els = {
            canvas: document.getElementById('geometryCanvas'),
            ctx: document.getElementById('geometryCanvas').getContext('2d'),
            labelsLayer: document.getElementById('labelsLayer'),
            playPauseBtn: document.getElementById('playPauseBtn'),
            resetBtn: document.getElementById('resetBtn'),
            timeSlider: document.getElementById('timeSlider'),
            timeHeader: document.getElementById('timeHeader'),
            stats: {
                // Kept for logic compatibility but hidden/removed from DOM
                time: { innerText: '' },
                sqDist: { innerText: '' },
                triDist: { innerText: '' },
                area: { innerText: '' }
            }
        };


        // --- Logic ---

        function updateState(dt) {
            if (!state.isPlaying) return;
            const prevT = state.t;
            state.t += dt;

            // Auto-pause at specific timestamps
            const pausePoints = [4.0, 5.5];
            for (const p of pausePoints) {
                if (prevT < p && state.t >= p) {
                    state.t = p;
                    pause();
                    break;
                }
            }

            if (state.t > MAX_TIME) {
                state.t = MAX_TIME;
                pause();
            }
            render();
        }

        function render() {
            const { canvas, ctx } = els;
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();

            // Adjust canvas resolution for high DPI screens
            if (canvas.width !== rect.width * dpr || canvas.height !== rect.height * dpr) {
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
            }

            // Calculate scale based on viewBox (-10 0 100 50)
            // Aspect ratio management like "xMidYMid meet"
            const scale = Math.min(canvas.width / VIEW_WIDTH, canvas.height / VIEW_HEIGHT);
            const offsetX = (canvas.width - VIEW_WIDTH * scale) / 2 - VIEW_OFF_X * scale;
            const offsetY = (canvas.height - VIEW_HEIGHT * scale) / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // 1. Draw Ground Line
            ctx.beginPath();
            ctx.moveTo(-1000, GROUND_Y);
            ctx.lineTo(1000, GROUND_Y);
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 1 / scale;
            ctx.stroke();

            // Stats Update
            els.timeSlider.value = state.t;
            els.timeHeader.innerText = state.t.toFixed(1) + ' 秒';
            const dist = (SPEED * state.t);
            // els.stats.sqDist.innerText = dist.toFixed(2) + ' cm'; // Removed from DOM
            // els.stats.triDist.innerText = dist.toFixed(2) + ' cm'; // Removed from DOM

            const sqPos = INITIAL_SQ_X + dist;
            const triPos = INITIAL_TRI_X - dist;

            // Coordinate mapping helper for labels
            const getScreenCoord = (ux, uy) => {
                const sx = ux * scale + offsetX;
                const sy = uy * scale + offsetY;
                // Back to client % (for labelsLayer)
                return {
                    x: (sx / dpr / rect.width) * 100,
                    y: (sy / dpr / rect.height) * 100
                };
            };

            // 2. Draw Objects (Flipped Y logic for geometry)
            const drawFlipped = (callback) => {
                ctx.save();
                ctx.translate(0, GROUND_Y);
                ctx.scale(1, -1);
                callback();
                ctx.restore();
            };

            // Clear labels
            els.labelsLayer.innerHTML = '';

            // Draw Square
            drawFlipped(() => {
                ctx.beginPath();
                ctx.rect(sqPos, 0, SQUARE_SIDE, SQUARE_SIDE);
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 3 / scale;
                ctx.stroke();
            });

            // Draw Triangle
            drawFlipped(() => {
                ctx.beginPath();
                ctx.moveTo(triPos, 0);
                ctx.lineTo(triPos + TRI_BASE, 0);
                ctx.lineTo(triPos + TRI_BASE / 2, TRI_HEIGHT);
                ctx.closePath();
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 3 / scale;
                ctx.stroke();
            });

            // Draw Overlap
            drawFlipped(() => {
                ctx.save();
                // Clip by square
                ctx.beginPath();
                ctx.rect(sqPos, 0, SQUARE_SIDE, SQUARE_SIDE);
                ctx.clip();

                // Draw triangle in overlap style
                ctx.beginPath();
                ctx.moveTo(triPos, 0);
                ctx.lineTo(triPos + TRI_BASE, 0);
                ctx.lineTo(triPos + TRI_BASE / 2, TRI_HEIGHT);
                ctx.closePath();

                ctx.fillStyle = 'rgba(245, 158, 11, 0.4)';
                ctx.fill();
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 1 / scale;
                ctx.stroke();

                ctx.restore();
            });

            // Calculate Area
            const area = calculateOverlapArea(sqPos, triPos);
            // els.stats.area.innerText = area.toFixed(2) + ' cm²'; // Removed from DOM

            // --- Draw Labels ---
            const toFinal = (ux, uy) => getScreenCoord(ux, GROUND_Y - uy);

            // Square Labels
            drawLabel(toFinal(sqPos, SQUARE_SIDE), 'A', -15, -15);
            drawLabel(toFinal(sqPos, 0), 'B', -15, 15);
            drawLabel(toFinal(sqPos + SQUARE_SIDE, 0), 'C', 15, 15);
            drawLabel(toFinal(sqPos + SQUARE_SIDE, SQUARE_SIDE), 'D', 15, -15);

            // Triangle Labels
            drawLabel(toFinal(triPos, 0), 'F', -15, 15);
            drawLabel(toFinal(triPos + TRI_BASE, 0), 'G', 15, 15);
            drawLabel(toFinal(triPos + TRI_BASE / 2, TRI_HEIGHT), 'E', 0, -20);

            // Dimensions (Text Only)
            const labelY = GROUND_Y + 4;  // Even closer to ground (was 7)
            const gapStart = sqPos + SQUARE_SIDE;
            const gapEnd = triPos;

            if (gapEnd > gapStart) {
                // Display gap as integer with default dark color
                drawTextOnly(ctx, (gapStart + gapEnd) / 2, labelY, Math.round(gapEnd - gapStart).toString(), scale, '#1e293b');
            }
            // Square label (Blue)
            drawTextOnly(ctx, sqPos + SQUARE_SIDE / 2, labelY, SQUARE_SIDE.toString(), scale, '#3b82f6');
            // Triangle label (Red)
            drawTextOnly(ctx, triPos + TRI_BASE / 2, labelY, TRI_BASE.toString(), scale, '#ef4444');

            // --- Draw Right Angle Symbol at E ---
            const ex = triPos + TRI_BASE / 2;
            const ey = TRI_HEIGHT;
            const s = 1.2; // logical size
            const d = s * 0.707;
            drawFlipped(() => {
                ctx.beginPath();
                // We are at the peak E. Draw lines "down" into the triangle.
                ctx.moveTo(ex - d, ey - d); // Point on left slanted side EF
                ctx.lineTo(ex, ey - 2 * d); // Right angle vertex inside 
                ctx.lineTo(ex + d, ey - d); // Point on right slanted side EG
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 1.6 / scale;
                ctx.stroke();
            });

            ctx.restore();
        }

        function drawTextOnly(ctx, x, y, text, scale, color) {
            ctx.save();
            ctx.fillStyle = color || '#1e293b';
            ctx.font = `700 ${36 / scale}px Inter`; // Doubled from 18px
            ctx.textAlign = 'center';
            ctx.fillText(text, x, y);
            ctx.restore();
        }

        // --- Helpers ---

        function drawCanvasDimension(ctx, x1, x2, y, text, scale) {
            ctx.save();
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 1 / scale;
            ctx.fillStyle = '#64748b';
            ctx.font = `${14 / scale}px Inter`;
            ctx.textAlign = 'center';

            // Line
            ctx.beginPath();
            ctx.moveTo(x1, y);
            ctx.lineTo(x2, y);
            ctx.stroke();

            // Ticks
            ctx.beginPath();
            ctx.moveTo(x1, y - 1 / scale); ctx.lineTo(x1, y + 1 / scale);
            ctx.moveTo(x2, y - 1 / scale); ctx.lineTo(x2, y + 1 / scale);
            ctx.stroke();

            // Text
            ctx.fillText(text, (x1 + x2) / 2, y + 4 / scale);
            ctx.restore();
        }

        function drawLabel(screenPos, text, ox, oy) {
            const el = document.createElement('div');
            el.className = 'label-text';
            el.textContent = text;
            el.style.left = `calc(${screenPos.x}% + ${ox}px)`;
            el.style.top = `calc(${screenPos.y}% + ${oy}px)`;
            els.labelsLayer.appendChild(el);
        }

        // Geometric overlap calculation
        function calculateOverlapArea(sqLeft, triLeft) {
            // Square: [L, R] = [sqLeft, sqLeft+6], Height 6
            // Triangle: Base [T_L, T_R] = [triLeft, triLeft+20]. Height 10. Apex at T_L+10.
            // Slopes 1 and -1.

            // This is a complex intersection of polygon function.
            // Since standard "moving square into triangle" problems usually have piecewise functions.
            // For visual demo, we can just approximate or solve for the intersection polygon area.
            // Or use an off-the-shelf minimal algo.
            // Given the simple shapes (Rectangle and Triangle on same base), we can integrate height.

            const sqRight = sqLeft + 6;
            const triRight = triLeft + 20;
            const triMid = triLeft + 10;

            // Define Triangle Height function y(x)
            const triY = (x) => {
                if (x < triLeft || x > triRight) return 0;
                if (x <= triMid) return x - triLeft; // Slope 1
                return triRight - x; // Slope -1
            };

            // Define Square Height function y(x)
            const sqY = (x) => {
                if (x < sqLeft || x > sqRight) return 0;
                return 6;
            };

            // Intersection Height h(x) = min(sqY(x), triY(x))
            // Area = Integral h(x) dx

            // Numerical integration for simplicity (accurate enough for UX stats)
            let area = 0;
            const step = 0.05;
            // Intersection range is roughly [max(sqL, triL), min(sqR, triR)]
            const start = Math.max(sqLeft, triLeft);
            const end = Math.min(sqRight, triRight);

            if (start >= end) return 0;

            for (let x = start; x < end; x += step) {
                const mid = x + step / 2;
                const h = Math.min(6, triY(mid));
                if (h > 0) area += h * step;
            }

            return area;
        }

        // --- Loop ---
        function tick(timestamp) {
            if (state.isPlaying) {
                if (!state.lastFrameTime) state.lastFrameTime = timestamp;
                const dt = (timestamp - state.lastFrameTime) / 1000;
                state.lastFrameTime = timestamp;
                updateState(dt);
            } else {
                state.lastFrameTime = 0;
            }
            requestAnimationFrame(tick);
        }

        function playPause() {
            state.isPlaying = !state.isPlaying;
            els.playPauseBtn.innerHTML = state.isPlaying ?
                `<svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg><span>暂停运动</span>` :
                `<svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg><span>开始运动</span>`;
        }

        function pause() {
            state.isPlaying = false;
            els.playPauseBtn.innerHTML = `<svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg><span>开始运动</span>`;
        }

        function reset() {
            pause();
            state.t = 0;
            render();
        }

        // --- Events ---
        els.playPauseBtn.addEventListener('click', playPause);
        els.resetBtn.addEventListener('click', reset);

        els.timeSlider.addEventListener('input', (e) => {
            pause();
            state.t = parseFloat(e.target.value);
            render();
        });

        // Init
        render();
        requestAnimationFrame(tick);

    </script>
</body>

</html>