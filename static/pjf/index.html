<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>橘子拖拽游戏 - Canvas版</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #E6F3FF, #F0FFF0);
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
        }

        #gameCanvas {
            display: block;
            cursor: grab;
            background: linear-gradient(135deg, #E6F3FF, #F0FFF0);
        }

        #gameCanvas:active {
            cursor: grabbing;
        }

        #gameCanvas.select-mode {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="%23333" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>') 12 12, crosshair;
        }

        #gameCanvas.select-mode:active {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="%23333" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>') 12 12, crosshair;
        }

        /* 圈选完成后的拖拽状态 */
        #gameCanvas.select-mode.dragging-selection {
            cursor: pointer !important;
        }

        .title {
            position: absolute;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            color: #333;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
            white-space: nowrap;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-size: 18px;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .mode-button {
            padding: 6px 12px;
            border: none;
            border-radius: 12px;
            background: #4CAF50;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .mode-button:hover {
            background: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .mode-button.active {
            background: #FF6B35;
        }

        .mode-button.active:hover {
            background: #e55a2b;
        }

        .instruction {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 2rem;
            text-align: center;
            background: rgba(0,0,0,0.4);
            padding: 6px 12px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            .title {
                font-size: 20px;
                top: -40px;
            }
            
            .controls {
                top: 5px;
                right: 5px;
            }
            
            .mode-button {
                padding: 6px 12px;
                font-size: 12px;
            }
            
            .instruction {
                font-size: 16px;
                padding: 10px 20px;
                max-width: 90%;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="title">拖拽橘子到盘子里</h1>
        <div class="controls">
            <button id="toggleMode" class="mode-button">圈分</button>
            <button id="resetBtn" class="mode-button" style="display: none;">重分</button>
        </div>
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
        <div class="loading" id="loading">加载中...</div>
        <div class="instruction" id="instruction">拖拽橘子到盘子里</div>
    </div>

    <script>
        class CanvasDragGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.loading = document.getElementById('loading');
                this.instruction = document.getElementById('instruction');
                this.toggleModeBtn = document.getElementById('toggleMode');
                this.resetBtn = document.getElementById('resetBtn');
                
                // 游戏对象
                this.oranges = [];
                this.plates = [];
                this.images = {};
                this.imagesLoaded = 0;
                this.totalImages = 2;
                
                // 拖拽状态
                this.isDragging = false;
                this.dragOrange = null;
                this.dragOffset = { x: 0, y: 0 };
                this.hoveredPlate = null;
                
                // 圈选模式状态
                this.isSelectMode = false;
                this.isSelecting = false;
                this.selectionPath = []; // 存储绳子式圈选的路径点
                this.selectedOranges = [];
                this.isDraggingSelection = false;
                this.selectionDragOffset = { x: 0, y: 0 };
                this.ghostOranges = []; // 半透明的原位置橘子
                this.distributionCount = 0; // 分配次数计数器
                
                // 游戏配置
                this.orangeSize = 60;
                this.plateWidth = 120;
                this.plateHeight = 58; // 调整盘子高度保持比例
                this.plateY = this.canvas.height - 160; // 调整Y位置
                
                this.init();
            }

            init() {
                this.setupCanvas();
                this.loadImages();
            }

            setupCanvas() {
                // 获取Canvas的实际显示尺寸
                const rect = this.canvas.getBoundingClientRect();
                
                // 设置Canvas的实际尺寸为显示尺寸
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                
                // 更新plateY位置基于实际Canvas高度
                this.plateY = this.canvas.height - 160;
            }

            loadImages() {
                const imageUrls = {
                    orange: 'juzi.png',
                    plate: 'panzi.png'
                };

                Object.keys(imageUrls).forEach(key => {
                    const img = new Image();
                    img.onload = () => {
                        this.images[key] = img;
                        this.imagesLoaded++;
                        if (this.imagesLoaded === this.totalImages) {
                            this.startGame();
                        }
                    };
                    img.onerror = () => {
                        // 创建占位符图像
                        this.images[key] = this.createPlaceholderImage(key);
                        this.imagesLoaded++;
                        if (this.imagesLoaded === this.totalImages) {
                            this.startGame();
                        }
                    };
                    img.src = imageUrls[key];
                });
            }

            createPlaceholderImage(type) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                if (type === 'orange') {
                    canvas.width = canvas.height = 60;
                    ctx.fillStyle = '#FF6B35';
                    ctx.beginPath();
                    ctx.arc(30, 30, 25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(25, 5, 10, 15);
                } else if (type === 'plate') {
                    canvas.width = 120;
                    canvas.height = 58;
                    ctx.fillStyle = '#E0E0E0';
                    ctx.beginPath();
                    ctx.ellipse(60, 40, 55, 35, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                return canvas;
            }

            startGame() {
                this.loading.style.display = 'none';
                this.createGameObjects();
                this.addEventListeners();
                this.addModeListeners();
                this.gameLoop();
            }

            createGameObjects() {
                // 创建18个橘子，确保不重叠且在容器内
                this.createOrangesWithoutOverlap();
                // 创建6个盘子
                const plateSpacing = (this.canvas.width - 6 * this.plateWidth) / 7;
                for (let i = 0; i < 6; i++) {
                    this.plates.push({
                        id: i,
                        x: plateSpacing + i * (this.plateWidth + plateSpacing),
                        y: this.plateY,
                        width: this.plateWidth,
                        height: this.plateHeight,
                        oranges: [], // 存储盘子里的橘子数组
                        highlight: false,
                        scale: 1,
                        targetScale: 1
                    });
                }
            }

            exitSelectModeAndShowReset() {
                // 退出圈选模式
                this.isSelectMode = false;
                this.canvas.classList.remove('select-mode');
                this.clearSelection();
                
                // 隐藏圈选按钮，显示重新分按钮
                this.toggleModeBtn.style.display = 'none';
                this.resetBtn.style.display = 'inline-block';
            }

            resetGame() {
                // 重置所有状态
                this.distributionCount = 0;
                this.isSelectMode = false;
                this.canvas.classList.remove('select-mode');
                this.clearSelection();
                
                // 清空所有盘子并重置橘子状态
                this.plates.forEach(plate => {
                    plate.oranges = [];
                    plate.highlight = false;
                    plate.targetScale = 1;
                });
                
                // 重置所有橘子状态并重新生成位置
                this.oranges = []; // 清空现有橘子数组
                this.createOrangesWithoutOverlap(); // 重新创建橘子
                
                // 恢复按钮状态
                this.toggleModeBtn.style.display = 'inline-block';
                this.toggleModeBtn.textContent = '圈一';
                this.toggleModeBtn.classList.remove('active');
                this.resetBtn.style.display = 'none';
                
                // 恢复初始指令
                this.instruction.textContent = '拖拽橘子到盘子里';
            }

            createOrangesWithoutOverlap() {
                const maxAttempts = 1000; // 防止无限循环
                const minDistance = this.orangeSize; // 橘子之间的最小距离
                const gameAreaHeight = this.canvas.height - 200; // 为盘子留出空间
                const margin = 10; // 边界边距
                
                // 定义中心区域范围（画布的中心60%区域）
                const centerAreaWidth = this.canvas.width * 0.6;
                const centerAreaHeight = gameAreaHeight * 0.6;
                const centerStartX = (this.canvas.width - centerAreaWidth) / 2;
                const centerStartY = (gameAreaHeight - centerAreaHeight) / 2;

                for (let i = 0; i < 18; i++) {
                    let attempts = 0;
                    let validPosition = false;
                    let newOrange;
                    
                    while (!validPosition && attempts < maxAttempts) {
                        // 在中心区域内生成随机位置
                        const maxX = centerStartX + centerAreaWidth - this.orangeSize;
                        const maxY = centerStartY + centerAreaHeight - this.orangeSize;
                        const x = Math.random() * (maxX - centerStartX) + centerStartX;
                        const y = Math.random() * (maxY - centerStartY) + centerStartY;
                        
                        newOrange = {
                            id: i,
                            x: x,
                            y: y,
                            width: this.orangeSize,
                            height: this.orangeSize,
                            onPlate: false,
                            plateId: null,
                            scale: 1,
                            targetScale: 1
                        };
                        
                        // 检查是否与现有橘子重叠
                        validPosition = true;
                        for (let j = 0; j < this.oranges.length; j++) {
                            const existingOrange = this.oranges[j];
                            const distance = Math.sqrt(
                                Math.pow(newOrange.x + newOrange.width/2 - existingOrange.x - existingOrange.width/2, 2) +
                                Math.pow(newOrange.y + newOrange.height/2 - existingOrange.y - existingOrange.height/2, 2)
                            );
                            
                            if (distance < minDistance) {
                                validPosition = false;
                                break;
                            }
                        }
                        
                        attempts++;
                    }
                    
                    // 如果找不到合适位置，使用网格布局（在中心区域）
                    if (!validPosition) {
                        const cols = Math.ceil(Math.sqrt(18));
                        const rows = Math.ceil(18 / cols);
                        const cellWidth = centerAreaWidth / cols;
                        const cellHeight = centerAreaHeight / rows;
                        
                        const col = i % cols;
                        const row = Math.floor(i / cols);
                        
                        newOrange = {
                            id: i,
                            x: centerStartX + col * cellWidth + (cellWidth - this.orangeSize) / 2,
                            y: centerStartY + row * cellHeight + (cellHeight - this.orangeSize) / 2,
                            width: this.orangeSize,
                            height: this.orangeSize,
                            onPlate: false,
                            plateId: null,
                            scale: 1,
                            targetScale: 1
                        };
                        
                        // 确保网格布局的橘子也在中心区域内
                        newOrange.x = Math.max(centerStartX, Math.min(newOrange.x, centerStartX + centerAreaWidth - this.orangeSize));
                        newOrange.y = Math.max(centerStartY, Math.min(newOrange.y, centerStartY + centerAreaHeight - this.orangeSize));
                    }
                    
                    this.oranges.push(newOrange);
                }
            }

            addEventListeners() {
                // 鼠标事件
                this.canvas.addEventListener('mousedown', (e) => this.handleStart(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleEnd(e));

                // 触摸事件
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleStart(e.touches[0]);
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handleMove(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleEnd(e.changedTouches[0]);
                });

                // 防止右键菜单
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            addModeListeners() {
                this.toggleModeBtn.addEventListener('click', () => {
                    this.toggleMode();
                });
                
                this.resetBtn.addEventListener('click', () => {
                    this.resetGame();
                });
            }

            toggleMode() {
                if (this.isSelectMode) {
                    // 当前是圈选模式，切换到普通模式
                    this.isSelectMode = false;
                    this.toggleModeBtn.textContent = '圈一';
                    this.toggleModeBtn.classList.remove('active');
                    this.canvas.classList.remove('select-mode');
                    this.instruction.textContent = '拖拽橘子到盘子里';
                    this.clearSelection();
                } else {
                    // 当前是普通模式，切换到圈选模式
                    this.isSelectMode = true;
                    this.toggleModeBtn.textContent = '退出';
                    this.toggleModeBtn.classList.add('active');
                    this.canvas.classList.add('select-mode');
                    this.instruction.textContent = '画线围住6个橘子，然后拖动会自动分配。';
                    this.clearSelection();
                }
            }

            clearSelection() {
                this.selectedOranges = [];
                this.selectionPath = [];
                this.isSelecting = false;
                this.isDraggingSelection = false;
                this.ghostOranges = [];
                this.originalPositions = null; // 清除保存的原始位置
                // 移除拖拽样式
                this.canvas.classList.remove('dragging-selection');
            }

            getCanvasCoordinates(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            handleStart(e) {
                const pos = this.getCanvasCoordinates(e);
                
                if (this.isSelectMode) {
                    if (this.selectedOranges.length === 6 && this.isPointInSelectionPath(pos)) {
                        // 开始拖拽选区
                        this.isDraggingSelection = true;
                        const center = this.getSelectionCenter();
                        this.selectionDragOffset.x = pos.x - center.x;
                        this.selectionDragOffset.y = pos.y - center.y;
                        
                        // 立即创建透明橘子显示在原位置
                        if (this.originalPositions) {
                            this.ghostOranges = this.originalPositions.map(pos => ({
                                x: pos.x,
                                y: pos.y,
                                width: pos.width,
                                height: pos.height
                            }));
                        }
                    } else if (this.selectedOranges.length === 6) {
                        // 如果已经选中6个橘子，但点击在选区外，开始新的圈选
                        this.clearSelection();
                        this.isSelecting = true;
                        this.selectionPath = [{ x: pos.x, y: pos.y }];
                        this.selectedOranges = [];
                    } else {
                        // 开始新的画线圈选
                        this.isSelecting = true;
                        this.selectionPath = [{ x: pos.x, y: pos.y }];
                        this.selectedOranges = []; // 清空之前的选择
                    }
                } else {
                    // 普通模式
                    // 从上到下检查橘子（后绘制的在上层）
                    for (let i = this.oranges.length - 1; i >= 0; i--) {
                        const orange = this.oranges[i];
                        if (this.isPointInOrange(pos, orange)) {
                            this.isDragging = true;
                            this.dragOrange = orange;
                            this.dragOffset.x = pos.x - orange.x;
                            this.dragOffset.y = pos.y - orange.y;
                            orange.targetScale = 1.1;
                            
                            // 如果橘子在盘子上，从盘子上移除
                            if (orange.onPlate && orange.plateId !== null) {
                                const plate = this.plates[orange.plateId];
                                const index = plate.oranges.indexOf(orange);
                                if (index > -1) {
                                    plate.oranges.splice(index, 1);
                                    // 重新排列剩余橘子
                                    this.arrangeOrangesOnPlate(plate);
                                }
                                orange.onPlate = false;
                                orange.plateId = null;
                            }
                            break;
                        }
                    }
                }
            }

            handleMove(e) {
                const pos = this.getCanvasCoordinates(e);

                if (this.isSelectMode) {
                    if (this.isSelecting) {
                        // 实时添加路径点，创建平滑的画线效果
                        const lastPoint = this.selectionPath[this.selectionPath.length - 1];
                        const distance = Math.sqrt(
                            Math.pow(pos.x - lastPoint.x, 2) + Math.pow(pos.y - lastPoint.y, 2)
                        );
                        
                        // 降低距离阈值，让线条更平滑
                        if (distance > 3) {
                            this.selectionPath.push({ x: pos.x, y: pos.y });
                            // 实时更新选中的橘子
                            this.updateSelectionFromPath();
                        }
                    } else if (this.isDraggingSelection && this.selectedOranges.length === 6) {
                        // 拖拽选区
                        const center = this.getSelectionCenter();
                        const newCenterX = pos.x - this.selectionDragOffset.x;
                        const newCenterY = pos.y - this.selectionDragOffset.y;
                        
                        // 计算移动偏移
                        const deltaX = newCenterX - center.x;
                        const deltaY = newCenterY - center.y;
                        
                        // 同时移动选中的橘子
                        this.selectedOranges.forEach(orange => {
                            orange.x += deltaX;
                            orange.y += deltaY;
                        });
                    }
                } else {
                    // 普通模式
                    if (!this.isDragging || !this.dragOrange) return;

                    // 限制橘子在canvas边界内，添加边距
                    const margin = 5;
                    let newX = pos.x - this.dragOffset.x;
                    let newY = pos.y - this.dragOffset.y;
                    
                    // 确保橘子完全在canvas边界内
                    newX = Math.max(margin, Math.min(newX, this.canvas.width - this.dragOrange.width - margin));
                    newY = Math.max(margin, Math.min(newY, this.canvas.height - this.dragOrange.height - margin));
                    
                    this.dragOrange.x = newX;
                    this.dragOrange.y = newY;

                    // 检查悬停的盘子
                    this.hoveredPlate = null;
                    this.plates.forEach(plate => {
                        plate.highlight = false;
                        plate.targetScale = 1;
                        if (this.isPointInPlate(pos, plate)) {
                            this.hoveredPlate = plate;
                            plate.highlight = true;
                            plate.targetScale = 1.05;
                        }
                    });
                }
            }

            handleEnd(e) {
                const pos = this.getCanvasCoordinates(e);

                if (this.isSelectMode) {
                    if (this.isSelecting) {
                        // 完成画线圈选
                        this.isSelecting = false;
                        // 闭合路径（连接最后一点到第一点）
                        if (this.selectionPath.length > 2) {
                            // 自动闭合路径
                            this.selectionPath.push(this.selectionPath[0]);
                            this.updateSelectionFromPath();
                            this.finalizeSelection();
                        }
                    } else if (this.isDraggingSelection) {
                        // 完成选区拖拽，检查是否需要自动分配
                        this.isDraggingSelection = false;
                        if (this.selectedOranges.length === 6) {
                            this.autoDistributeToPlates();
                        }
                    }
                } else {
                    // 普通模式
                    if (!this.isDragging || !this.dragOrange) return;

                    const targetPlate = this.getPlateAt(pos);

                    if (targetPlate) {
                        this.placeOrangeOnPlate(this.dragOrange, targetPlate);
                    }

                    // 重置状态
                    this.dragOrange.targetScale = 1; // 统一保持原始大小
                    this.plates.forEach(plate => {
                        plate.highlight = false;
                        plate.targetScale = 1;
                    });

                    this.isDragging = false;
                    this.dragOrange = null;
                    this.hoveredPlate = null;
                }
            }

            isPointInOrange(point, orange) {
                return point.x >= orange.x && point.x <= orange.x + orange.width &&
                       point.y >= orange.y && point.y <= orange.y + orange.height;
            }

            isPointInPlate(point, plate) {
                return point.x >= plate.x && point.x <= plate.x + plate.width &&
                       point.y >= plate.y && point.y <= plate.y + plate.height;
            }

            getPlateAt(point) {
                for (let plate of this.plates) {
                    if (this.isPointInPlate(point, plate)) {
                        return plate;
                    }
                }
                return null;
            }

            // 检查点是否在画线圈选路径内
            isPointInSelectionPath(point) {
                if (this.selectionPath.length < 3 || this.selectedOranges.length !== 6) return false;
                return this.isPointInPolygon(point, this.selectionPath);
            }

            // 根据画线路径更新选择
            updateSelectionFromPath() {
                if (this.selectionPath.length < 3) {
                    this.selectedOranges = [];
                    return;
                }

                // 找到路径内的橘子
                this.selectedOranges = [];
                this.oranges.forEach(orange => {
                    if (!orange.onPlate && this.isOrangeInSelectionPath(orange)) {
                        this.selectedOranges.push(orange);
                    }
                });
            }

            // 检查橘子是否在画线圈选路径内（改进算法）
            isOrangeInSelectionPath(orange) {
                if (this.selectionPath.length < 3) return false;
                
                // 检查橘子的多个点是否在路径内，而不仅仅是中心点
                const orangeCenterX = orange.x + orange.width / 2;
                const orangeCenterY = orange.y + orange.height / 2;
                const radius = orange.width / 3; // 橘子的有效半径
                
                // 检查中心点和周围几个点
                const checkPoints = [
                    { x: orangeCenterX, y: orangeCenterY }, // 中心点
                    { x: orangeCenterX - radius, y: orangeCenterY }, // 左
                    { x: orangeCenterX + radius, y: orangeCenterY }, // 右
                    { x: orangeCenterX, y: orangeCenterY - radius }, // 上
                    { x: orangeCenterX, y: orangeCenterY + radius }  // 下
                ];
                
                // 如果任何一个检查点在路径内，就认为橘子被选中
                return checkPoints.some(point => this.isPointInPolygon(point, this.selectionPath));
            }

            // 点在多边形内的判断算法（射线法）- 优化版本
            isPointInPolygon(point, polygon) {
                if (polygon.length < 3) return false;
                
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const xi = polygon[i].x, yi = polygon[i].y;
                    const xj = polygon[j].x, yj = polygon[j].y;
                    
                    if (((yi > point.y) !== (yj > point.y)) &&
                        (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi)) {
                        inside = !inside;
                    }
                }
                return inside;
            }

            // 获取选中橘子的中心点
            getSelectionCenter() {
                if (this.selectedOranges.length === 0) return { x: 0, y: 0 };
                
                let totalX = 0, totalY = 0;
                this.selectedOranges.forEach(orange => {
                    totalX += orange.x + orange.width / 2;
                    totalY += orange.y + orange.height / 2;
                });
                
                return {
                    x: totalX / this.selectedOranges.length,
                    y: totalY / this.selectedOranges.length
                };
            }

            finalizeSelection() {
                if (this.selectedOranges.length === 6) {
                    // 正好6个橘子，保存原始位置并添加拖拽样式
                    this.originalPositions = this.selectedOranges.map(orange => ({
                        x: orange.x,
                        y: orange.y,
                        width: orange.width,
                        height: orange.height
                    }));
                    this.canvas.classList.add('dragging-selection');
                    this.instruction.textContent = '拖动选区自动分配到6个盘子';
                } else if (this.selectedOranges.length > 6) {
                    // 超过6个，只保留前6个
                    this.selectedOranges = this.selectedOranges.slice(0, 6);
                    this.originalPositions = this.selectedOranges.map(orange => ({
                        x: orange.x,
                        y: orange.y,
                        width: orange.width,
                        height: orange.height
                    }));
                    this.canvas.classList.add('dragging-selection');
                    this.instruction.textContent = '已选择6个橘子，拖动选区自动分配到盘子';
                } else {
                    // 少于6个，清除选择
                    this.clearSelection();
                    this.instruction.textContent = '请圈选6个橘子';
                }
            }

            autoDistributeToPlates() {
                if (this.selectedOranges.length !== 6) return;

                // 透明橘子已经在开始拖拽时创建，这里不需要重复创建
                // 如果还没有透明橘子（比如直接调用这个函数），则创建
                if (this.ghostOranges.length === 0) {
                    this.ghostOranges = this.originalPositions ? this.originalPositions.slice() : this.selectedOranges.map(orange => ({
                        x: orange.x,
                        y: orange.y,
                        width: orange.width,
                        height: orange.height
                    }));
                }

                // 将6个橘子分配到6个盘子
                this.selectedOranges.forEach((orange, index) => {
                    const plate = this.plates[index];
                    
                    // 从之前的盘子中移除橘子（如果有）
                    if (orange.onPlate && orange.plateId !== null) {
                        const oldPlate = this.plates[orange.plateId];
                        const oldIndex = oldPlate.oranges.indexOf(orange);
                        if (oldIndex > -1) {
                            oldPlate.oranges.splice(oldIndex, 1);
                            // 重新排列剩余橘子
                            this.arrangeOrangesOnPlate(oldPlate);
                        }
                    }

                    // 不清空目标盘子，直接添加新橘子实现累积效果
                    // 将橘子添加到盘子
                    plate.oranges.push(orange);
                    orange.onPlate = true;
                    orange.plateId = plate.id;
                    
                    // 重新排列盘子上的所有橘子
                    this.arrangeOrangesOnPlate(plate);
                });

                // 增加分配次数
                this.distributionCount++;
                
                // 清除选择状态，但保持圈选模式
                this.selectedOranges = [];
                this.selectionPath = [];
                this.isSelecting = false;
                this.isDraggingSelection = false;
                this.originalPositions = null; // 清除保存的原始位置
                this.canvas.classList.remove('dragging-selection');
                
                // 根据分配次数更新指令文字
                let instructionText = '';
                if (this.distributionCount === 1) {
                    instructionText = '每份先各放1个，分掉6个。';
                } else if (this.distributionCount === 2) {
                    instructionText = '每份再各放1个，又分掉6个。';
                } else if (this.distributionCount === 3) {
                    instructionText = '最后每份再各放1个，正好分完。';
                    // 第三次分配后，自动退出圈选模式并显示重新分按钮
                    setTimeout(() => {
                        this.exitSelectModeAndShowReset();
                    }, 2000);
                } else {
                    instructionText = '分配完成！';
                }
                
                this.instruction.textContent = instructionText;
                
                // 3秒后清除半透明橘子
                setTimeout(() => {
                    this.ghostOranges = [];
                }, 3000);
            }

            placeOrangeOnPlate(orange, plate) {
                // 从之前的盘子中移除橘子
                if (orange.onPlate && orange.plateId !== null) {
                    const oldPlate = this.plates[orange.plateId];
                    const index = oldPlate.oranges.indexOf(orange);
                    if (index > -1) {
                        oldPlate.oranges.splice(index, 1);
                    }
                }

                // 将橘子添加到新盘子
                plate.oranges.push(orange);
                
                // 计算橘子在盘子中的位置（避免重叠）
                this.arrangeOrangesOnPlate(plate);

                // 更新橘子状态
                orange.onPlate = true;
                orange.plateId = plate.id;
                orange.targetScale = 1; // 保持原始大小
            }

            arrangeOrangesOnPlate(plate) {
                const orangeCount = plate.oranges.length;
                if (orangeCount === 0) return;

                const plateCenter = {
                    x: plate.x + plate.width / 2,
                    y: plate.y + plate.height / 2
                };

                if (orangeCount === 1) {
                    // 单个橘子放在盘子中心
                    const orange = plate.oranges[0];
                    orange.x = plateCenter.x - orange.width / 2;
                    orange.y = plateCenter.y - orange.height / 2;
                } else if (orangeCount === 2) {
                    // 两个橘子左右排列
                    const spacing = 50;
                    plate.oranges.forEach((orange, index) => {
                        orange.x = plateCenter.x - orange.width / 2 + (index - 0.5) * spacing;
                        orange.y = plateCenter.y - orange.height / 2;
                    });
                } else if (orangeCount === 3) {
                    // 三个橘子三角形排列
                    const positions = [
                        { x: 0, y: -40 },      // 上方
                        { x: -25, y: 0 },     // 左下
                        { x: 25, y: 0 }       // 右下
                    ];
                    plate.oranges.forEach((orange, index) => {
                        orange.x = plateCenter.x - orange.width / 2 + positions[index].x;
                        orange.y = plateCenter.y - orange.height / 2 + positions[index].y;
                    });
                } else if (orangeCount === 4) {
                    // 四个橘子三角形排列
                    const positions = [
                        { x: -23, y: -35 },      // 上左
                        { x: 23, y: -35 },      // 上右
                        { x: -25, y: 10 },     // 左下
                        { x: 25, y: 10 }       // 右下
                    ];
                    plate.oranges.forEach((orange, index) => {
                        orange.x = plateCenter.x - orange.width / 2 + positions[index].x;
                        orange.y = plateCenter.y - orange.height / 2 + positions[index].y;
                    });
                } else {
                    // 更多橘子采用圆形排列
                    const radius = 30;
                    plate.oranges.forEach((orange, index) => {
                        const angle = (index / orangeCount) * 2 * Math.PI;
                        orange.x = plateCenter.x - orange.width / 2 + Math.cos(angle) * radius;
                        orange.y = plateCenter.y - orange.height / 2 + Math.sin(angle) * radius;
                    });
                }
            }

            returnOrangeToRandomPosition(orange) {
                // 从盘子中移除橘子
                if (orange.onPlate && orange.plateId !== null) {
                    const plate = this.plates[orange.plateId];
                    const index = plate.oranges.indexOf(orange);
                    if (index > -1) {
                        plate.oranges.splice(index, 1);
                        // 重新排列剩余橘子
                        this.arrangeOrangesOnPlate(plate);
                    }
                }

                // 生成新的随机位置
                const margin = 10;
                const gameAreaHeight = this.canvas.height - 200;
                orange.x = Math.random() * (this.canvas.width - orange.width - 2 * margin) + margin;
                orange.y = Math.random() * (gameAreaHeight - orange.height - 2 * margin) + margin;
                orange.onPlate = false;
                orange.plateId = null;
                orange.targetScale = 1;
            }

            updateAnimations() {
                // 更新橘子动画
                this.oranges.forEach(orange => {
                    orange.scale += (orange.targetScale - orange.scale) * 0.2;
                });

                // 更新盘子动画
                this.plates.forEach(plate => {
                    plate.scale += (plate.targetScale - plate.scale) * 0.2;
                });
            }

            render() {
                // 清空画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // 绘制半透明的原位置橘子
                if (this.ghostOranges.length > 0) {
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.3;
                    // 优化图片渲染，避免模糊和锯齿
                    this.ctx.imageSmoothingEnabled = true;
                    this.ctx.imageSmoothingQuality = 'high';
                    this.ghostOranges.forEach(ghost => {
                        // 使用整数像素位置避免模糊
                        const finalX = Math.round(ghost.x);
                        const finalY = Math.round(ghost.y);
                        const finalWidth = Math.round(ghost.width);
                        const finalHeight = Math.round(ghost.height);
                        
                        this.ctx.drawImage(
                            this.images.orange,
                            finalX,
                            finalY,
                            finalWidth,
                            finalHeight
                        );
                    });
                    this.ctx.restore();
                }

                // 绘制盘子
                this.plates.forEach(plate => {
                    this.ctx.save();
                    
                    const centerX = plate.x + plate.width / 2;
                    const centerY = plate.y + plate.height / 2;
                    
                    this.ctx.translate(centerX, centerY);
                    
                    if (plate.highlight) {
                        this.ctx.filter = 'brightness(1.2)';
                    }
                    
                    // 优化图片渲染，避免模糊和锯齿
                    this.ctx.imageSmoothingEnabled = true;
                    this.ctx.imageSmoothingQuality = 'high';
                    
                    // 按比例绘制盘子，保持原始图片比例
                    const plateImg = this.images.plate;
                    const aspectRatio = plateImg.width / plateImg.height;
                    let drawWidth = plate.width * plate.scale;
                    let drawHeight = plate.width * plate.scale / aspectRatio; // 根据宽度计算高度
                    
                    // 如果计算出的高度超过设定高度，则以高度为准
                    if (drawHeight > plate.height * plate.scale) {
                        drawHeight = plate.height * plate.scale;
                        drawWidth = plate.height * plate.scale * aspectRatio;
                    }
                    
                    // 使用整数像素位置避免模糊
                    const finalX = Math.round(-drawWidth / 2);
                    const finalY = Math.round(-drawHeight / 2);
                    const finalWidth = Math.round(drawWidth);
                    const finalHeight = Math.round(drawHeight);
                    
                    this.ctx.drawImage(
                        plateImg,
                        finalX,
                        finalY,
                        finalWidth,
                        finalHeight
                    );
                    
                    this.ctx.restore();
                });

                // 绘制橘子（被拖拽的橘子最后绘制）
                const orangesToDraw = [...this.oranges];
                if (this.dragOrange) {
                    const dragIndex = orangesToDraw.indexOf(this.dragOrange);
                    orangesToDraw.splice(dragIndex, 1);
                    orangesToDraw.push(this.dragOrange);
                }

                orangesToDraw.forEach(orange => {
                    this.ctx.save();
                    
                    const centerX = orange.x + orange.width / 2;
                    const centerY = orange.y + orange.height / 2;
                    
                    this.ctx.translate(centerX, centerY);
                    this.ctx.scale(orange.scale, orange.scale);
                    
                    // 优化图片渲染，避免模糊和锯齿
                    this.ctx.imageSmoothingEnabled = true;
                    this.ctx.imageSmoothingQuality = 'high';
                    
                    // 如果是选中的橘子，添加高亮效果
                    if (this.selectedOranges.includes(orange)) {
                        this.ctx.shadowColor = '#FFD700';
                        this.ctx.shadowBlur = 10;
                    }
                    
                    // 使用整数像素位置避免模糊
                    const finalX = Math.round(-orange.width / 2);
                    const finalY = Math.round(-orange.height / 2);
                    const finalWidth = Math.round(orange.width);
                    const finalHeight = Math.round(orange.height);
                    
                    this.ctx.drawImage(
                        this.images.orange,
                        finalX,
                        finalY,
                        finalWidth,
                        finalHeight
                    );
                    
                    this.ctx.restore();
                });

                // 绘制绳子式圈选路径
                if (this.isSelectMode && this.selectionPath.length > 0) {
                    this.ctx.save();
                    
                    if (this.selectedOranges.length === 6) {
                        // 已选中6个橘子，显示绿色
                        this.ctx.strokeStyle = '#4CAF50';
                        this.ctx.fillStyle = 'rgba(76, 175, 80, 0.1)';
                    } else {
                        // 正在选择或选择数量不对，显示橙色
                        this.ctx.strokeStyle = '#FF6B35';
                        this.ctx.fillStyle = 'rgba(255, 107, 53, 0.1)';
                    }
                    
                    this.ctx.lineWidth = 3;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    
                    // 绘制路径填充（如果路径闭合）
                    if (this.selectionPath.length > 2 && !this.isSelecting) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.selectionPath[0].x, this.selectionPath[0].y);
                        for (let i = 1; i < this.selectionPath.length; i++) {
                            this.ctx.lineTo(this.selectionPath[i].x, this.selectionPath[i].y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                    
                    // 绘制路径线条
                    this.ctx.beginPath();
                    if (this.selectionPath.length > 0) {
                        this.ctx.moveTo(this.selectionPath[0].x, this.selectionPath[0].y);
                        for (let i = 1; i < this.selectionPath.length; i++) {
                            this.ctx.lineTo(this.selectionPath[i].x, this.selectionPath[i].y);
                        }
                        
                        // 如果不是正在选择状态，闭合路径
                        if (!this.isSelecting && this.selectionPath.length > 2) {
                            this.ctx.closePath();
                        }
                    }
                    this.ctx.stroke();
                    
                    // 显示选中橘子数量
                    if (this.selectedOranges.length > 0 && this.selectionPath.length > 2) {
                        // 计算路径的中心点来显示文字
                        let centerX = 0, centerY = 0;
                        this.selectionPath.forEach(point => {
                            centerX += point.x;
                            centerY += point.y;
                        });
                        centerX /= this.selectionPath.length;
                        centerY /= this.selectionPath.length;
                        
                        this.ctx.fillStyle = this.selectedOranges.length === 6 ? '#4CAF50' : '#FF6B35';
                        this.ctx.font = 'bold 16px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(
                            `已选择: ${this.selectedOranges.length}/6`,
                            centerX,
                            centerY - 10
                        );
                        this.ctx.textAlign = 'left'; // 重置对齐方式
                    }
                    
                    this.ctx.restore();
                }
            }

            gameLoop() {
                this.updateAnimations();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // 页面加载完成后初始化游戏
        window.addEventListener('load', () => {
            new CanvasDragGame();
        });
    </script>
</body>
</html>