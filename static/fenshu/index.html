<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>分数墙</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* 防止移动端点击闪烁 */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body {
            overflow: hidden;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            /* 防止移动端滚动和缩放 */
            touch-action: manipulation;
        }
        
        #canvas {
            display: block;
            cursor: pointer;
            /* 防止移动端长按选择 */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        .number-panel {
            position: fixed;
            background: white;
            border: 2px solid #ddd;
            border-radius: 12px;
            padding: 15px;
            display: none;
            z-index: 1000;
            box-shadow: 0 8px 24px rgba(0,0,0,0.12);
            min-width: 240px;
        }
        
        .panel-header {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 12px;
        }
        
        .close-btn {
            width: 34px;
            height: 34px;
            border: none;
            background: #f5f5f5;
            color: #666;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            /* 移动端优化 */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .close-btn:hover {
            background: #e0e0e0;
            color: #333;
        }
        
        .number-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }
        
        .undo-btn {
            width: 60px;
            height: 60px;
            aspect-ratio: 1 / 1;
            border: 2px solid #6c757d;
            background: #6c757d;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            /* 移动端优化 */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .undo-btn:hover {
            background: #545b62;
            border-color: #545b62;
            transform: translateY(-1px);
        }
        
        .undo-btn:active {
            transform: translateY(0);
        }
        
        .number-btn {
            width: 60px;
            height: 60px;
            border: 2px solid #ddd;
            background: white;
            color: #333;
            font-size: 28px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            aspect-ratio: 1 / 1;
            /* 移动端优化 */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .number-btn:hover {
            background: #f0f0f0;
            border-color: #bbb;
            transform: translateY(-1px);
        }
        
        .number-btn:active {
            transform: translateY(0);
            background: #e0e0e0;
        }
        
        .ok-btn {
            width: 60px;
            height: 60px;
            aspect-ratio: 1 / 1;
            border: 2px solid #007bff;
            background: #007bff;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            /* 移动端优化 */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .ok-btn:hover {
            background: #0056b3;
            border-color: #0056b3;
            transform: translateY(-1px);
        }
        
        .ok-btn:active {
            transform: translateY(0);
        }
        
        .panel-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 18px;
            color: #333;
        }
        
        .ok-btn {
            background: #007acc !important;
            color: #fff;
        }
        
        .input-box {
            width: 60px;
            height: 60px;
            border: 2px solid #ccc;
            text-align: center;
            font-size: 18px;
            border-radius: 5px;
        }
        
        .control-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 1000;
        }
        
        .swap-btn {
            width: 50px;
            height: 50px;
            border: 2px solid #6c5ce7;
            background: #6c5ce7;
            color: #fff;
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(108, 92, 231, 0.2);
            /* 移动端优化 */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .color-palette {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .color-block {
            width: 45px;
            height: 45px;
            border: 1px solid rgba(255,255,255,0.3);
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.3s ease;
            /* 移动端优化 */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .color-block:hover {
            transform: scale(1.1) translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
            border-color: rgba(255,255,255,0.6);
        }
        
        .color-block.selected,.swap-btn.active {
            border-color: #fff;
            border-width: 4px;
            transform: scale(1.15);
        }
        
        .color-white { background-color: white; }
        .color-blue { background-color: #4285f4; }
        .color-green { background-color: #34a853; }
        .color-orange { background-color: #ff9800; }
        .color-red { background-color: #ea4335; }
        

    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="numberPanel" class="number-panel">
        <div class="panel-header">
            <button class="close-btn" id="closeBtn">×</button>
        </div>
        <div class="number-grid">
            <button class="number-btn" data-value="2">2</button>
            <button class="number-btn" data-value="3">3</button>
            <button class="number-btn" data-value="4">4</button>
            <button class="number-btn" data-value="5">5</button>
            <button class="number-btn" data-value="6">6</button>
            <button class="number-btn" data-value="7">7</button>
            <button class="number-btn" data-value="8">8</button>
            <button class="number-btn" data-value="9">9</button>
            <button class="undo-btn" id="undoBtn">撤销</button>
            <button class="number-btn" data-value="10">10</button>
            <button class="number-btn" data-value="11">11</button>
            <button class="ok-btn" id="okBtn">确定</button>
        </div>
    </div>
    
    <div class="control-panel">
        <button class="swap-btn" id="swapBtn" title="交换位置模式">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
            </svg>
        </button>
        <div class="color-palette">
            <div class="color-block color-blue" data-color="#4285f4" title="蓝色"></div>
            <div class="color-block color-green" data-color="#34a853" title="绿色"></div>
            <div class="color-block color-orange" data-color="#ff9800" title="橙色"></div>
            <div class="color-block color-red" data-color="#ea4335" title="红色"></div>
        </div>
    </div>

    <script>
        class FractionBoard {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.numberPanel = document.getElementById('numberPanel');
                this.rectangles = [];
                this.selectedRect = null;
                this.selectedParts = 1;
                this.currentColor = 'white';
                this.colorMode = false; // 是否处于颜色填充模式，默认关闭
                this.swapMode = false; // 是否处于交换位置模式
                this.animatingRect = null; // 正在动画的长方形
                this.animationId = null; // 动画ID
                this.lastAddedRect = null; // 记录最后添加的长方形，用于撤销
                this.selectedForSwap = null; // 选中用于交换的长方形
                this.swapAnimating = false; // 是否正在进行交换动画
                this.tempHighlightedParts = new Map(); // 存储临时高亮的部分 {rectId: {partIndex: timeoutId}}
                this.tempOriginalColors = new Map(); // 存储临时高亮前的原始颜色
                
                this.initCanvas();
                this.createDefaultRectangle();
                this.bindEvents();
            }
            
            initCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    
                    // 窗口大小改变时重新创建长方形以适应新的宽度
                    this.rectangles = [];
                    this.createDefaultRectangle();
                });
            }
            
            createDefaultRectangle() {
                // 根据窗口宽度动态设置长方形宽度
                let rectWidth;
                if (this.canvas.width > 1000) {
                    rectWidth = 800;
                } else {
                    rectWidth = this.canvas.width * 0.8;
                }
                
                // 高度为浏览器高度的十五分之一
                const rectHeight = this.canvas.height / 18;
                
                const rect = {
                    x: this.canvas.width / 2 - rectWidth / 2,
                    y: 50,
                    width: rectWidth,
                    height: rectHeight,
                    parts: 1,
                    colors: ['white'], // 每个部分的颜色
                    id: Date.now(),
                    isDefault: true // 标识这是默认的第一个长方形
                };
                this.rectangles.push(rect);
                this.draw();
            }
            
            // 判断颜色是否为非白色（需要使用白色文字）
            isNonWhiteColor(color) {
                return color !== 'white' && color !== '#ffffff' && color !== '#FFFFFF';
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.rectangles.forEach(rect => {
                    this.drawRectangle(rect);
                });
            }
            
            drawRectangle(rect) {
                const ctx = this.ctx;
                
                // 设置透明度 - 如果是选中用于交换的长方形，降低透明度
                if (rect === this.selectedForSwap) {
                    ctx.globalAlpha = 0.6;
                } else {
                    ctx.globalAlpha = 1.0;
                }
                
                // 绘制外边框
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                
                // 填充白色背景（对所有长方形）
                ctx.fillStyle = 'white';
                ctx.fillRect(rect.x + 1, rect.y + 1, rect.width - 2, rect.height - 2);
                
                if (rect.parts > 1) {
                    // 绘制分割线和填充颜色
                    const partWidth = rect.width / rect.parts;
                    
                    for (let i = 0; i < rect.parts; i++) {
                        const partX = rect.x + i * partWidth;
                        
                        // 填充颜色
                        if (rect.colors[i] !== 'white') {
                            ctx.fillStyle = rect.colors[i];
                            ctx.fillRect(partX + 1, rect.y + 1, partWidth - 2, rect.height - 2);
                        }
                        
                        // 绘制分割线（除了最后一个部分）
                        if (i < rect.parts - 1) {
                            ctx.strokeStyle = '#333';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(partX + partWidth, rect.y);
                            ctx.lineTo(partX + partWidth, rect.y + rect.height);
                            ctx.stroke();
                        }
                    }
                    
                    // 绘制分数 - 在每个小块中显示对应的分数
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    for (let i = 0; i < rect.parts; i++) {
                        const partX = rect.x + i * partWidth;
                        const partCenterX = partX + partWidth / 2;
                        const partCenterY = rect.y + rect.height / 2;
                        
                        // 根据当前部分的背景色决定文字颜色
                        const partColor = rect.colors[i];
                        const textColor = this.isNonWhiteColor(partColor) ? 'white' : '#000';
                        ctx.fillStyle = textColor;
                        
                        // 动态计算字体大小，基于长方形高度
                        // 分子和分母各占高度的约1/3，留出空间给分数线和间距
                        const maxFontSize = Math.floor(rect.height * 0.4); // 最大字体大小为高度的25%
                        const minFontSize = 14; // 最小字体大小
                        const fontSize = Math.max(minFontSize, maxFontSize);
                        
                        // 计算分数线长度，基于字体大小
                        const lineLength = fontSize;
                        
                        // 计算垂直间距，基于字体大小
                        const verticalSpacing = fontSize * 0.6;
                        
                        // 分子
                        ctx.font = `${fontSize}px Arial`;
                        ctx.fillText('1', partCenterX, partCenterY - verticalSpacing + 2);
                        
                        // 分数线
                        ctx.strokeStyle = textColor;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(partCenterX - lineLength/2, partCenterY);
                        ctx.lineTo(partCenterX + lineLength/2, partCenterY);
                        ctx.stroke();
                        
                        // 分母
                        ctx.font = `${fontSize}px Arial`;
                        ctx.fillText(rect.parts.toString(), partCenterX, partCenterY + verticalSpacing);
                    }
                } else {
                    // 单个部分，显示数字1，字体大小也动态调整
                    // 根据背景色决定文字颜色
                    const backgroundColor = rect.colors[0];
                    const textColor = this.isNonWhiteColor(backgroundColor) ? 'white' : '#000';
                    ctx.fillStyle = textColor;
                    
                    // 动态计算字体大小，基于长方形高度
                    const maxFontSize = Math.floor(rect.height); // 单个数字可以更大，占高度的60%
                    const minFontSize = 14; // 最小字体大小
                    const fontSize = Math.max(minFontSize, Math.min(maxFontSize, 36)); // 限制在14-36px之间
                    
                    ctx.font = `${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('1', rect.x + rect.width / 2, rect.y + rect.height / 2);
                }
                
                // 重置透明度
                ctx.globalAlpha = 1.0;
            }
            
            isPointInRectangle(x, y, rect) {
                return x >= rect.x && x <= rect.x + rect.width &&
                       y >= rect.y && y <= rect.y + rect.height;
            }
            
            showNumberPanel(x, y, rect) {
                this.selectedRect = rect;
                this.numberPanel.style.left = (x-140) + 'px';
                this.numberPanel.style.top = (y+20) + 'px';
                this.numberPanel.style.display = 'block';
                
                // 确保面板不会超出屏幕
                const panelRect = this.numberPanel.getBoundingClientRect();
                if (panelRect.right > window.innerWidth) {
                    this.numberPanel.style.left = (window.innerWidth - panelRect.width - 10) + 'px';
                }
                if (panelRect.bottom > window.innerHeight) {
                    this.numberPanel.style.top = (window.innerHeight - panelRect.height - 10) + 'px';
                }
            }
            
            hideNumberPanel() {
                this.numberPanel.style.display = 'none';
                this.selectedRect = null;
            }
            
            findNextPosition() {
                // 找到所有长方形的最低位置
                let maxY = 50; // 默认起始位置
                this.rectangles.forEach(rect => {
                    if (rect !== this.animatingRect) { // 排除正在动画的长方形
                        maxY = Math.max(maxY, rect.y + rect.height);
                    }
                });
                return maxY + 20; // 添加10px间距
            }
            
            animateRectangle(rect, targetY) {
                const startY = rect.y;
                const distance = targetY - startY;
                const duration = 1000; // 增加动画持续时间到1秒
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // 使用更平滑的缓动函数（ease-in-out）
                    const easeInOut = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    rect.y = startY + distance * easeInOut;
                    
                    this.draw();
                    
                    if (progress < 1) {
                        this.animationId = requestAnimationFrame(animate);
                    } else {
                        // 动画完成
                        this.animatingRect = null;
                        this.animationId = null;
                    }
                };
                
                this.animatingRect = rect;
                animate();
            }
             
            divideRectangle(parts) {
                if (this.selectedRect && parts > 0) {
                    // 停止任何正在进行的动画
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                        this.animatingRect = null;
                        this.animationId = null;
                    }
                    
                    // 计算标准高度（与默认长方形一致）
                    const standardHeight = this.canvas.height / 18;
                    
                    // 克隆当前长方形
                    const newRect = {
                        x: this.selectedRect.x,
                        y: this.selectedRect.y, // 初始位置与原长方形相同
                        width: this.selectedRect.width,
                        height: standardHeight, // 使用标准高度
                        parts: parts,
                        colors: new Array(parts).fill('white'),
                        id: Date.now()
                        // 注意：克隆的长方形没有isDefault属性
                    };
                    
                    // 记录最后添加的长方形
                    this.lastAddedRect = newRect;
                    
                    // 添加到数组
                    this.rectangles.push(newRect);
                    
                    // 计算目标位置并开始动画
                    const targetY = this.findNextPosition();
                    this.animateRectangle(newRect, targetY);
                    
                    // 隐藏数字面板
                    this.hideNumberPanel();
                }
            }
            
            getPartIndex(x, y, rect) {
                if (!this.isPointInRectangle(x, y, rect) || rect.parts <= 1) {
                    return -1;
                }
                const partWidth = rect.width / rect.parts;
                const relativeX = x - rect.x;
                return Math.floor(relativeX / partWidth);
            }
            
            fillPart(rect, partIndex, color) {
                if (rect && rect.colors && partIndex >= 0 && partIndex < rect.parts) {
                    // 如果当前部分已经是选中的颜色，则切换回白色
                    if (rect.colors[partIndex] === color) {
                        rect.colors[partIndex] = 'white';
                    } else {
                        rect.colors[partIndex] = color;
                    }
                    this.draw();
                }
            }
            
            // 临时高亮部分（橙色填充，白色文字，3秒后恢复）
            tempHighlightPart(rect, partIndex) {
                if (!rect || !rect.colors || partIndex < 0 || partIndex >= rect.parts) {
                    return;
                }
                
                const rectId = rect.id;
                const partKey = `${rectId}_${partIndex}`;
                
                // 如果这个部分已经在临时高亮中，清除之前的定时器
                if (this.tempHighlightedParts.has(partKey)) {
                    clearTimeout(this.tempHighlightedParts.get(partKey));
                }
                
                // 保存原始颜色
                this.tempOriginalColors.set(partKey, rect.colors[partIndex]);
                
                // 设置临时橙色
                rect.colors[partIndex] = '#ff9800';
                this.draw();
                
                // 设置3秒后恢复的定时器
                const timeoutId = setTimeout(() => {
                    // 恢复原始颜色
                    const originalColor = this.tempOriginalColors.get(partKey);
                    if (originalColor !== undefined && rect.colors) {
                        rect.colors[partIndex] = originalColor;
                        this.draw();
                    }
                    
                    // 清理记录
                    this.tempHighlightedParts.delete(partKey);
                    this.tempOriginalColors.delete(partKey);
                }, 3000);
                
                // 记录定时器ID
                this.tempHighlightedParts.set(partKey, timeoutId);
            }
            
            undoLastRectangle() {
                if (this.lastAddedRect) {
                    // 停止任何正在进行的动画
                    if (this.animationId && this.animatingRect === this.lastAddedRect) {
                        cancelAnimationFrame(this.animationId);
                        this.animatingRect = null;
                        this.animationId = null;
                    }
                    
                    // 从数组中移除最后添加的长方形
                    const index = this.rectangles.indexOf(this.lastAddedRect);
                    if (index > -1) {
                        this.rectangles.splice(index, 1);
                    }
                    
                    // 清除记录
                    this.lastAddedRect = null;
                    
                    // 重新绘制
                    this.draw();
                    
                    // 隐藏数字面板
                    this.hideNumberPanel();
                }
            }
            
            
            swapRectangles(rect1, rect2) {
                if (this.swapAnimating || !rect1 || !rect2 || rect1 === rect2) {
                    return;
                }
                
                this.swapAnimating = true;
                
                // 保存原始位置
                const startY1 = rect1.y;
                const startY2 = rect2.y;
                const targetY1 = startY2;
                const targetY2 = startY1;
                
                // 动画参数
                let progress = 0;
                const duration = 500; // 动画持续时间（毫秒）
                const startTime = Date.now();
                
                const animate = () => {
                    const currentTime = Date.now();
                    progress = Math.min((currentTime - startTime) / duration, 1);
                    
                    // 使用缓动函数
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    
                    // 更新位置
                    rect1.y = startY1 + (targetY1 - startY1) * easeProgress;
                    rect2.y = startY2 + (targetY2 - startY2) * easeProgress;
                    
                    // 重新绘制
                    this.draw();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // 动画完成，确保位置精确
                        rect1.y = targetY1;
                        rect2.y = targetY2;
                        
                        // 在rectangles数组中交换位置
                        const index1 = this.rectangles.indexOf(rect1);
                        const index2 = this.rectangles.indexOf(rect2);
                        if (index1 !== -1 && index2 !== -1) {
                            this.rectangles[index1] = rect2;
                            this.rectangles[index2] = rect1;
                        }
                        
                        this.swapAnimating = false;
                        this.selectedForSwap = null;
                        this.draw();
                    }
                };
                
                animate();
            }
            
            bindEvents() {
                // Canvas 点击和触摸事件
                const handleInteraction = (e) => {
                    // 防止默认行为和事件冒泡
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const rect = this.canvas.getBoundingClientRect();
                    let x, y;
                    
                    // 处理触摸和鼠标事件
                    if (e.type === 'touchstart' || e.type === 'touchend') {
                        if (e.touches && e.touches.length > 0) {
                            x = e.touches[0].clientX - rect.left;
                            y = e.touches[0].clientY - rect.top;
                        } else if (e.changedTouches && e.changedTouches.length > 0) {
                            x = e.changedTouches[0].clientX - rect.left;
                            y = e.changedTouches[0].clientY - rect.top;
                        } else {
                            return;
                        }
                    } else {
                        x = e.clientX - rect.left;
                        y = e.clientY - rect.top;
                    }
                    
                    // 检查是否点击了某个长方形
                    for (let rectangle of this.rectangles) {
                        if (this.isPointInRectangle(x, y, rectangle)) {
                            // 如果处于颜色模式且长方形已分割，则填充颜色
                            if (this.colorMode && rectangle.parts > 1) {
                                const partIndex = this.getPartIndex(x, y, rectangle);
                                if (partIndex >= 0) {
                                    this.fillPart(rectangle, partIndex, this.currentColor);
                                }
                            } 
                            // 如果处于交换模式且是非默认长方形，处理选择和交换逻辑
                            else if (this.swapMode && !rectangle.isDefault && !this.swapAnimating) {
                                if (this.selectedForSwap === null) {
                                    // 第一次点击，选中长方形
                                    this.selectedForSwap = rectangle;
                                    this.draw(); // 重新绘制以显示透明度变化
                                } else if (this.selectedForSwap === rectangle) {
                                    // 点击同一个长方形，取消选择
                                    this.selectedForSwap = null;
                                    this.draw();
                                } else {
                                    // 点击不同的长方形，执行交换
                                    this.swapRectangles(this.selectedForSwap, rectangle);
                                }
                            }
                            // 如果是默认长方形，显示数字面板
                            else if (rectangle.isDefault) {
                                this.showNumberPanel(e.clientX || e.changedTouches[0].clientX, 
                                                   e.clientY || e.changedTouches[0].clientY, rectangle);
                            }
                            // 非交换状态，非填充颜色状态下，点击克隆平均分后的小块，实现临时填充橙色
                            else if (!this.swapMode && !this.colorMode && rectangle.parts > 1 && !rectangle.isDefault) {
                                const partIndex = this.getPartIndex(x, y, rectangle);
                                if (partIndex >= 0) {
                                    this.tempHighlightPart(rectangle, partIndex);
                                }
                            }
                            return;
                        }
                    }
                };
                
                // 绑定鼠标事件
                this.canvas.addEventListener('click', handleInteraction);
                
                // 绑定触摸事件（移动端）
                this.canvas.addEventListener('touchend', handleInteraction, { passive: false });
                
                // 防止触摸时的默认行为
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                }, { passive: false });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                }, { passive: false });
                

                
                // 数字按钮点击事件处理函数
                const handleNumberButtonClick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const value = e.target.getAttribute('data-value');
                    if (value && value !== '') {
                        this.selectedParts = parseInt(value);
                        // 重置所有按钮的样式
                        document.querySelectorAll('.number-btn').forEach(b => {
                            b.style.background = '#fff';
                            b.style.color = '#333';
                        });
                        // 高亮选中的按钮
                        e.target.style.background = '#007acc';
                        e.target.style.color = 'white';
                    }
                };
                
                // 为数字按钮绑定点击和触摸事件
                document.querySelectorAll('.number-btn').forEach(btn => {
                    // 鼠标点击事件
                    btn.addEventListener('click', handleNumberButtonClick);
                    
                    // 触摸事件支持
                    btn.addEventListener('touchend', (e) => {
                        // 防止触摸后触发click事件导致重复执行
                        e.preventDefault();
                        handleNumberButtonClick(e);
                    }, { passive: false });
                    
                    // 防止触摸时的默认行为
                    btn.addEventListener('touchstart', (e) => {
                        e.stopPropagation();
                    }, { passive: false });
                });
                
                // OK 按钮事件处理函数
                const handleOkButtonClick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.divideRectangle(this.selectedParts);
                };
                
                // 为OK按钮绑定点击和触摸事件
                const okBtn = document.getElementById('okBtn');
                okBtn.addEventListener('click', handleOkButtonClick);
                okBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleOkButtonClick(e);
                }, { passive: false });
                okBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                }, { passive: false });
                
                // 关闭按钮事件处理函数
                const handleCloseButtonClick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.hideNumberPanel();
                };
                
                // 为关闭按钮绑定点击和触摸事件
                const closeBtn = document.getElementById('closeBtn');
                closeBtn.addEventListener('click', handleCloseButtonClick);
                closeBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleCloseButtonClick(e);
                }, { passive: false });
                closeBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                }, { passive: false });
                
                // 撤销按钮事件处理函数
                const handleUndoButtonClick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.undoLastRectangle();
                };
                
                // 为撤销按钮绑定点击和触摸事件
                const undoBtn = document.getElementById('undoBtn');
                undoBtn.addEventListener('click', handleUndoButtonClick);
                undoBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleUndoButtonClick(e);
                }, { passive: false });
                undoBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                }, { passive: false });
                
                // 点击面板外部关闭面板
                const handleOutsideClick = (e) => {
                    // 防止在触摸设备上的重复触发
                    if (e.type === 'touchend') {
                        e.preventDefault();
                    }
                    
                    if (!this.numberPanel.contains(e.target) && e.target !== this.canvas) {
                        this.hideNumberPanel();
                    }
                };
                
                document.addEventListener('click', handleOutsideClick);
                document.addEventListener('touchend', handleOutsideClick, { passive: false });
                
                // 交换按钮事件处理函数
                const handleSwapButtonClick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // 切换交换模式
                    this.swapMode = !this.swapMode;
                    
                    // 更新按钮样式
                    const swapBtn = document.getElementById('swapBtn');
                    if (this.swapMode) {
                        swapBtn.classList.add('active');
                        this.canvas.style.cursor = 'pointer';
                        // 关闭颜色模式
                        this.colorMode = false;
                        // 移除所有颜色块的选中状态，不再默认选中白色
                        document.querySelectorAll('.color-block').forEach(b => b.classList.remove('selected'));
                        this.currentColor = 'white';
                    } else {
                        swapBtn.classList.remove('active');
                        this.canvas.style.cursor = 'default';
                        // 清除选中的交换长方形
                        this.selectedForSwap = null;
                        this.draw();
                    }
                };
                
                // 为交换按钮绑定点击和触摸事件
                const swapBtn = document.getElementById('swapBtn');
                swapBtn.addEventListener('click', handleSwapButtonClick);
                swapBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleSwapButtonClick(e);
                }, { passive: false });
                swapBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                }, { passive: false });
                
                // 颜色选择器事件处理函数
                const handleColorBlockClick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // 检查当前点击的颜色块是否已经选中
                    const isCurrentlySelected = e.target.classList.contains('selected');
                    
                    // 移除所有颜色块的选中状态
                    document.querySelectorAll('.color-block').forEach(b => b.classList.remove('selected'));
                    
                    if (isCurrentlySelected) {
                        // 如果当前颜色块已经选中，则取消选中状态
                        this.colorMode = false;
                        this.currentColor = null;
                        // 恢复默认鼠标样式
                        this.canvas.style.cursor = 'pointer';
                    } else {
                        // 如果当前颜色块未选中，则选中它
                        e.target.classList.add('selected');
                        // 更新当前颜色
                        this.currentColor = e.target.getAttribute('data-color');
                        // 启用颜色模式，关闭交换模式
                        this.colorMode = true;
                        this.swapMode = false;
                        // 更新按钮状态
                        document.getElementById('swapBtn').classList.remove('active');
                        // 清除选中的交换长方形
                        this.selectedForSwap = null;
                        // 更新鼠标样式
                        this.canvas.style.cursor = 'crosshair';
                    }
                    
                    this.draw();
                };
                
                // 为颜色选择器绑定点击和触摸事件
                document.querySelectorAll('.color-block').forEach(block => {
                    // 鼠标点击事件
                    block.addEventListener('click', handleColorBlockClick);
                    
                    // 触摸事件支持
                    block.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        handleColorBlockClick(e);
                    }, { passive: false });
                    
                    // 防止触摸时的默认行为
                    block.addEventListener('touchstart', (e) => {
                        e.stopPropagation();
                    }, { passive: false });
                });
            }
        }
        
        // 初始化应用
        window.addEventListener('DOMContentLoaded', () => {
            new FractionBoard();
        });
    </script>
</body>
</html>