<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>月历壁纸</title>
    <style>
/* Apple Grey-White Metallic Aesthetic */
:root {
    --bg: #f5f5f7;
    --surface: #ffffff;
    --text: #1d1d1f;
    --text-secondary: #6e6e73;
    --border: #d2d2d7;
    --accent: #0c5ec4;
    --shadow-sm: 0 2px 8px rgba(0,0,0,0.06);
    --shadow-md: 0 10px 28px rgba(0,0,0,0.12);
    --metal-gradient: linear-gradient(180deg, #fcfcfd 0%, #f5f5f7 40%, #eeeff2 100%);
    --metal-shine: radial-gradient(120% 120% at 50% -20%, rgba(255,255,255,0.75) 0%, rgba(255,255,255,0) 60%);
}

/* General Body Styles */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'SF Pro Display', 'Helvetica Neue', Arial, sans-serif;
    background-color: var(--bg);
    color: var(--text);
    margin: 0;
    padding: 20px;
    display: flex;
    justify-content: center;
    min-height: 100vh;
    box-sizing: border-box;
}

/* Preview Container */
.preview-container {
    width: 100%;
    max-width: 420px;
    height: 88vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 2px;
    box-sizing: border-box;
    position: relative;
    overflow: hidden;
}

#wallpaper-canvas {
    max-width: 100%;
    max-height: 100%;
    border-radius: 20px;
    border: 1px solid var(--border);
    box-shadow: var(--shadow-sm);
}

/* Floating Controls Panel */
.floating-controls {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 500px;
    background-color: rgba(255, 255, 255, 0.65);
    backdrop-filter: blur(16px);
    border: 1px solid var(--border);
    border-radius: 16px;
    box-shadow: var(--shadow-md);
    z-index: 1000;
    overflow: hidden;
    transition: all 0.3s ease;
}

.controls-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 20px;
    border-bottom: 1px solid var(--border);
}

.controls-header button {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--accent);
    font-size: 18px;
    cursor: pointer;
    padding: 8px 12px;
    border-radius: 10px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
    transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
}

.controls-header button:hover {
    background: linear-gradient(180deg, #ffffff 0%, #f3f4f6 100%);
    border-color: #bcbcc4;
}

.controls-header button:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
}

#controls-panel {
    padding: 20px;
    display: none; /* Hidden by default */
    flex-direction: column;
    gap: 20px;
}

.control-section {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.control-section h3 {
    margin: 0;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.control-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 15px;
}

.control-row label {
    font-size: 15px;
    color: var(--text-secondary);
}

/* Input Styles */
input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 60%;
    height: 26px; /* 提高整体高度以居中拇指 */
    background: transparent; /* 用轨道元素渲染背景 */
    border-radius: 999px;
    outline: none;
    transition: opacity 0.2s;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: var(--surface);
    cursor: pointer;
    border-radius: 50%;
    border: 1px solid #bcbcc4;
    box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    margin-top: -6px; /* 修复小圆点垂直错位 */
}

input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: var(--surface);
    cursor: pointer;
    border-radius: 50%;
    border: 1px solid #bcbcc4;
    box-shadow: 0 2px 4px rgba(0,0,0,0.08);
}

input[type="range"]::-webkit-slider-runnable-track {
    height: 8px;
    background: #e5e5ea;
    border-radius: 999px;
}

input[type="range"]::-moz-range-track {
    height: 8px;
    background: #e5e5ea;
    border-radius: 999px;
}

.theme-toggle-button {
    background-color: var(--surface);
    color: var(--text);
    border: 1px solid var(--border);
    padding: 10px 15px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: background-color 0.2s ease, border-color 0.2s ease;
}

.theme-toggle-button:hover {
    background-color: #f3f4f6;
    border-color: #bcbcc4;
}

.theme-toggle-button.active {
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 0 0 3px rgba(0,122,255,0.15);
}

.theme-selector {
    display: flex;
    gap: 10px;
}

.theme-swatch {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: pointer;
    border: 1px solid var(--border);
    background: var(--surface);
    box-shadow: var(--shadow-sm);
    transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
}

.theme-swatch:hover {
    transform: scale(1.06);
    box-shadow: 0 4px 14px rgba(0,0,0,0.12);
}

.theme-swatch.active {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(0,122,255,0.2);
}
.field{
    margin: 10px 0;
}
/* Responsive Design */
@media (max-width: 600px) {
    body {
        padding: 10px;
    }

    .floating-controls {
        bottom: 15px;
        width: calc(100% - 20px);
    }

    .controls-header {
        padding: 10px 15px;
    }

    #controls-panel {
        padding: 15px;
    }
}
    </style>
</head>
<body>
    <main class="preview-container">
        <canvas id="wallpaper-canvas"></canvas>
    </main>

    <div class="floating-controls">
        <input type="file" id="bg-upload" accept="image/*" hidden>
        <div class="controls-header">
            <button id="upload-btn">上传</button>
            <button id="toggle-controls-btn">设置</button>
            <button id="download-btn">下载</button>
        </div>
        <div class="controls-panel card" id="controls-panel">
            <div class="group">

                <!-- 第二行：文字颜色单独一行 -->
                <div class="field">
                    <div id="text-color-selector" class="theme-selector" style="margin-top:8px;"></div>
                </div>
                <!-- 第一行：左侧紧凑/宽松；中间数字字号 -->
                <div class="field" style="display:flex; gap:16px; justify-content:space-between; align-items:flex-start;">
                    <div style="flex:1; min-width: 0;">
                        <div class="density-group" style="display:flex; gap:8px; margin-top:8px;">
                            <button id="density-compact" class="theme-toggle-button">紧凑</button>
                            <button id="density-comfort" class="theme-toggle-button">宽松</button>
                        </div>
                    </div>
                    <div style="flex:1; min-width: 0;">
                        <div class="density-group" style="display:flex; gap:8px; margin-top:8px;">
                            <button id="number-small" class="theme-toggle-button">小号</button>
                            <button id="number-large" class="theme-toggle-button">大号</button>
                        </div>
                    </div>
                </div>
                <!-- 新增：周起始与表头 -->
                <div class="field">
                    <div class="density-group" style="display:flex; gap:8px; margin-top:8px;">
                        <button id="week-sunday" class="theme-toggle-button">周日起</button>
                        <button id="week-monday" class="theme-toggle-button">周一起</button>
                        <button id="week-header-hide" class="theme-toggle-button">隐藏周</button>
                        <button id="pure-text-btn" class="theme-toggle-button">隐背景</button>
                    </div>
                </div>
                <!-- 第三行：竖屏比例按钮 -->
                <div class="field">
                    <div id="ratio-selector" class="theme-selector" style="margin-top:8px;"></div>
                </div>
                <!-- 第四行：透明度设置 -->
                <div class="field">
                    <div class="control-row">
                        <div style="flex:1; min-width: 0;">
                            <label for="bg-mask-opacity">背景遮罩透明度</label>
                            <input type="range" id="bg-mask-opacity" min="0" max="1" step="0.05" value="0.1">
                        </div>
                        <div style="flex:1; min-width: 0;">
                            <label for="calendar-bg-opacity">月历背景透明度</label>
                            <input type="range" id="calendar-bg-opacity" min="0" max="1" step="0.05" value="0.2">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
document.addEventListener('DOMContentLoaded', () => {
    const el = (id) => document.getElementById(id);

    const canvas = el('wallpaper-canvas');
    if (!canvas) {
        console.error('Canvas element not found!');
        return;
    }
    const ctx = canvas.getContext('2d');

    const controls = {
        bgUpload: el('bg-upload'),
        uploadBtn: el('upload-btn'),
        toggleControlsBtn: el('toggle-controls-btn'),
        downloadBtn: el('download-btn'),
        controlsPanel: el('controls-panel'),
        bgMaskOpacity: el('bg-mask-opacity'),
        calendarBgOpacity: el('calendar-bg-opacity'),
        pureTextBtn: el('pure-text-btn'),
        weekSunday: el('week-sunday'),
        weekMonday: el('week-monday'),
        weekHeaderHide: el('week-header-hide'),
        densityCompact: el('density-compact'),
        densityComfort: el('density-comfort'),
        numberSmall: el('number-small'),
        numberLarge: el('number-large'),
        textColorSelector: el('text-color-selector'),
        ratioSelector: el('ratio-selector'),
    };

    const themes = [
        { name: 'Default', accentColor: '#007AFF', textColor: '#FFFFFF', weekendColor: '#FFFFFF' },
    ];

    const state = {
        bgImage: null,
        bgPreset: 'silver-gradient',
        ratio: '9:19.5',
        exportWidth: 1170,
        weekStart: 'sunday',
        ...themes[0],
        boxOpacity: 0.1,
        month: new Date().getMonth(),
        year: new Date().getFullYear(),
        calendarX: 10,
        calendarY: 50,
        calendarScale: 0.65,
        cornerRadius: 48,
        bgOffscreen: null,
        compactMode: false,
        dayNumberMode: 'large',
        hasAutoPlaced: false,
        bgScale: 1,
        bgOffsetX: 0,
        bgOffsetY: 0,
        bgMaskOpacity: 0.1,
        pureTextMode: false,
        hideWeekHeader: false,
    };

    let swatches = [];

    const textColors = [
        { name: '白色', value: '#FFFFFF' },
        { name: '黑色', value: '#000000' },
        { name: '棕色', value: '#8B4513' },
        { name: '橙色', value: '#FF9500' },
        { name: '绿色', value: '#34C759' },
        { name: '蓝色', value: '#007AFF' },
        { name: '红色', value: '#FF3B30' },
        { name: '紫色', value: '#AF52DE' },
        { name: '黄色', value: '#FFD60A' }
    ];

    function updateState(newState) {
        Object.assign(state, newState);
        render();
    }

    function render() {
        adjustCanvasSize();
        drawBackground();
        ensureDefaultPlacement();
        drawCalendar();
    }

    function ensureDefaultPlacement() {
        if (state.hasAutoPlaced) return;
        const calendarWidth = (canvas.width * 0.9) * state.calendarScale;
        const cellWidth = calendarWidth / 7;
        const densityRatio = state.compactMode ? 0.65 : 0.78;
        const cellHeight = cellWidth * densityRatio;
        const rows = computeCalendarData(state.year, state.month, state.weekStart).length - (state.hideWeekHeader ? 1 : 0);
        const calendarHeight = cellHeight * rows;
        const margin = Math.round(canvas.width * 0.04);
        state.calendarX = canvas.width - calendarWidth - margin;
        state.calendarY = margin;
        state.hasAutoPlaced = true;
    }

    function adjustCanvasSize() {
        const [width, height] = state.ratio.split(':').map(Number);
        const container = canvas.parentElement;
        const containerRatio = container.clientWidth / container.clientHeight;
        const imageRatio = width / height;

        if (containerRatio > imageRatio) {
            canvas.style.height = '100%';
            canvas.style.width = 'auto';
        } else {
            canvas.style.width = '100%';
            canvas.style.height = 'auto';
        }
    }

    function drawBackground() {
        const [ratioWidth, ratioHeight] = state.ratio.split(':').map(Number);
        canvas.width = state.exportWidth;
        canvas.height = Math.round(state.exportWidth * (ratioHeight / ratioWidth));

        // Prepare offscreen background canvas for localized blur in glass effect.
        if (!state.bgOffscreen) {
            state.bgOffscreen = document.createElement('canvas');
        }
        state.bgOffscreen.width = canvas.width;
        state.bgOffscreen.height = canvas.height;
        const bctx = state.bgOffscreen.getContext('2d');
        bctx.clearRect(0, 0, canvas.width, canvas.height);

        if (state.bgImage) {
            const img = state.bgImage;
            const scale = state.bgScale || 1;
            const sw = img.width * scale;
            const sh = img.height * scale;
            const dx = (canvas.width - sw) / 2 + state.bgOffsetX;
            const dy = (canvas.height - sh) / 2 + state.bgOffsetY;
            bctx.drawImage(img, dx, dy, sw, sh);
        } else {
            drawPresetBackground(bctx);
        }

        // Draw non-blurred background onto main canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(state.bgOffscreen, 0, 0);

        // 背景遮罩（全屏叠加）
        if (state.bgMaskOpacity && state.bgMaskOpacity > 0) {
            ctx.save();
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = `rgba(0,0,0,${Math.min(1, Math.max(0, state.bgMaskOpacity))})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
        }
    }

    function drawPresetBackground(targetCtx = ctx) {
        if (state.bgPreset === 'silver-gradient') {
            const grd = targetCtx.createLinearGradient(0, 0, 0, canvas.height);
            grd.addColorStop(0.0, '#d8dbe0');
            grd.addColorStop(0.35, '#e4e6ea');
            grd.addColorStop(0.7, '#eceef1');
            grd.addColorStop(1.0, '#f7f8fa');
            targetCtx.fillStyle = grd;
            targetCtx.fillRect(0, 0, canvas.width, canvas.height);
            return;
        }
        const gradient = {
            gradient1: ['#434343', '#000000'],
            gradient2: ['#2c3e50', '#3498db'],
            gradient3: ['#1A2980', '#26D0CE'],
            gradient4: ['#FF512F', '#DD2476'],
        }[state.bgPreset];
        if (gradient) {
            const grd = targetCtx.createLinearGradient(0, 0, 0, canvas.height);
            grd.addColorStop(0, gradient[0]);
            grd.addColorStop(1, gradient[1]);
            targetCtx.fillStyle = grd;
        } else {
            targetCtx.fillStyle = state.bgPreset === 'solid-white' ? '#FFFFFF' : '#000000';
        }
        targetCtx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function computeCalendarData(year, month, weekStart) {
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const firstDay = new Date(year, month, 1).getDay();
        const data = [];
        const weekDays = weekStart === 'monday' ? ['一', '二', '三', '四', '五', '六', '日'] : ['日', '一', '二', '三', '四', '五', '六'];
        data.push(weekDays);
        let currentDay = 1;
        const offset = weekStart === 'monday' ? (firstDay + 6) % 7 : firstDay;
        for (let i = 0; i < 6; i++) {
            const week = [];
            for (let j = 0; j < 7; j++) {
                if (i === 0 && j < offset) {
                    week.push('');
                } else if (currentDay <= daysInMonth) {
                    week.push(currentDay++);
                } else {
                    week.push('');
                }
            }
            data.push(week);
            if (currentDay > daysInMonth) break;
        }
        return data;
    }

    function drawCalendar() {
        const { year, month, weekStart, textColor, boxOpacity, calendarX, calendarY, calendarScale, compactMode } = state;
        const calendarData = computeCalendarData(year, month, weekStart);

        const calendarWidth = (canvas.width * 0.9) * calendarScale;
        const cellWidth = calendarWidth / 7;
        const densityRatio = compactMode ? 0.65 : 0.78;
        const cellHeight = cellWidth * densityRatio;
        const rowsCount = calendarData.length - (state.hideWeekHeader ? 1 : 0);
        const calendarHeight = cellHeight * rowsCount;

        const x = calendarX;
        const y = calendarY;

        if (!state.pureTextMode) {
            // Apple liquid glass box: localized background blur within rounded rectangle
            ctx.save();
            drawRoundRect(ctx, x, y, calendarWidth, calendarHeight, state.cornerRadius);
            ctx.clip();
            if (state.bgOffscreen) {
                ctx.filter = 'blur(12px)';
                ctx.drawImage(state.bgOffscreen, 0, 0);
                ctx.filter = 'none';
            }
            ctx.restore();

            // Translucent white fill for glass
            const glassAlpha = Math.min(0.55, Math.max(0.1, boxOpacity));
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = `rgba(255,255,255,${glassAlpha})`;
            drawRoundRect(ctx, x, y, calendarWidth, calendarHeight, state.cornerRadius);
            ctx.fill();

            // Subtle highlight gradient (top shine)
            const shine = ctx.createLinearGradient(x, y, x, y + calendarHeight);
            shine.addColorStop(0, 'rgba(255,255,255,0.65)');
            shine.addColorStop(0.4, 'rgba(255,255,255,0.12)');
            shine.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = shine;
            drawRoundRect(ctx, x, y, calendarWidth, calendarHeight, state.cornerRadius);
            ctx.fill();

            // Soft shadow to match draggable box style
            ctx.save();
            ctx.shadowColor = 'rgba(0,0,0,0.25)';
            ctx.shadowBlur = Math.max(6, canvas.width * 0.008);
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = Math.max(1, canvas.height * 0.002);
            ctx.fillStyle = 'rgba(0,0,0,0)';
            drawRoundRect(ctx, x, y, calendarWidth, calendarHeight, state.cornerRadius);
            ctx.fill();
            ctx.restore();
        }


        const fontSize = Math.floor(cellWidth / (compactMode ? 2.5 : 2.1));
        ctx.font = `${fontSize}px -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // 字体大小：小/大号与表头比例
        const baseFontSize2 = Math.floor(cellWidth / (compactMode ? 2.5 : 2.1));
        const dayScale = state.dayNumberMode === 'small' ? 0.9 : 1.15;
        const headerScale = 0.9;
        const fontFamily = '-apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", Arial, sans-serif';
        const fontHeader = `${Math.floor(baseFontSize2 * headerScale)}px ${fontFamily}`;
        const fontDay = `${Math.floor(baseFontSize2 * dayScale)}px ${fontFamily}`;
        calendarData.forEach((week, rowIndex) => {
            if (rowIndex === 0 && state.hideWeekHeader) return;
            ctx.font = rowIndex === 0 ? fontHeader : fontDay;
            week.forEach((day, colIndex) => {
                const cellX = x + colIndex * cellWidth + cellWidth / 2;
                const visibleIndex = state.hideWeekHeader ? rowIndex - 1 : rowIndex;
                const cellY = y + visibleIndex * cellHeight + cellHeight / 2;

                ctx.fillStyle = textColor;
                ctx.fillText(day.toString(), cellX, cellY);
            });
        });
    }

    function drawRoundRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
    }

    function sampleEdgeRGBA(bctx, x, y, width, height, side) {
        let sx = 0, sy = 0;
        if (side === 'top') {
            sx = Math.round(x + width / 2);
            sy = Math.round(y - 1);
        } else if (side === 'bottom') {
            sx = Math.round(x + width / 2);
            sy = Math.round(y + height + 1);
        } else if (side === 'left') {
            sx = Math.round(x - 1);
            sy = Math.round(y + height / 2);
        } else if (side === 'right') {
            sx = Math.round(x + width + 1);
            sy = Math.round(y + height / 2);
        }
        if (sx < 0 || sy < 0 || sx >= canvas.width || sy >= canvas.height) {
            return null;
        }
        try {
            const d = bctx.getImageData(sx, sy, 1, 1).data;
            return `rgba(${d[0]}, ${d[1]}, ${d[2]}, 0.85)`;
        } catch (e) {
            return null;
        }
    }

    function getEventPosition(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        if (e.touches) {
            return {
                x: (e.touches[0].clientX - rect.left) * scaleX,
                y: (e.touches[0].clientY - rect.top) * scaleY,
            };
        }
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY,
        };
    }

    function isPointerOverCalendar(x, y) {
        const { calendarX, calendarY, calendarScale, compactMode, year, month, weekStart } = state;
        const calendarWidth = (canvas.width * 0.9) * calendarScale;
        const cellWidth = calendarWidth / 7;
        const densityRatio = compactMode ? 0.65 : 0.78;
        const cellHeight = cellWidth * densityRatio;
        const rows = computeCalendarData(year, month, weekStart).length - (state.hideWeekHeader ? 1 : 0);
        const calendarHeight = cellHeight * rows;
        return x >= calendarX && x <= calendarX + calendarWidth && y >= calendarY && y <= calendarY + calendarHeight;
    }

    function createTextColorSwatches() {
        const selector = controls.textColorSelector;
        if (!selector) return;
        selector.innerHTML = '';
        swatches = [];
        textColors.forEach((tc) => {
            const swatch = document.createElement('div');
            swatch.className = 'theme-swatch';
            swatch.style.backgroundColor = tc.value;
            swatch.title = tc.name;
            swatch.addEventListener('click', () => {
                updateState({ textColor: tc.value });
                swatches.forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
            });
            selector.appendChild(swatch);
            swatches.push(swatch);
        });
        // 初始选中当前文字颜色最接近的色块
        const initialIndex = textColors.findIndex(c => c.value.toLowerCase() === state.textColor.toLowerCase());
        if (initialIndex >= 0 && swatches[initialIndex]) {
            swatches[initialIndex].classList.add('active');
        }
    }

    function setupEventListeners() {
        controls.uploadBtn.addEventListener('click', () => {
            controls.bgUpload.click();
        });

        controls.bgUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // 初始缩放为 cover，居中显示
                        const coverScale = Math.max(canvas.width / img.width, canvas.height / img.height);
                        updateState({ bgImage: img, bgScale: coverScale, bgOffsetX: 0, bgOffsetY: 0 });
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // 月历背景透明度（玻璃背景）
        if (controls.calendarBgOpacity) {
            controls.calendarBgOpacity.addEventListener('input', (e) => {
                updateState({ boxOpacity: parseFloat(e.target.value) });
            });
            state.boxOpacity = parseFloat(controls.calendarBgOpacity.value || state.boxOpacity);
        }

        // 背景遮罩透明度（全屏遮罩）
        if (controls.bgMaskOpacity) {
            controls.bgMaskOpacity.addEventListener('input', (e) => {
                updateState({ bgMaskOpacity: parseFloat(e.target.value) });
            });
            state.bgMaskOpacity = parseFloat(controls.bgMaskOpacity.value || state.bgMaskOpacity);
        }

        // 纯文字无背景模式切换
        if (controls.pureTextBtn) {
            const updatePureTextActive = () => {
                controls.pureTextBtn.classList.toggle('active', state.pureTextMode === true);
            };
            controls.pureTextBtn.addEventListener('click', () => {
                updateState({ pureTextMode: !state.pureTextMode });
                updatePureTextActive();
            });
            updatePureTextActive();
        }

        // 周起始切换
        if (controls.weekSunday && controls.weekMonday) {
            const updateWeekStartActive = () => {
                controls.weekSunday.classList.toggle('active', state.weekStart === 'sunday');
                controls.weekMonday.classList.toggle('active', state.weekStart === 'monday');
            };
            controls.weekSunday.addEventListener('click', () => {
                updateState({ weekStart: 'sunday', hasAutoPlaced: false });
                updateWeekStartActive();
            });
            controls.weekMonday.addEventListener('click', () => {
                updateState({ weekStart: 'monday', hasAutoPlaced: false });
                updateWeekStartActive();
            });
            updateWeekStartActive();
        }

        // 隐藏/显示星期表头
        if (controls.weekHeaderHide) {
            const updateHideHeaderActive = () => {
                controls.weekHeaderHide.classList.toggle('active', state.hideWeekHeader === true);
            };
            controls.weekHeaderHide.addEventListener('click', () => {
                updateState({ hideWeekHeader: !state.hideWeekHeader, hasAutoPlaced: false });
                updateHideHeaderActive();
            });
            updateHideHeaderActive();
        }

        // 密度双按钮：同时显示并高亮当前选择
        if (controls.densityCompact && controls.densityComfort) {
            const updateActive = () => {
                controls.densityCompact.classList.toggle('active', state.compactMode === true);
                controls.densityComfort.classList.toggle('active', state.compactMode === false);
            };
            controls.densityCompact.addEventListener('click', () => {
                updateState({ compactMode: true });
                updateActive();
            });
            controls.densityComfort.addEventListener('click', () => {
                updateState({ compactMode: false });
                updateActive();
            });
            updateActive();
        }

        // 数字字号双按钮：同时显示并高亮当前选择
        if (controls.numberSmall && controls.numberLarge) {
            const updateNumberActive = () => {
                controls.numberSmall.classList.toggle('active', state.dayNumberMode === 'small');
                controls.numberLarge.classList.toggle('active', state.dayNumberMode === 'large');
            };
            controls.numberSmall.addEventListener('click', () => {
                updateState({ dayNumberMode: 'small' });
                updateNumberActive();
            });
            controls.numberLarge.addEventListener('click', () => {
                updateState({ dayNumberMode: 'large' });
                updateNumberActive();
            });
            updateNumberActive();
        }

        let isDraggingCal = false;
        let isDraggingBG = false;
        let dragStartX, dragStartY;
        let initialCalendarX, initialCalendarY;
        let initialBgOffsetX, initialBgOffsetY;

        canvas.addEventListener('mousedown', (e) => {
            const { x, y } = getEventPosition(e);
            if (isPointerOverCalendar(x, y)) {
                isDraggingCal = true;
                dragStartX = x;
                dragStartY = y;
                initialCalendarX = state.calendarX;
                initialCalendarY = state.calendarY;
                canvas.style.cursor = 'grabbing';
            } else {
                isDraggingBG = true;
                dragStartX = x;
                dragStartY = y;
                initialBgOffsetX = state.bgOffsetX;
                initialBgOffsetY = state.bgOffsetY;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDraggingCal) {
                const { x, y } = getEventPosition(e);
                const dx = x - dragStartX;
                const dy = y - dragStartY;
                updateState({ calendarX: initialCalendarX + dx, calendarY: initialCalendarY + dy });
            } else if (isDraggingBG) {
                const { x, y } = getEventPosition(e);
                const dx = x - dragStartX;
                const dy = y - dragStartY;
                updateState({ bgOffsetX: initialBgOffsetX + dx, bgOffsetY: initialBgOffsetY + dy });
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDraggingCal = false;
            isDraggingBG = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isDraggingCal = false;
            isDraggingBG = false;
            canvas.style.cursor = 'default';
        });

        canvas.addEventListener('wheel', (e) => {
            const { x, y } = getEventPosition(e);
            const scaleAmount = e.deltaY * -0.001;
            if (isPointerOverCalendar(x, y)) {
                e.preventDefault();
                updateState({ calendarScale: Math.max(0.5, Math.min(3, state.calendarScale + scaleAmount)) });
            } else {
                e.preventDefault();
                const nextScale = Math.max(0.2, Math.min(5, state.bgScale + scaleAmount));
                updateState({ bgScale: nextScale });
            }
        });

        let initialDistance = -1;
        let initialDistanceBG = -1;

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                const { x, y } = getEventPosition(e);
                if (isPointerOverCalendar(x, y)) {
                    isDraggingCal = true;
                    dragStartX = x;
                    dragStartY = y;
                    initialCalendarX = state.calendarX;
                    initialCalendarY = state.calendarY;
                } else {
                    isDraggingBG = true;
                    dragStartX = x;
                    dragStartY = y;
                    initialBgOffsetX = state.bgOffsetX;
                    initialBgOffsetY = state.bgOffsetY;
                }
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const rect = canvas.getBoundingClientRect();
                const cx = ((e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left) * (canvas.width / rect.width);
                const cy = ((e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top) * (canvas.height / rect.height);
                if (isPointerOverCalendar(cx, cy)) {
                    initialDistance = dist;
                    initialDistanceBG = -1;
                } else {
                    initialDistanceBG = dist;
                    initialDistance = -1;
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDraggingCal && e.touches.length === 1) {
                const { x, y } = getEventPosition(e);
                const dx = x - dragStartX;
                const dy = y - dragStartY;
                updateState({ calendarX: initialCalendarX + dx, calendarY: initialCalendarY + dy });
            } else if (isDraggingBG && e.touches.length === 1) {
                const { x, y } = getEventPosition(e);
                const dx = x - dragStartX;
                const dy = y - dragStartY;
                updateState({ bgOffsetX: initialBgOffsetX + dx, bgOffsetY: initialBgOffsetY + dy });
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (initialDistance > 0) {
                    const scaleAmount = (distance - initialDistance) * 0.01;
                    updateState({ calendarScale: Math.max(0.5, Math.min(3, state.calendarScale + scaleAmount)) });
                    initialDistance = distance;
                } else if (initialDistanceBG > 0) {
                    const scaleAmount = (distance - initialDistanceBG) * 0.01;
                    const nextScale = Math.max(0.2, Math.min(5, state.bgScale + scaleAmount));
                    updateState({ bgScale: nextScale });
                    initialDistanceBG = distance;
                }
            }
        });

        canvas.addEventListener('touchend', (e) => {
            isDraggingCal = false;
            isDraggingBG = false;
            initialDistance = -1;
            initialDistanceBG = -1;
        });

        controls.downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `月历壁纸-${state.year}-${state.month + 1}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        const toggleBtn = el('toggle-controls-btn');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', () => {
                const panel = controls.controlsPanel;
                const isHidden = panel.style.display === 'none' || panel.style.display === '';
                panel.style.display = isHidden ? 'flex' : 'none';
                toggleBtn.textContent = isHidden ? '收起' : '设置';
            });
        }

        window.addEventListener('resize', render);
    }

    function createRatioButtons() {
        const container = controls.ratioSelector;
        if (!container) return;
        container.innerHTML = '';
        const portraitRatios = ['9:19.5', '9:20', '9:16', '3:4', '2:3'];
        const buttons = [];
        portraitRatios.forEach((r) => {
            const btn = document.createElement('button');
            btn.className = 'theme-toggle-button';
            btn.textContent = r;
            btn.addEventListener('click', () => {
                // 切换比例时，如有背景图则重算 cover 缩放并重置偏移
                const [rw, rh] = r.split(':').map(Number);
                const newW = state.exportWidth;
                const newH = Math.round(state.exportWidth * (rh / rw));
                if (state.bgImage) {
                    const coverScale = Math.max(newW / state.bgImage.width, newH / state.bgImage.height);
                    updateState({ ratio: r, hasAutoPlaced: false, bgScale: coverScale, bgOffsetX: 0, bgOffsetY: 0 });
                } else {
                    updateState({ ratio: r, hasAutoPlaced: false });
                }
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
            container.appendChild(btn);
            buttons.push(btn);
        });
        const idx = portraitRatios.indexOf(state.ratio);
        if (idx >= 0) buttons[idx].classList.add('active');
    }

    // Initial setup
    window.onload = () => {
        createTextColorSwatches();
        createRatioButtons();
        setupEventListeners();
        render();
    };
});
    </script>
</body>
</html>