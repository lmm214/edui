<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŠåœ†æ»šåŠ¨äº’åŠ¨æ¼”ç¤º</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .container {
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            width: 98vw;
            height: 98vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-sizing: border-box;
        }
        h1 { 
            color: #333; 
            margin: 5px 0; 
            font-size: 1.5rem;
        }
        .phase-indicator {
            font-weight: bold;
            color: #007bff;
            height: 30px;
            line-height: 30px;
            font-size: 1.2rem;
            margin-bottom: 5px;
        }
        .canvas-wrapper {
            position: relative;
            flex-grow: 1; 
            width: 100%;
            overflow: hidden;
            border: 1px solid #ddd;
            background: #fff;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
            background: linear-gradient(to bottom, #ffffff 80%, #f2f2f2 100%);
        }
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            padding: 10px 0;
            width: 100%;
            background: #fff;
        }
        button {
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.2s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        button.reset { background-color: #6c757d; }
        button.reset:hover { background-color: #545b62; }
        
        /* æ”¾å¤§æ¨¡å¼æŒ‰é’®æ ·å¼ */
        button.zoom-btn { background-color: #17a2b8; }
        button.zoom-btn:hover { background-color: #138496; }

        input[type=range] {
            width: 40%;
            max-width: 500px;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>åŠçƒå½¢å·¥ä»¶è¿åŠ¨è½¨è¿¹æ¼”ç¤º</h1>
    <div class="phase-indicator" id="phaseText">å‡†å¤‡å¼€å§‹</div>

    <div class="canvas-wrapper">
        <canvas id="simCanvas"></canvas>
    </div>

    <div class="controls">
        <button id="btnPlay">â–¶ æ’­æ”¾</button>
        <button id="btnReset" class="reset">â†º é‡ç½®</button>
        <input type="range" id="progressSlider" min="0" max="1000" value="0">
        <button id="btnZoom" class="zoom-btn">ğŸ” æ”¾å¤§å‰ä¸¤æ­¥</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const btnPlay = document.getElementById('btnPlay');
    const btnReset = document.getElementById('btnReset');
    const btnZoom = document.getElementById('btnZoom');
    const slider = document.getElementById('progressSlider');
    const phaseText = document.getElementById('phaseText');

    // --- ç‰©ç†å‚æ•° (ç±³) ---
    const R_METER = 3; 
    const SLIDE_DIST_METER = 24;

    // å„é˜¶æ®µè·ç¦»
    const DIST_P1 = (Math.PI * R_METER / 2); // æ»šåŠ¨
    const DIST_P2 = (Math.PI * R_METER / 2); // ç¿»è½¬
    const DIST_P3 = SLIDE_DIST_METER;      // å¹³ç§»
    
    const TOTAL_DIST_FULL = DIST_P1 + DIST_P2 + DIST_P3;
    const TOTAL_DIST_ZOOM = DIST_P1 + DIST_P2; // æ”¾å¤§æ¨¡å¼åªçœ‹å‰ä¸¤æ­¥

    // --- åŠ¨ç”»çŠ¶æ€ ---
    let isPlaying = false;
    let isZoomMode = false; // æ˜¯å¦å¤„äºæ”¾å¤§æ¨¡å¼
    let progress = 0; // 0 ~ 1 (æ³¨æ„ï¼šåœ¨æ”¾å¤§æ¨¡å¼ä¸‹ï¼Œ1ä»£è¡¨P2ç»“æŸ)
    let animationId;
    let autoPausePoint = 0; 

    // --- ç»˜å›¾å‚æ•° ---
    let SCALE = 1; 
    let GROUND_Y = 0;
    let START_X = 0;
    let DPR = 1; 

    const PATH_COLORS = ['#ff7f0e', '#2ca02c', '#1f77b4']; 

    // --- æ ¸å¿ƒï¼šå“åº”å¼å¸ƒå±€ä¸æ¨¡å¼åˆ‡æ¢ ---
    function resizeCanvas() {
        const wrapper = canvas.parentElement;
        DPR = window.devicePixelRatio || 1;
        
        const logicalWidth = wrapper.clientWidth;
        const logicalHeight = wrapper.clientHeight;

        canvas.width = logicalWidth * DPR;
        canvas.height = logicalHeight * DPR;
        canvas.style.width = logicalWidth + 'px';
        canvas.style.height = logicalHeight + 'px';

        ctx.scale(DPR, DPR);

        const horizontalPadding = 40; 
        const verticalPadding = 60;

        // å†³å®šå½“å‰è¦æ˜¾ç¤ºçš„æ€»è·ç¦»
        // æ”¾å¤§æ¨¡å¼ï¼šåªæ˜¾ç¤º P1 + P2
        // å…¨æ™¯æ¨¡å¼ï¼šæ˜¾ç¤º P1 + P2 + P3
        const distToShow = isZoomMode ? TOTAL_DIST_ZOOM : TOTAL_DIST_FULL;

        // ç¼“å†²åŒºè®¡ç®— (ä¿è¯å·¦å³ä¸åˆ‡è¾¹)
        const START_BUFFER = R_METER + 1.5; 
        const END_BUFFER = R_METER + 1.5;
        
        const totalMetersNeeded = START_BUFFER + distToShow + END_BUFFER;

        // è®¡ç®— Scale
        SCALE = (logicalWidth - horizontalPadding * 2) / totalMetersNeeded;
        
        // é™åˆ¶ Scaleï¼Œé¿å…æå€¼
        SCALE = Math.min(Math.max(SCALE, 10), 150); // æ”¾å¤§ä¸Šé™æé«˜åˆ°150

        START_X = horizontalPadding + (START_BUFFER * SCALE); 
        GROUND_Y = logicalHeight - verticalPadding - (R_METER * SCALE); 
        
        update(); 
    }

    // åˆ‡æ¢æ”¾å¤§/å…¨æ™¯æ¨¡å¼
    btnZoom.addEventListener('click', () => {
        isZoomMode = !isZoomMode;
        
        // åˆ‡æ¢æ–‡æ¡ˆ
        if (isZoomMode) {
            btnZoom.innerText = "ğŸ”­ æŸ¥çœ‹å®Œæ•´æ­¥éª¤";
            // åˆ‡æ¢åˆ°æ”¾å¤§æ¨¡å¼æ—¶ï¼Œå¦‚æœè¿›åº¦å·²ç»åœ¨P2ä¹‹åï¼Œé‡ç½®
            if (progress * TOTAL_DIST_FULL > TOTAL_DIST_ZOOM) {
                progress = 0;
                autoPausePoint = 0;
                slider.value = 0;
            }
        } else {
            btnZoom.innerText = "ğŸ” æ”¾å¤§å‰ä¸¤æ­¥";
            progress = 0; // åˆ‡æ¢æ¨¡å¼é‡ç½®ï¼Œä½“éªŒæ›´ä½³
            autoPausePoint = 0;
            slider.value = 0;
        }
        
        isPlaying = false;
        btnPlay.disabled = false;
        cancelAnimationFrame(animationId);
        
        resizeCanvas();
    });

    function drawSemicircle(x, y, rotation, opacity = 1, isGhost = false) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        const rPx = R_METER * SCALE;

        ctx.beginPath();
        ctx.arc(0, 0, rPx, 0, Math.PI);
        ctx.closePath();

        if (isGhost) {
            ctx.setLineDash([5, 5]); 
            ctx.strokeStyle = `rgba(100, 100, 100, ${opacity})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        } else {
            ctx.fillStyle = `rgba(230, 240, 255, ${opacity})`;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // ç›´å¾„
        ctx.beginPath();
        ctx.moveTo(-rPx, 0);
        ctx.lineTo(rPx, 0);
        ctx.lineWidth = 2;
        if(isGhost) {
             ctx.strokeStyle = `rgba(100, 100, 100, ${opacity})`;
             ctx.setLineDash([5, 5]);
        } else {
            ctx.strokeStyle = '#333';
            ctx.setLineDash([]); 
        }
        ctx.stroke();

        // åœ†å¿ƒç‚¹
        ctx.beginPath();
        ctx.arc(0, 0, isZoomMode ? 6 : 4, 0, Math.PI * 2); // æ”¾å¤§æ¨¡å¼ç‚¹å¤§ä¸€ç‚¹
        ctx.fillStyle = isGhost ? `rgba(255, 0, 0, ${opacity})` : 'red';
        ctx.fill();

        ctx.restore();
    }

    function getCenterPosition(totalMeters) {
        let centerX, centerY, rotation;
        let rPx = R_METER * SCALE;

        if (totalMeters <= DIST_P1) {
            // P1: æ»šåŠ¨
            centerX = START_X + (totalMeters * SCALE); 
            centerY = GROUND_Y - rPx;
            rotation = totalMeters / DIST_P1 * (Math.PI / 2); 
        } else if (totalMeters <= (DIST_P1 + DIST_P2)) {
            // P2: ç¿»è½¬
            let distInPhase = totalMeters - DIST_P1;
            let p = distInPhase / DIST_P2;
            let angle = p * (Math.PI / 2);
            let pivotX = START_X + DIST_P1 * SCALE;
            centerX = pivotX + rPx * Math.sin(angle);
            centerY = GROUND_Y - rPx * Math.cos(angle);
            rotation = (Math.PI / 2) + angle;
        } else {
            // P3: å¹³ç§»
            let distInPhase = totalMeters - (DIST_P1 + DIST_P2);
            let startSlideX = (START_X + DIST_P1 * SCALE) + rPx;
            centerX = startSlideX + distInPhase * SCALE;
            centerY = GROUND_Y;
            rotation = Math.PI; 
        }
        return { x: centerX, y: centerY, rotation: rotation };
    }

    let pathPoints = [];
    function generatePath(maxMeters) {
        pathPoints = [];
        const step = 0.05; 
        let currentMeters = 0;
        
        // é™åˆ¶æœ€å¤§ç”Ÿæˆè·ç¦»ï¼Œé¿å…æ”¾å¤§æ¨¡å¼ç”»å‡ºå¤šä½™çš„çº¿
        let limit = isZoomMode ? Math.min(maxMeters, TOTAL_DIST_ZOOM) : Math.min(maxMeters, TOTAL_DIST_FULL);

        while (currentMeters <= limit && currentMeters <= DIST_P1) {
            pathPoints.push({ ...getCenterPosition(currentMeters), segment: 0 });
            currentMeters += step;
        }
        while (currentMeters <= limit && currentMeters <= DIST_P1 + DIST_P2) {
            pathPoints.push({ ...getCenterPosition(currentMeters), segment: 1 });
            currentMeters += step;
        }
        // å¦‚æœä¸æ˜¯æ”¾å¤§æ¨¡å¼ï¼Œç»§ç»­è®¡ç®— P3
        if (!isZoomMode) {
            while (currentMeters <= limit) {
                pathPoints.push({ ...getCenterPosition(currentMeters), segment: 2 });
                currentMeters += step;
            }
        }
        // è¡¥ç‚¹
        if (currentMeters > limit && pathPoints.length > 0) {
             // ç®€å•è¡¥æœ€åä¸€ä¸ªç‚¹
             pathPoints.push({ ...getCenterPosition(limit), segment: limit > DIST_P1 + DIST_P2 ? 2 : (limit > DIST_P1 ? 1 : 0) });
        }
    }

    function update() {
        const logicalWidth = canvas.width / DPR;
        const logicalHeight = canvas.height / DPR;
        ctx.clearRect(0, 0, logicalWidth, logicalHeight);

        // --- 1. åœ°é¢ ---
        ctx.beginPath();
        ctx.moveTo(0, GROUND_Y);
        ctx.lineTo(logicalWidth, GROUND_Y);
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.stroke();

        // å½“å‰æœ€å¤§è·ç¦»å–å†³äºæ¨¡å¼
        const maxDist = isZoomMode ? TOTAL_DIST_ZOOM : TOTAL_DIST_FULL;
        let currentTotalMeters = progress * maxDist;
        
        // --- æ–‡å­—æ›´æ–° ---
        if (currentTotalMeters <= DIST_P1) phaseText.innerText = "1. æ— æ»‘åŠ¨æ»šåŠ¨ (åœ†å¿ƒæ°´å¹³ç§»åŠ¨)";
        else if (currentTotalMeters <= (DIST_P1 + DIST_P2)) phaseText.innerText = "2. ç»•æ£±è§’ç¿»è½¬ (åœ†å¿ƒå¼§çº¿è¿åŠ¨)";
        else phaseText.innerText = "3. è´´åœ°å¹³ç§» (åœ†å¿ƒæ°´å¹³ç§»åŠ¨)";
        
        if(progress >= 1) phaseText.innerText = "æ¼”ç¤ºç»“æŸ";

        // --- 2. è™šçº¿ Ghosts (åº•å±‚) ---
        let startPos = getCenterPosition(0);
        drawSemicircle(startPos.x, startPos.y, startPos.rotation, 0.3, true);
        
        // P1 ç»“æŸè™šçº¿
        if (currentTotalMeters >= DIST_P1) {
            let p1End = getCenterPosition(DIST_P1);
            drawSemicircle(p1End.x, p1End.y, p1End.rotation, 0.3, true);
        }
        
        // P2 ç»“æŸè™šçº¿ (ä»»ä½•æ¨¡å¼éƒ½æ˜¾ç¤º)
        if (currentTotalMeters >= (DIST_P1 + DIST_P2)) {
            let p2End = getCenterPosition(DIST_P1 + DIST_P2);
            drawSemicircle(p2End.x, p2End.y, p2End.rotation, 0.3, true);
        }

        // P3 ç»“æŸè™šçº¿ (ä»…å…¨æ™¯æ¨¡å¼)
        if (!isZoomMode && currentTotalMeters >= TOTAL_DIST_FULL) {
            let finalPos = getCenterPosition(TOTAL_DIST_FULL);
            drawSemicircle(finalPos.x, finalPos.y, finalPos.rotation, 0.3, true);
        }

        // --- 3. å®ä½“ ---
        let curPos = getCenterPosition(currentTotalMeters);
        drawSemicircle(curPos.x, curPos.y, curPos.rotation);

        // --- 4. è½¨è¿¹ (é¡¶å±‚) ---
        generatePath(currentTotalMeters);

        if (pathPoints.length > 0) {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            let currentSegment = pathPoints[0].segment;
            ctx.beginPath();
            ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
            ctx.strokeStyle = PATH_COLORS[currentSegment];
            ctx.lineWidth = isZoomMode ? 6 : 4; // æ”¾å¤§æ¨¡å¼è½¨è¿¹æ›´ç²—

            for (let i = 1; i < pathPoints.length; i++) {
                if (pathPoints[i].segment !== currentSegment) {
                    ctx.stroke(); 
                    ctx.beginPath(); 
                    ctx.moveTo(pathPoints[i-1].x, pathPoints[i-1].y);
                    currentSegment = pathPoints[i].segment;
                    ctx.strokeStyle = PATH_COLORS[currentSegment];
                }
                ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
            }
            ctx.stroke(); 
        }
    }

    function loop() {
        if (isPlaying) {
            // åŠ¨æ€é€Ÿåº¦ï¼šä¿è¯åœ¨å±å¹•ä¸Šç§»åŠ¨çš„è§†è§‰é€Ÿåº¦ä¸€è‡´
            // å…¨æ™¯å¤§çº¦33ç±³ï¼Œæ”¾å¤§æ¨¡å¼å¤§çº¦9.4ç±³ã€‚
            // ä¸ºäº†è®©æ”¾å¤§æ¨¡å¼çœ‹èµ·æ¥æ…¢ä¸€ç‚¹ã€ç»†è‡´ä¸€ç‚¹ï¼Œå¯ä»¥é™ä½ç›¸å¯¹é€Ÿåº¦
            const totalM = isZoomMode ? TOTAL_DIST_ZOOM : TOTAL_DIST_FULL;
            const baseSpeed = isZoomMode ? 0.03 : 0.06; 
            let speedStep = baseSpeed / totalM; 

            progress += speedStep;
            
            let currentMeters = progress * totalM;
            
            // è‡ªåŠ¨æš‚åœé€»è¾‘
            if (autoPausePoint === 0 && currentMeters >= DIST_P1) {
                progress = DIST_P1 / totalM;
                isPlaying = false;
                btnPlay.disabled = false;
                autoPausePoint = 1;
            } else if (autoPausePoint === 1 && currentMeters >= (DIST_P1 + DIST_P2)) {
                progress = (DIST_P1 + DIST_P2) / totalM;
                isPlaying = false;
                btnPlay.disabled = false;
                autoPausePoint = 2;
                
                // å¦‚æœæ˜¯æ”¾å¤§æ¨¡å¼ï¼Œåˆ°è¿™é‡Œå°±ç»“æŸäº†
                if (isZoomMode) {
                   progress = 1;
                   autoPausePoint = 3; // End
                }

            } else if (autoPausePoint === 2 && !isZoomMode && progress >= 1) {
                progress = 1;
                isPlaying = false;
                btnPlay.disabled = false;
                autoPausePoint = 3; 
            }

            slider.value = progress * 1000;
            update();
            
            if (isPlaying && progress < 1) {
                animationId = requestAnimationFrame(loop);
            } else if (progress >= 1) {
                isPlaying = false;
                btnPlay.disabled = false;
                update(); // ç¡®ä¿æœ€åä¸€å¸§æ¸²æŸ“
            }
        }
    }

    btnPlay.addEventListener('click', () => {
        if (progress >= 1) { 
            progress = 0;
            autoPausePoint = 0;
        }
        isPlaying = true;
        btnPlay.disabled = true;
        loop();
    });

    btnReset.addEventListener('click', () => {
        isPlaying = false;
        btnPlay.disabled = false;
        cancelAnimationFrame(animationId);
        progress = 0;
        slider.value = 0;
        autoPausePoint = 0;
        phaseText.innerText = "å‡†å¤‡å¼€å§‹";
        update();
    });

    slider.addEventListener('input', (e) => {
        isPlaying = false;
        btnPlay.disabled = false;
        cancelAnimationFrame(animationId);
        progress = e.target.value / 1000;
        
        const totalM = isZoomMode ? TOTAL_DIST_ZOOM : TOTAL_DIST_FULL;
        let m = progress * totalM;

        // é‡ç½®æš‚åœç‚¹é€»è¾‘
        if (m < DIST_P1) autoPausePoint = 0;
        else if (m < (DIST_P1 + DIST_P2)) autoPausePoint = 1;
        else if (!isZoomMode && progress < 1) autoPausePoint = 2;
        else autoPausePoint = 3;

        update();
    });

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); 
</script>

</body>
</html>