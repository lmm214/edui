
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é•¿æ–¹å½¢ä¸­æœ‰ä¸¤æ¡å°è·¯</title>
    <style>
        :root {
            --bg-color: #f2f4f2;
            --stroke-color: #000000;
            --fill-color: #C8E6C9;
            --highlight-color: #FFE0B2;
            --ghost-fill: #e8eee8;
            --ghost-stroke: #cccccc;
        }
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #container {
            width: 90vw;
            height: 90vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        svg {
            width: 100%;
            height: auto;
            max-width: 600px; 
            aspect-ratio: 24 / 18;
            touch-action: none;
            background: #ffffff;
            border: 1px solid #ddd;
            box-shadow: 0 10px 40px rgba(0,0,0,0.08);
            user-select: none;
        }
        .piece {
            cursor: grab;
            stroke-linejoin: round;
            stroke-linecap: round;
            transition: fill 0.2s ease, opacity 0.2s;
        }
        .piece:active {
            cursor: grabbing;
        }
        .piece.dragging {
            fill: var(--highlight-color) !important;
            opacity: 0.95;
            stroke-width: 1px !important; /* å¼ºåˆ¶ä¿æŒ 1px è¾¹æ¡† */
            /* ç§»é™¤äº† drop-shadow é˜´å½± */
        }
        .ghost {
            pointer-events: none;
            fill: var(--ghost-fill);
            stroke: var(--ghost-stroke);
            stroke-width: 1;
        }
        
        /* é€šé“æ§åˆ¶æ ·å¼ */
        .channel-control {
            fill: #ffffff; /* ç™½è‰²å¡«å…… */
            transition: fill 0.2s;
        }
        .channel-control:hover {
            fill: #f9f9f9; /* æ‚¬åœæ—¶å¾®å¾®å˜ç°æç¤ºå¯æ“ä½œ */
        }
        .channel-control:active {
            fill: #f0f0f0;
        }
        /* ç«–å‘é€šé“åªèƒ½å·¦å³ç§»åŠ¨ */
        #channel-v {
            cursor: ew-resize;
        }
        /* æ–œå‘é€šé“æ ¹æ®ä½ç½®ä¸åŒæœ‰ä¸åŒå…‰æ ‡ */
        #channel-d {
            cursor: move;
        }
        
        /* å¸®åŠ©æŒ‰é’®æ ·å¼ */
        #help-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid var(--fill-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: var(--fill-color);
            transition: all 0.3s ease;
            z-index: 1000;
            -webkit-user-select: none;
            user-select: none;
        }
        #help-btn:hover {
            background: var(--fill-color);
            color: #ffffff;
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }
        #help-btn:active {
            transform: scale(0.95);
        }
        
        /* å¸®åŠ©å¼¹çª—æ ·å¼ */
        #help-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
        }
        #help-modal.show {
            display: flex;
        }
        .modal-content {
            background: #ffffff;
            border-radius: 16px;
            padding: 32px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            position: relative;
            animation: modalSlideIn 0.3s ease;
        }
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 2px solid var(--fill-color);
        }
        .modal-title {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin: 0;
        }
        .close-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #f5f5f5;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #666;
            transition: all 0.2s;
        }
        .close-btn:hover {
            background: #e0e0e0;
            color: #333;
        }
        .modal-body {
            color: #555;
            line-height: 1.8;
        }
        .modal-body h3 {
            color: #FF5600;
            font-size: 18px;
            margin: 20px 0 12px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .modal-body p {
            margin: 8px 0;
            padding-left: 8px;
        }
        .modal-body ul {
            margin: 8px 0;
            padding-left: 24px;
        }
        .modal-body li {
            margin: 6px 0;
        }
        .highlight {
            color: var(--fill-color);
            font-weight: 600;
        }
    </style>
</head>
<body>

<!-- å¸®åŠ©æŒ‰é’® -->
<button id="help-btn" title="ä½¿ç”¨è¯´æ˜">?</button>

<!-- å¸®åŠ©å¼¹çª— -->
<div id="help-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title">ğŸ“ ä½¿ç”¨è¯´æ˜</h2>
            <button class="close-btn" id="close-modal">Ã—</button>
        </div>
        <div class="modal-body">
            <h3>ğŸ® æ“ä½œæ–¹æ³•</h3>
            <ul>
                <li><span class="highlight">æ‹–åŠ¨ç«–å‘é€šé“</span>ï¼ˆç™½è‰²ç«–æ¡ï¼‰ï¼šå·¦å³ç§»åŠ¨æ”¹å˜ä½ç½®</li>
                <li><span class="highlight">æ‹–åŠ¨æ–œå‘é€šé“</span>ï¼ˆç™½è‰²æ–œæ¡ï¼‰ï¼š
                    <ul>
                        <li>ç‚¹å‡»ä¸­é—´åŒºåŸŸï¼šæ•´ä½“ä¸Šä¸‹å¹³ç§»</li>
                        <li>ç‚¹å‡»å·¦ä¾§/å³ä¾§ï¼šæ—‹è½¬è°ƒæ•´è§’åº¦</li>
                    </ul>
                </li>
                <li><span class="highlight">æ‹–åŠ¨ç»¿è‰²ç¢ç‰‡</span>ï¼šè‡ªç”±ç§»åŠ¨å››å—è‰åœ°ï¼Œè§‚å¯Ÿå®ƒä»¬å¦‚ä½•æ‹¼åˆ</li>
            </ul>
            
            <h3>ğŸ’¡ æ•™å­¦è¦ç‚¹</h3>
            <p>é€šè¿‡åŠ¨æ‰‹æ“ä½œï¼Œå­¦ç”Ÿèƒ½å‘ç°ï¼š<span class="highlight">æ— è®ºé€šé“æ€ä¹ˆç§»åŠ¨ï¼Œå››å—è‰åœ°æ€»èƒ½å®Œç¾æ‹¼æˆä¸€ä¸ªå›ºå®šå¤§å°çš„é•¿æ–¹å½¢</span>ã€‚</p>
        </div>
    </div>
</div>

<div id="container">
    <svg viewBox="0 0 240 180" id="canvas">
        
        <!-- åº•å±‚å‚è€ƒå›¾ -->
        <g id="ghost-layer"></g>

        <!-- æ§åˆ¶å±‚ (æ”¾åœ¨ä¸­é—´ï¼Œä½œä¸ºèƒŒæ™¯äº¤äº’å±‚ï¼Œä½†åœ¨ Piece ä¸‹é¢) -->
        <g id="controls-layer">
            <!-- ä¸¤ä¸ªç™½è‰²é€šé“ -->
            <polygon id="channel-v" class="channel-control" />
            <polygon id="channel-d" class="channel-control" />
        </g>
        
        <!-- åŠ¨æ€ç¢ç‰‡å±‚ (æœ€ä¸Šå±‚) -->
        <g id="piece-layer"></g>
        
    </svg>
</div>

<script>
{
    const svg = document.getElementById('canvas');
    const pieceLayer = document.getElementById('piece-layer');
    const ghostLayer = document.getElementById('ghost-layer');
    
    // å¼•ç”¨é€šé“å…ƒç´ 
    const channelV = document.getElementById('channel-v');
    const channelD = document.getElementById('channel-d');
    
    // --- å‡ ä½•å¸¸é‡ ---
    const W = 240;
    const H = 180;
    const CHANNEL_WIDTH = 20; // é€šé“å›ºå®šç‰©ç†å®½åº¦
    const HALF_W = CHANNEL_WIDTH / 2;

    // --- çŠ¶æ€æ•°æ® ---
    // å‚ç›´é€šé“ï¼ˆChannel Vï¼‰
    const stateV = { topX: 120, btmX: 120 };
    
    // æ–œå‘é€šé“ï¼ˆChannel Dï¼‰
    const stateD = { leftY: 70, rightY: 110 };

    // ç¢ç‰‡æ•°æ®
    let pieces = [];
    const pieceIds = ['tl', 'tr', 'bl', 'br'];

    // --- æ ¸å¿ƒå‡ ä½•ç®—æ³• ---

    const getChannelEdges = (x1, y1, x2, y2, halfWidth) => {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const len = Math.sqrt(dx*dx + dy*dy);
        const nx = -dy / len;
        const ny = dx / len;
        const ox = nx * halfWidth;
        const oy = ny * halfWidth;
        
        return {
            edge1: { x1: x1 + ox, y1: y1 + oy, x2: x2 + ox, y2: y2 + oy }, 
            edge2: { x1: x1 - ox, y1: y1 - oy, x2: x2 - ox, y2: y2 - oy } 
        };
    };

    const intersect = (l1, l2) => {
        const x1 = l1.x1, y1 = l1.y1, x2 = l1.x2, y2 = l1.y2;
        const x3 = l2.x1, y3 = l2.y1, x4 = l2.x2, y4 = l2.y2;
        
        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        if (denom === 0) return {x:0, y:0};
        
        const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
        return {
            x: x1 + ua * (x2 - x1),
            y: y1 + ua * (y2 - y1)
        };
    };

    const getBoundaryPt = (line, boundaryType, val) => {
        if (boundaryType === 'y') { 
            if (line.y2 === line.y1) return {x: line.x1, y: val};
            const t = (val - line.y1) / (line.y2 - line.y1);
            return { x: line.x1 + t * (line.x2 - line.x1), y: val };
        } else {
             if (line.x2 === line.x1) return {x: val, y: line.y1};
             const t = (val - line.x1) / (line.x2 - line.x1);
             return { x: val, y: line.y1 + t * (line.y2 - line.y1) };
        }
    };

    const calculateGeometry = () => {
        const edgesV = getChannelEdges(stateV.topX, 0, stateV.btmX, H, HALF_W);
        const edgesD = getChannelEdges(0, stateD.leftY, W, stateD.rightY, HALF_W);

        const p_cross_tl = intersect(edgesV.edge1, edgesD.edge2);
        const p_cross_tr = intersect(edgesV.edge2, edgesD.edge2);
        const p_cross_bl = intersect(edgesV.edge1, edgesD.edge1);
        const p_cross_br = intersect(edgesV.edge2, edgesD.edge1);

        const rawPoints = {};
        rawPoints.tl = [{x:0, y:0}, getBoundaryPt(edgesV.edge1, 'y', 0), p_cross_tl, getBoundaryPt(edgesD.edge2, 'x', 0)];
        rawPoints.tr = [getBoundaryPt(edgesV.edge2, 'y', 0), {x:W, y:0}, getBoundaryPt(edgesD.edge2, 'x', W), p_cross_tr];
        rawPoints.bl = [getBoundaryPt(edgesD.edge1, 'x', 0), p_cross_bl, getBoundaryPt(edgesV.edge1, 'y', H), {x:0, y:H}];
        rawPoints.br = [p_cross_br, getBoundaryPt(edgesD.edge1, 'x', W), {x:W, y:H}, getBoundaryPt(edgesV.edge2, 'y', H)];

        const vPoints = [
            getBoundaryPt(edgesV.edge1, 'y', 0), getBoundaryPt(edgesV.edge2, 'y', 0),
            getBoundaryPt(edgesV.edge2, 'y', H), getBoundaryPt(edgesV.edge1, 'y', H)
        ];
        const dPoints = [
            getBoundaryPt(edgesD.edge2, 'x', 0), getBoundaryPt(edgesD.edge2, 'x', W),
            getBoundaryPt(edgesD.edge1, 'x', W), getBoundaryPt(edgesD.edge1, 'x', 0)
        ];

        return { rawPoints, vPoints, dPoints };
    };

    const updateView = () => {
        const { rawPoints, vPoints, dPoints } = calculateGeometry();
        pieces.forEach(p => {
            p.rawPoints = rawPoints[p.id];
            const ptsStr = p.rawPoints.map(pt => `${pt.x.toFixed(2)},${pt.y.toFixed(2)}`).join(' ');
            p.el.setAttribute('points', ptsStr);
            p.ghostEl.setAttribute('points', ptsStr);
        });
        channelV.setAttribute('points', vPoints.map(p => `${p.x},${p.y}`).join(' '));
        channelD.setAttribute('points', dPoints.map(p => `${p.x},${p.y}`).join(' '));
    };

    // --- SAT Physics ---
    const getTransformedVertices = (piece, dx, dy) => piece.rawPoints.map(p => ({ x: p.x + piece.x + dx, y: p.y + piece.y + dy }));
    const getAxes = (vertices) => {
        const axes = [];
        for (let i = 0; i < vertices.length; i++) {
            const p1 = vertices[i];
            const p2 = vertices[(i + 1) % vertices.length];
            const axis = { x: p1.y - p2.y, y: p2.x - p1.x };
            const len = Math.sqrt(axis.x * axis.x + axis.y * axis.y);
            if (len > 0) axes.push({ x: axis.x / len, y: axis.y / len });
        }
        return axes;
    };
    const project = (vertices, axis) => {
        let min = Infinity, max = -Infinity;
        for (let p of vertices) {
            const proj = p.x * axis.x + p.y * axis.y;
            if (proj < min) min = proj;
            if (proj > max) max = proj;
        }
        return { min, max };
    };
    const checkOverlap = (vertsA, vertsB) => {
        const axes = [...getAxes(vertsA), ...getAxes(vertsB)];
        for (let axis of axes) {
            const projA = project(vertsA, axis);
            const projB = project(vertsB, axis);
            if (projA.max < projB.min || projB.max < projA.min) return false;
        }
        return true;
    };
    const hasCollision = (targetPiece, dx, dy) => {
        const targetVerts = getTransformedVertices(targetPiece, dx, dy);
        for (let p of targetVerts) if (p.x < 0 || p.x > W || p.y < 0 || p.y > H) return true;
        for (let other of pieces) {
            if (other === targetPiece) continue;
            if (checkOverlap(targetVerts, getTransformedVertices(other, 0, 0))) return true; 
        }
        return false;
    };

    // --- äº¤äº’é€»è¾‘ ---
    let dragTarget = null; 
    let selectedPiece = null;
    let dragStart = { x: 0, y: 0 };
    let dragMode = null; 

    const getPos = (e) => {
        const CTM = svg.getScreenCTM();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: (clientX - CTM.e) / CTM.a,
            y: (clientY - CTM.f) / CTM.d
        };
    };

    // è®¡ç®—æ–œå‘é€šé“åœ¨è¾¹ç•Œå¤„çš„å‚ç›´è¾¹è·ï¼ˆé˜²æ­¢æº¢å‡ºï¼‰
    const calculateVMargin = (y1, y2) => {
        const slopeDy = Math.abs(y2 - y1);
        const len = Math.sqrt(W * W + slopeDy * slopeDy);
        // é€šé“å‚ç›´æ–¹å‘çš„åŠå®½ = HALF_W * (len / W)
        // è§£é‡Šï¼šcos(theta) = W / len, vWidth = width / cos(theta) = width * len / W
        return HALF_W * (len / W);
    };

    const onStart = (e) => {
        const id = e.target.id;
        const cls = e.target.classList;
        const pos = getPos(e);

        if (id === 'channel-v') {
            dragTarget = 'channel-v';
            dragStart.x = pos.x; 
            e.preventDefault();
        } 
        else if (id === 'channel-d') {
            dragTarget = 'channel-d';
            const clickX = pos.x;
            const zoneWidth = W * 0.2; 
            if (clickX < zoneWidth) dragMode = 'pivot-left';
            else if (clickX > W - zoneWidth) dragMode = 'pivot-right';
            else dragMode = 'translate';
            dragStart.y = pos.y;
            e.preventDefault();
        }
        else if (cls.contains('piece')) {
            e.preventDefault();
            dragTarget = 'piece';
            selectedPiece = pieces.find(p => p.el === e.target);
            if (selectedPiece) {
                dragStart.x = pos.x - selectedPiece.x;
                dragStart.y = pos.y - selectedPiece.y;
                pieceLayer.appendChild(selectedPiece.el);
                selectedPiece.el.classList.add('dragging');
            }
        }
    };

    const onMove = (e) => {
        if (!dragTarget) return;
        e.preventDefault();
        const pos = getPos(e);

        // 1. æ‹–åŠ¨ç«–å‘é€šé“
        if (dragTarget === 'channel-v') {
            const dx = pos.x - dragStart.x;
            let nextX = stateV.topX + dx;
            nextX = Math.max(HALF_W, Math.min(W - HALF_W, nextX));
            stateV.topX = nextX;
            stateV.btmX = nextX;
            dragStart.x = pos.x;
            updateView();
        } 
        // 2. æ‹–åŠ¨æ–œå‘é€šé“
        else if (dragTarget === 'channel-d') {
            const dy = pos.y - dragStart.y;
            
            if (dragMode === 'translate') {
                let nextLeft = stateD.leftY + dy;
                let nextRight = stateD.rightY + dy;
                
                // è®¡ç®—å½“å‰æ–œç‡ä¸‹çš„å‚ç›´è¾¹è·
                const margin = calculateVMargin(nextLeft, nextRight);
                
                // é™åˆ¶ï¼šå¿…é¡»åœ¨ [margin, H-margin] ä¹‹é—´
                // å¹³ç§»æ—¶ margin æ˜¯å¸¸æ•°
                const minY = margin;
                const maxY = H - margin;

                // æ£€æŸ¥æ˜¯å¦è¶Šç•Œï¼Œå¹¶ä¿®æ­£ dy
                if (nextLeft < minY) nextLeft = minY;
                if (nextLeft > maxY) nextLeft = maxY;
                if (nextRight < minY) nextRight = minY;
                if (nextRight > maxY) nextRight = maxY;
                
                // ç”±äºå¹³ç§»éœ€è¦ä¿æŒ left/right ç›¸å¯¹è·ç¦»ï¼Œæˆ‘ä»¬å–ä¿®æ­£åçš„æœ€å°ç§»åŠ¨é‡
                // å…¶å®å¹³ç§»æ—¶ï¼Œæˆ‘ä»¬åªéœ€ä¿è¯æœ€çªå‡ºçš„é‚£ä¸ªç‚¹ä¸è¶Šç•Œ
                // æœ€ä¸Šé¢çš„ç‚¹åæ ‡æ˜¯ min(left, right) - marginï¼Œå¿…é¡» >= 0
                // æœ€ä¸‹é¢çš„ç‚¹åæ ‡æ˜¯ max(left, right) + marginï¼Œå¿…é¡» <= H
                
                // é‡æ–°è®¡ç®—æ›´ä¸¥è°¨çš„å¹³ç§»çº¦æŸï¼š
                const currentMin = Math.min(stateD.leftY, stateD.rightY);
                const currentMax = Math.max(stateD.leftY, stateD.rightY);
                // å…è®¸çš„ dy èŒƒå›´
                const maxUp = currentMin - margin; // å‘ä¸Šçš„æœ€å¤§è·ç¦» (å˜æˆè´Ÿæ•°)
                const maxDown = H - margin - currentMax; // å‘ä¸‹çš„æœ€å¤§è·ç¦»
                
                // é™åˆ¶ dy
                const clampedDy = Math.max(-maxUp, Math.min(maxDown, dy));
                
                stateD.leftY += clampedDy;
                stateD.rightY += clampedDy;
            } 
            else if (dragMode === 'pivot-left') {
                // å·¦ç«¯ç§»åŠ¨ï¼Œå³ç«¯(rightY)ä¸åŠ¨
                let nextLeft = stateD.leftY + dy;
                
                // åŠ¨æ€è¾¹è·ï¼šéšç€ leftY å˜åŒ–ï¼Œæ–œç‡å˜åŒ–ï¼Œmargin ä¹Ÿä¼šå˜åŒ–
                // è¿™æ˜¯ä¸€ä¸ªéçº¿æ€§çº¦æŸï¼Œä½†ç”¨æœ¬æ¬¡ä½ç½®è®¡ç®—çš„ margin åšè¿‘ä¼¼ clamping è¶³å¤Ÿå¹³æ»‘
                const margin = calculateVMargin(nextLeft, stateD.rightY);
                
                nextLeft = Math.max(margin, Math.min(H - margin, nextLeft));
                stateD.leftY = nextLeft;
            } 
            else if (dragMode === 'pivot-right') {
                // å³ç«¯ç§»åŠ¨ï¼Œå·¦ç«¯(leftY)ä¸åŠ¨
                let nextRight = stateD.rightY + dy;
                
                const margin = calculateVMargin(stateD.leftY, nextRight);
                
                nextRight = Math.max(margin, Math.min(H - margin, nextRight));
                stateD.rightY = nextRight;
            }
            
            dragStart.y = pos.y;
            updateView();
        }
        // 3. æ‹–åŠ¨ç¢ç‰‡
        else if (dragTarget === 'piece' && selectedPiece) {
            const targetX = pos.x - dragStart.x;
            const targetY = pos.y - dragStart.y;
            const dx = targetX - selectedPiece.x;
            const dy = targetY - selectedPiece.y;

            if (!hasCollision(selectedPiece, dx, dy)) {
                selectedPiece.x += dx; selectedPiece.y += dy;
            } else if (!hasCollision(selectedPiece, dx, 0)) {
                selectedPiece.x += dx;
            } else if (!hasCollision(selectedPiece, 0, dy)) {
                selectedPiece.y += dy;
            }
            selectedPiece.el.setAttribute('transform', `translate(${selectedPiece.x}, ${selectedPiece.y})`);
            const newPos = getPos(e);
            dragStart.x = newPos.x - selectedPiece.x;
            dragStart.y = newPos.y - selectedPiece.y;
        }
    };

    const onEnd = () => {
        if (selectedPiece) {
            selectedPiece.el.classList.remove('dragging');
            selectedPiece = null;
        }
        dragTarget = null;
        dragMode = null;
    };

    const init = () => {
        pieceIds.forEach(id => {
            const g = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            g.setAttribute("class", "ghost");
            ghostLayer.appendChild(g);

            const p = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            p.setAttribute("class", "piece");
            p.setAttribute("fill", "var(--fill-color)");
            p.setAttribute("stroke", "var(--stroke-color)");
            p.setAttribute("stroke-width", "1");
            p.id = `piece-${id}`;
            pieceLayer.appendChild(p);

            pieces.push({ id: id, el: p, ghostEl: g, x: 0, y: 0, rawPoints: [] });
        });

        updateView();

        svg.addEventListener('mousedown', onStart);
        svg.addEventListener('touchstart', onStart, {passive: false});
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onEnd);
        window.addEventListener('touchmove', onMove, {passive: false});
        window.addEventListener('touchend', onEnd);
    };

    init();
}

// å¸®åŠ©å¼¹çª—æ§åˆ¶
{
    const helpBtn = document.getElementById('help-btn');
    const helpModal = document.getElementById('help-modal');
    const closeBtn = document.getElementById('close-modal');
    
    helpBtn.addEventListener('click', () => {
        helpModal.classList.add('show');
    });
    
    closeBtn.addEventListener('click', () => {
        helpModal.classList.remove('show');
    });
    
    helpModal.addEventListener('click', (e) => {
        if (e.target === helpModal) {
            helpModal.classList.remove('show');
        }
    });
}
</script>

</body>
</html>
