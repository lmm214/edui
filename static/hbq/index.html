
<!doctype html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
	<title>黑白棋大挑战</title>
<style type="text/css">
body {
	background-image: linear-gradient(45deg, #93a5cf 0%, #e4efe9 100%);
    font-family: "微软雅黑", "苹方", "PingFang SC", "Helvetica Neue", Arial, sans-serif;
	margin: 0;
	padding: 0;
	min-height: 100vh;
	overflow: hidden;
}
#desk {
	max-width: 1000px;
	margin: -4rem auto 0;
	padding: 0 20px;
	display: grid;
	grid-template-columns: 1fr auto;
	grid-template-rows: auto 1fr;
	gap: 0;
	align-items: center;
	justify-items: center;
	min-height: calc(100vh - 40px);
}
#title {
	max-width: 1000px;
	margin: 20px auto;
    text-align: center;
}
#interface {
	grid-column: 1;
	grid-row: 2;
}
#console {
	grid-column: 2;
	grid-row: 2;
	display: flex;
	flex-direction: column;
	gap: 15px;
	max-width: 200px;
	padding: 20px;
	background: rgba(102, 126, 234, 0.05);
	border-radius: 15px;
	border: 2px solid rgba(102, 126, 234, 0.1);
}
#console .cbox2, #console .cbox3{
	grid-column: 3;
	grid-row: 1;
	display: flex;
	flex-direction: column;
	gap: 5px;
}
#console .cbox2{grid-column: 2;}
h1 {
	margin: 0;
	color: #2c3e50;
	font-size: 2rem;
	line-height: 1.2;
	font-weight: 800;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
	letter-spacing: 2px;
}
h1 span {
	color: #fff;
}
h3 {
	margin: 5px 0;
	color: #34495e;
	font-size: 20px;
	line-height: 1.3;
	font-weight: 600;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
}

.button {
	margin: 5px;
	width: 120px;
	height: 50px;
	font-size: 16px;
	line-height: 50px;
	border: none;
	border-radius: 25px;
	box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
	text-align: center;
	cursor: pointer;
	transition: all 0.3s ease;
	font-weight: 600;
	text-transform: uppercase;
	letter-spacing: 1px;
}
.button:hover {
	background-image: linear-gradient(120deg, #a6c0fe 0%, #f68084 100%);
	box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
	transform: translateY(-2px);
}
.button:active {
	transform: translateY(0);
	box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
}

.cbox {
	height: 60px;
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0 15px;
	transition: all 0.3s ease;
}
.side {
    border-radius: 15px;
	background: rgba(255, 255, 255, 0.4);
}
.cbox span {
	font-size: 24px;
	font-weight: bold;
	color: #2c3e50;
	text-shadow: none;
}

#interface {
	position: relative;
	width: 100%;
	max-width: 600px;
	height: auto;
	margin: 0 auto;
}

#chessboard {
	width: 100%;
	max-width: 600px;
	height: auto;
	aspect-ratio: 1;
	margin: 15px auto;
	border: 4px solid #34495e;
	background: #2c3e50;
	box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
	border-radius: 15px;
	-webkit-transform: perspective(740px) rotateX(0deg);
	transform: perspective(740px) rotateX(0deg);
	-webkit-transition: -webkit-transform 1s;
	transition: transform 1s;
	overflow: hidden;
}
#chessboard table {
	background: #34495e;
	border-spacing: 2px;
	width: 100%;
	height: 100%;
}
#chessboard td {
	width: 12.5%;
	height: 12.5%;
    aspect-ratio: 1;
	position: relative;
	transition: all 0.2s ease;
	cursor: pointer;
}
#chessboard td:hover {
	background-color: rgba(102, 126, 234, 0.1) !important;
}

#chessboard td > div {
	width: 100%;
	height: 100%;
	display: flex;
	align-items: center;
	justify-content: center;
}
#chessboard .bg0 { background: #ffffff; }
#chessboard .bg1 { background: #e9f0e9; }

.black, .white {
	width: 70%;
	height: 70%;
	border-radius: 50%;
	margin: 0 auto;
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
	position: relative;
	max-width: 42px;
	max-height: 42px;
}
#console .black, #console .white {
	margin: 0 0 0 10px;
}
.fdd #chessboard {
	-webkit-transform: perspective(800px) rotateX(35deg);
	transform: perspective(800px) rotateX(35deg);
	box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
}
.fdd td .black, .fdd td .white {
	margin: 6px auto 16px;
	box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
}

.black {
	background: radial-gradient(circle at 30% 30%, #555, #000);
	-webkit-transform: rotateY(0deg);
	transform: rotateY(0deg);
}
.white {
	background: radial-gradient(circle at 30% 30%, #fff, #ddd);
	-webkit-transform: rotateY(180deg);
	transform: rotateY(180deg);
}
.reversal {
    -webkit-transition: -webkit-transform 600ms cubic-bezier(0.4, 0, 0.2, 1);
    transition: transform 600ms cubic-bezier(0.4, 0, 0.2, 1);
}
.newest:before, .reversal:before {
	content: "";
	display: block;
	width: 15%;
	height: 15%;
	aspect-ratio: 1;
	border-radius: 50%;
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	z-index: 10;
	max-width: 8px;
	max-height: 8px;
}
.newest:before {
	background: #e74c3c;
	box-shadow: 0 0 8px #e74c3c;
}
.reversal:before {
	background: #3498db;
	box-shadow: 0 0 8px #3498db;
}
.prompt {
	width: 20%;
	height: 20%;
	border-radius: 50%;
	margin: auto;
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background: radial-gradient(circle, #f3d29e, #ecb359);
	max-width: 6px;
	max-height: 6px;
}

@keyframes pulse {
	0%, 100% { transform: scale(1); }
	50% { transform: scale(1.1); }
}

#selectbox {
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	width: 90%;
	max-width: 380px;
	height: auto;
	background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
	border: none;
	border-radius: 25px;
	box-shadow: 0 25px 80px rgba(0, 0, 0, 0.4);
	padding: 0;
	font-size: 16px;
	line-height: 1.6;
	display: none;
	z-index: 1000;
	overflow: hidden;
}
#selectbox::before {
	content: '';
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.6);
	z-index: -1;
	backdrop-filter: blur(5px);
}
.selectbox-header {
	background: rgba(255, 255, 255, 0.95);
	padding: 25px 30px 20px;
	text-align: center;
	border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}
.selectbox-content {
	padding: 25px 30px;
	background: rgba(255, 255, 255, 0.98);
}
.selectbox-section {
	margin-bottom: 25px;
}
.selectbox-section:last-of-type {
	margin-bottom: 0;
}
.section-title {
	font-size: 14px;
	font-weight: 600;
	color: #7f8c8d;
	margin-bottom: 15px;
	text-transform: uppercase;
	letter-spacing: 1px;
	border-bottom: 2px solid #ecf0f1;
	padding-bottom: 8px;
}
#selectbox input:checked + span {
	color: #667eea;
	font-weight: 600;
	text-shadow: none;
}
#selectbox label {
	display: flex;
	align-items: center;
	margin: 8px 0;
	cursor: pointer;
	transition: all 0.3s ease;
	padding: 12px 15px;
	border-radius: 12px;
	border: 2px solid transparent;
	background: rgba(102, 126, 234, 0.02);
}
#selectbox label:hover {
	background: rgba(102, 126, 234, 0.08);
	border-color: rgba(102, 126, 234, 0.2);
	transform: translateX(3px);
}
#selectbox input[type="radio"]:checked + span {
	color: #667eea;
}
#selectbox label:has(input:checked) {
	background: rgba(102, 126, 234, 0.15);
	border-color: #667eea;
	box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
}
#selectbox input[type="radio"] {
	margin-right: 12px;
	transform: scale(1.3);
	accent-color: #667eea;
}

#buttons {
	margin: 30px 0 0;
	display: flex;
	justify-content: center;
	gap: 20px;
}
#copyright {
	text-align: center;
	color: #7f8c8d;
	padding: 20px;
	font-size: 14px;
	margin-top: 20px;
	border-top: 1px solid #ecf0f1;
}

#pass {
	position: absolute;
	top: 20px;
	left: 50%;
	transform: translateX(-50%);
	width: auto;
	min-width: 250px;
	height: auto;
	border-radius: 25px;
	text-align: center;
	font-size: 18px;
	line-height: 1.5;
	padding: 20px 30px;
	background: linear-gradient(135deg, #e74c3c, #c0392b);
	color: white;
	text-shadow: none;
	display: none;
	box-shadow: 0 12px 35px rgba(231, 76, 60, 0.4);
	font-weight: 700;
	border: 3px solid rgba(255, 255, 255, 0.3);
	z-index: 100;
}

/* 自定义Alert组件样式 */
#custom-alert {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.6);
	z-index: 2;
	display: flex;
	align-items: center;
	justify-content: center;
	backdrop-filter: blur(5px);
}

.alert-content {
	background: white;
	border-radius: 20px;
	box-shadow: 0 25px 80px rgba(0, 0, 0, 0.3);
	max-width: 450px;
	width: 90%;
	max-height: 80vh;
	overflow: hidden;
	animation: alertSlideIn 0.3s ease-out;
}

@keyframes alertSlideIn {
	from {
		opacity: 0;
		transform: scale(0.8) translateY(-20px);
	}
	to {
		opacity: 1;
		transform: scale(1) translateY(0);
	}
}

.alert-header {
	background: linear-gradient(135deg, #667eea, #764ba2);
	color: white;
	padding: 25px 30px 20px;
	text-align: center;
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 10px;
}

.alert-icon {
	font-size: 48px;
	line-height: 1;
}

.alert-title {
	margin: 0;
	font-size: 22px;
	font-weight: 700;
	letter-spacing: 1px;
    color: #fff;
}

.alert-body {
	padding: 30px;
	text-align: center;
}

.alert-message {
	margin: 0;
	font-size: 2rem;
	line-height: 1.6;
	color: #2c3e50;
	white-space: pre-line;
}

.alert-footer {
	padding: 0 30px 30px;
	text-align: center;
}

.alert-button {
	background: linear-gradient(45deg, #667eea, #764ba2);
	color: white;
	border: none;
	padding: 12px 30px;
	border-radius: 25px;
	font-size: 16px;
	font-weight: 600;
	cursor: pointer;
	transition: all 0.3s ease;
	text-transform: uppercase;
	letter-spacing: 1px;
	min-width: 120px;
}

.alert-button:hover {
	background: linear-gradient(45deg, #764ba2, #667eea);
	transform: translateY(-2px);
	box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
}

.alert-button:active {
	transform: translateY(0);
}

@media screen and (max-width: 768px) {
	#desk {
		margin: 10px auto;
		padding: 0px 15px;
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 0;
		min-width: 280px;
	}

	#title {
		order: 1;
	}

	#interface {
		order: 2;
		width: 100%;
		max-width: 280px;
	}

	#console {
		order: 3;
		max-width: none;
		width: 90%;
	}
	#console .cbox2{gap: 10px;display: grid;grid-column: 1;grid-template-columns: 1fr 1fr;}
	#console .cbox3{
		display: flex;
		flex-direction: row;
		grid-template-columns: 1fr 1fr 1fr;
		gap: 5px;
		grid-column: 1;
	}
	h1 {
		font-size: 28px;
	}
	h3 {
		font-size: 16px;
	}

	.button {
		width: 100%;
		height: 45px;
		line-height: 45px;
		font-size: 14px;
	}

	.cbox span {
		font-size: 20px;
	}

	#selectbox {
		padding: 10px;
		font-size: 16px;
	}
	.selectbox-header{padding:5px 15px;border-radius:15px 15px 0 0;}
	.selectbox-content{padding:5px 15px;border-radius:0 0 15px 15px ;}
	#chessboard {
		max-width: 100%;
		width: 100%;
	}
	.black, .white {
		max-width: 24px;
		max-height: 24px;
	}
	.prompt{max-width:4px;max-height:4px;}
}

@media screen and (max-height: 768px) {
	#desk {
		margin: 0 auto;
		min-height: auto;
		gap: 0;
	}

	#title {
		margin: 10px auto;
	}

	h1 {
		font-size: 1.5rem;
		margin: 0;
	}

	#interface {
		max-width: min(320px, 70vh);
	}

	#chessboard {
		max-width: min(320px, 60vh);
		width: min(100%, 60vh);
		margin: 10px auto;
	}

	#console {
		padding: 10px;
		gap: 10px;
	}

	.cbox {
		height: 45px;
		padding: 0 10px;
	}

	.cbox span {
		font-size: 18px;
	}

	.button {
		height: 40px;
		width: 80px;
		line-height: 40px;
		font-size: 14px;
	}

	.black, .white {
		max-width: 24px;
		max-height: 24px;
	}
}
@media screen and (max-width: 360px) {
	.black, .white {
		max-width: 18px;
		max-height: 18px;
	}
}
</style>
</head>
<body>
    <div id="title">
		<h1>黑<span>白</span>棋大挑战</h1>
	</div>
<div id="desk">
	<div id="interface">
		<div id="chessboard"></div>
		<div id="pass"></div>

		<div id="selectbox">
			<div class="selectbox-header">
				<h2 style="margin: 0; color: #2c3e50; font-size: 24px; font-weight: 700;">⚙️ 设置</h2>
			</div>
			
			<div class="selectbox-content">
				<div class="selectbox-section">
					<h3 style="margin: 0 0 10px 0; color: #34495e; font-size: 16px; font-weight: 600;">🎮 游戏模式</h3>
					<label><input type="radio" name="gameMode" value="ai" checked="checked" onchange="toggleDifficultySection()"><span>🤖 人机对战 <small style="color: #95a5a6;">(与AI对弈)</small></span></label>
					<label><input type="radio" name="gameMode" value="human" onchange="toggleDifficultySection()"><span>👥 人人对战 <small style="color: #95a5a6;">(双人游戏)</small></span></label>
				</div>
				<div class="selectbox-section" id="difficulty-section">
					<h3 style="margin: 0 0 10px 0; color: #34495e; font-size: 16px; font-weight: 600;">⚡ AI难度</h3>
					<label><input type="radio" name="level" checked="checked"><span>🟢 简单模式 <small style="color: #95a5a6;">(新手推荐)</small></span></label>
					<label><input type="radio" name="level"><span>🟡 普通模式 <small style="color: #95a5a6;">(有点挑战)</small></span></label>
					<label><input type="radio" name="level"><span>🔴 困难模式 <small style="color: #95a5a6;">(高手对决)</small></span></label>
				</div>
				<div id="buttons">
					<div id="ok" class="button">确定</div>
				</div>
			</div>
		</div>

		<!-- 自定义Alert组件 -->
		<div id="custom-alert" style="display: none;">
			<div class="alert-content">
				<div class="alert-header">
					<div class="alert-icon">🎯</div>
					<h3 class="alert-title">游戏提示</h3>
				</div>
				<div class="alert-body">
					<p class="alert-message"></p>
				</div>
				<div class="alert-footer">
					<button class="alert-button" onclick="closeCustomAlert()">确定</button>
				</div>
			</div>
		</div>

	</div>
	<div id="console">
		<div class="cbox2">
			<div id="side1" class="cbox">
				<div class="black"></div>
				<span>0</span>
			</div>
			<div id="side2" class="cbox">
				<div class="white"></div>
				<span>0</span>
			</div>
		</div>
		<div class="cbox3">
			<div id="play" class="button">🎮 开始</div>
			<div id="setting" class="button">⚙️ 设置</div>
			<div id="back" class="button">↩️ 撤销</div>
		</div>
	</div>
</div>

<script>
var JSConfetti=function(){"use strict";function t(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function e(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function i(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}function n(t){return+t.replace(/px/,"")}function s(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=Math.random()*(e-t)+t;return Math.floor(n*Math.pow(10,i))/Math.pow(10,i)}function o(t){return t[s(0,t.length)]}var a=["#fcf403","#62fc03","#f4fc03","#03e7fc","#03fca5","#a503fc","#fc03ad","#fc03c2"];function r(t){return Math.log(t)/Math.log(1920)}var h=function(){function e(i){t(this,e);var n=i.initialPosition,a=i.direction,h=i.confettiRadius,c=i.confettiColors,u=i.emojis,l=i.emojiSize,d=i.canvasWidth,f=s(.9,1.7,3)*r(d);this.confettiSpeed={x:f,y:f},this.finalConfettiSpeedX=s(.2,.6,3),this.rotationSpeed=u.length?.01:s(.03,.07,3)*r(d),this.dragForceCoefficient=s(5e-4,9e-4,6),this.radius={x:h,y:h},this.initialRadius=h,this.rotationAngle="left"===a?s(0,.2,3):s(-.2,0,3),this.emojiSize=l,this.emojiRotationAngle=s(0,2*Math.PI),this.radiusYUpdateDirection="down";var m="left"===a?s(82,15)*Math.PI/180:s(-15,-82)*Math.PI/180;this.absCos=Math.abs(Math.cos(m)),this.absSin=Math.abs(Math.sin(m));var v=s(-150,0),p={x:n.x+("left"===a?-v:v)*this.absCos,y:n.y-v*this.absSin};this.currentPosition=Object.assign({},p),this.initialPosition=Object.assign({},p),this.color=u.length?null:o(c),this.emoji=u.length?o(u):null,this.createdAt=(new Date).getTime(),this.direction=a}return i(e,[{key:"draw",value:function(t){var e=this.currentPosition,i=this.radius,n=this.color,s=this.emoji,o=this.rotationAngle,a=this.emojiRotationAngle,r=this.emojiSize,h=window.devicePixelRatio;n?(t.fillStyle=n,t.beginPath(),t.ellipse(e.x*h,e.y*h,i.x*h,i.y*h,o,0,2*Math.PI),t.fill()):s&&(t.font="".concat(r,"px serif"),t.save(),t.translate(h*e.x,h*e.y),t.rotate(a),t.textAlign="center",t.fillText(s,0,0),t.restore())}},{key:"updatePosition",value:function(t,e){var i=this.confettiSpeed,n=this.dragForceCoefficient,s=this.finalConfettiSpeedX,o=this.radiusYUpdateDirection,a=this.rotationSpeed,r=this.createdAt,h=this.direction,c=e-r;i.x>s&&(this.confettiSpeed.x-=n*t),this.currentPosition.x+=i.x*("left"===h?-this.absCos:this.absCos)*t,this.currentPosition.y=this.initialPosition.y-i.y*this.absSin*c+.00125*Math.pow(c,2)/2,this.rotationSpeed-=this.emoji?1e-4:1e-5*t,this.rotationSpeed<0&&(this.rotationSpeed=0),this.emoji?this.emojiRotationAngle+=this.rotationSpeed*t%(2*Math.PI):"down"===o?(this.radius.y-=t*a,this.radius.y<=0&&(this.radius.y=0,this.radiusYUpdateDirection="up")):(this.radius.y+=t*a,this.radius.y>=this.initialRadius&&(this.radius.y=this.initialRadius,this.radiusYUpdateDirection="down"))}},{key:"getIsVisibleOnCanvas",value:function(t){return this.currentPosition.y<t+100}}]),e}();function c(){var t=document.createElement("canvas");return t.style.position="fixed",t.style.width="100%",t.style.height="100%",t.style.top="0",t.style.left="0",t.style.zIndex="1000",t.style.pointerEvents="none",document.body.appendChild(t),t}function u(t){var e=t.confettiRadius,i=void 0===e?6:e,n=t.confettiNumber,s=void 0===n?t.confettiesNumber||(t.emojis?40:250):n,o=t.confettiColors,r=void 0===o?a:o,h=t.emojis,c=void 0===h?t.emojies||[]:h,u=t.emojiSize,l=void 0===u?80:u;return t.emojies&&console.error("emojies argument is deprecated, please use emojis instead"),t.confettiesNumber&&console.error("confettiesNumber argument is deprecated, please use confettiNumber instead"),{confettiRadius:i,confettiNumber:s,confettiColors:r,emojis:c,emojiSize:l}}var l=function(){function e(i){var n=this;t(this,e),this.canvasContext=i,this.shapes=[],this.promise=new Promise((function(t){return n.resolvePromise=t}))}return i(e,[{key:"getBatchCompletePromise",value:function(){return this.promise}},{key:"addShapes",value:function(){var t;(t=this.shapes).push.apply(t,arguments)}},{key:"complete",value:function(){var t;return!this.shapes.length&&(null===(t=this.resolvePromise)||void 0===t||t.call(this),!0)}},{key:"processShapes",value:function(t,e,i){var n=this,s=t.timeDelta,o=t.currentTime;this.shapes=this.shapes.filter((function(t){return t.updatePosition(s,o),t.draw(n.canvasContext),!i||t.getIsVisibleOnCanvas(e)}))}}]),e}();return function(){function e(){var i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};t(this,e),this.activeConfettiBatches=[],this.canvas=i.canvas||c(),this.canvasContext=this.canvas.getContext("2d"),this.requestAnimationFrameRequested=!1,this.lastUpdated=(new Date).getTime(),this.iterationIndex=0,this.loop=this.loop.bind(this),requestAnimationFrame(this.loop)}return i(e,[{key:"loop",value:function(){var t,e,i,s,o;this.requestAnimationFrameRequested=!1,t=this.canvas,e=window.devicePixelRatio,i=getComputedStyle(t),s=n(i.getPropertyValue("width")),o=n(i.getPropertyValue("height")),t.setAttribute("width",(s*e).toString()),t.setAttribute("height",(o*e).toString());var a=(new Date).getTime(),r=a-this.lastUpdated,h=this.canvas.offsetHeight,c=this.iterationIndex%10==0;this.activeConfettiBatches=this.activeConfettiBatches.filter((function(t){return t.processShapes({timeDelta:r,currentTime:a},h,c),!c||!t.complete()})),this.iterationIndex++,this.queueAnimationFrameIfNeeded(a)}},{key:"queueAnimationFrameIfNeeded",value:function(t){this.requestAnimationFrameRequested||this.activeConfettiBatches.length<1||(this.requestAnimationFrameRequested=!0,this.lastUpdated=t||(new Date).getTime(),requestAnimationFrame(this.loop))}},{key:"addConfetti",value:function(){for(var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=u(t),i=e.confettiRadius,n=e.confettiNumber,s=e.confettiColors,o=e.emojis,a=e.emojiSize,r=this.canvas.getBoundingClientRect(),c=r.width,d=r.height,f=5*d/7,m={x:0,y:f},v={x:c,y:f},p=new l(this.canvasContext),y=0;y<n/2;y++){var g=new h({initialPosition:m,direction:"right",confettiRadius:i,confettiColors:s,confettiNumber:n,emojis:o,emojiSize:a,canvasWidth:c}),C=new h({initialPosition:v,direction:"left",confettiRadius:i,confettiColors:s,confettiNumber:n,emojis:o,emojiSize:a,canvasWidth:c});p.addShapes(g,C)}return this.activeConfettiBatches.push(p),this.queueAnimationFrameIfNeeded(),p.getBatchCompletePromise()}},{key:"clearCanvas",value:function(){this.activeConfettiBatches=[]}},{key:"destroyCanvas",value:function(){this.canvas.remove()}}]),e}()}();
        const confetti = new JSConfetti();
        function showConfetti() {
            confetti.addConfetti({
                confettiNumber: 500
            })
        }
		
function Chessboard()
{
	var oo = this;

	var pieces;		//棋子元素
	var piecesnum;	//黑白子数目显示元素
	var side;	//表示执棋方元素

	oo.toDown = null;	//下子

	function bindEvent(td)	//绑定点击事件
	{
		for(var i=0; i<64; i++)
			(function (i){
				td[i].onclick = function (){
					if (pieces[i].className=="prompt")
						oo.toDown(i);
				}
			})(i);
		td = undefined;
	}

	oo.create = function ()		//创建棋盘
	{
		var obj = document.getElementById("chessboard");
		var html = "<table>";
		for (var i=0; i<8; i++)
		{
			html += "<tr>";
			for (var j=0; j<8; j++)
				html += "<td class='bg"+(j+i)%2+"'><div></div></td>";
			html += "</tr>";
		}
		html += "</table>";
		obj.innerHTML = html;
		pieces = obj.getElementsByTagName("div");
		bindEvent(obj.getElementsByTagName("td"));

		piecesnum = document.getElementById("console").getElementsByTagName("span");
		side = {
			"1": document.getElementById("side1"),
			"-1": document.getElementById("side2")
		};
	}

	oo.update = function (m,nop)		//更新棋盘
	{
		for (var i=0; i<64; i++)
			pieces[i].className = ["white","","black"][m[i]+1];
		if (!nop)
			for (var n in m.next)
				pieces[n].className = "prompt";
		for (var i=0; i<m.newRev.length; i++)
			pieces[m.newRev[i]].className += " reversal";
		if (m.newPos!=-1)
			pieces[m.newPos].className += " newest";
		piecesnum[0].innerHTML = m.black;
		piecesnum[1].innerHTML = m.white;
		side[m.side].className = "cbox side";
		side[-m.side].className = "cbox";
	}
}


function AI(){
	var oo = this;

	oo.calculateTime = 1000;	//限制每步棋计算的时间
	oo.outcomeDepth = 14;		//终局搜索深度
	var outcomeCoarse = 15;		//终局搜索模糊模式搜索深度
	var maxDepth;
	var outTime;

	var weight = [6,11,2,2,3];  //权重

	var rnd = [			//用于估价函数中边角的计算
		{s: 0,a: 1,b: 8,c: 9,dr:[1,8]},
		{s: 7,a: 6,b:15,c:14,dr:[-1,8]},
		{s:56,a:57,b:48,c:49,dr:[1,-8]},
		{s:63,a:62,b:55,c:54,dr:[-1,-8]}
	];

	oo.history = [[],[]];			//历史启发表
	for (var i=0; i<2; i++)
		for (var j=0; j<=60; j++)
			oo.history[i][j] = [0,63,7,56,37,26,20,43,19,29,34,44,21,42,45,18,2,61,23,40,5,58,47,16,10,53,22,41,13,46,17,50,51,52,12,11,30,38,25,33,4,3,59,60,39,31,24,32,1,62,15,48,8,55,6,57,9,54,14,49];

	var hash = new Transposition();

	function sgn(n)//符号函数，要用时才发现javascript居然没有sgn函数，真晕啊
	{
		return n>0?1:n<0?-1:0;
	}


	function evaluation(m)			//估价函数
	{
		var corner = 0, steady = 0, uk = {};
		for (var i=0,v,l = rnd.length; v = rnd[i],i<l; i++)
		{
			if (m[v.s]==0)			//角为空格
			{
				corner += m[v.a] * -3;		//次要危险点
				corner += m[v.b] * -3;		//次要危险点
				corner += m[v.c] * -6;		//主要危险点
				continue;
			}
			corner += m[v.s] * 15;		//角点
			steady += m[v.s];		//角也是稳定子
			for (var k = 0; k <2; k++)
			{
				if (uk[v.s+v.dr[k]])
					continue;
				var eb = true, tmp = 0;
				for (var j = 1; j <= 6; j++)
				{
					var t = m[v.s+v.dr[k]*j];
					if (t==0)
							break;
					else if (eb && t==m[v.s])
						steady += t;		//稳定子
					else
					{
						eb = false;
						tmp += t;		//稳定子
					}
				}
				if (j==7 && m[v.s+v.dr[k]*7]!=0)
				{
					steady += tmp;
					uk[v.s+v.dr[k]*6] = true;
				}
			}
		}

		var frontier = 0;		//前沿子
		for (var i=9; i<=54; i+=(i&7)==6?3:1)
		{
			if (m[i]==0)
				continue;
			for (var j=0; j<8; j++)
				if (m[othe.dire(i,j)]==0)
				{
					frontier -= m[i];
					break;
				}
		}

		var mobility = (m.nextNum-m.prevNum)*m.side;	//行动力(简单吧)

		var parity = m.space<18 ? (m.space%2==0?-m.side:m.side) : 0;	//奇偶性


		var rv = corner*weight[0] + steady*weight[1] + frontier*weight[2] + mobility*weight[3] + parity*weight[4];
		return rv * m.side;
	}

	function outcome(m)		//终局结果
	{
		var s = m.black-m.white;
		if (maxDepth>=outcomeCoarse)
			return sgn(s)*10000*m.side;//为了加快终局搜索速度只给出输赢,暂不记分,使搜索更容易发生剪枝.
		return (s+m.space*sgn(s))*10000*m.side;
	}

	oo.startSearch = function(m)		//开始搜索博弈树
	{
		// hash = new Transposition();
		// console.profile('性能分析器一');
		var f = 0;
		if (m.space<=oo.outcomeDepth)
		{
			//进行终局搜索
			outTime = (new Date()).getTime()+600000;		//终局搜索就不限时间了
			maxDepth = m.space;
			//console.time("计时器2");
			if (maxDepth>=outcomeCoarse)
				f = alphaBeta(m, maxDepth, -Infinity, Infinity);
			else
				f = mtd(m, maxDepth, f);
			//console.timeEnd("计时器2");
			console.log("终局搜索结果：",maxDepth,m.space,m.side,f*m.side);
			return hash.getBest(m.key);
		}

		// 新手模式：如果设置的深度为0，则进行随机走法
		if (oo.outcomeDepth === 0) {
			if (m.nextIndex && m.nextIndex.length > 0) {
				var randomMove = m.nextIndex[Math.floor(Math.random() * m.nextIndex.length)];
				console.log("新手模式随机走法：", randomMove);
				return randomMove;
			}
		}

		outTime = (new Date()).getTime()+oo.calculateTime;
		maxDepth = 0;
		//console.time("计时器2");
		try {
			// 如果设置了固定深度限制，则只搜索到该深度
			var maxSearchDepth = (oo.outcomeDepth > 0 && oo.outcomeDepth < m.space) ? oo.outcomeDepth : m.space;
			while (maxDepth < maxSearchDepth)
			{
				f = mtd(m, ++maxDepth, f);
				// f = alphaBeta(m, ++maxDepth, -Infinity, Infinity);
				var best = hash.getBest(m.key);
				console.log(maxDepth,f*m.side,best);
				// 如果达到设定的深度限制，立即停止
				if (oo.outcomeDepth > 0 && maxDepth >= oo.outcomeDepth) {
					break;
				}
			}
		} catch(eo){
			if (eo.message!="time out")		//不有限定计算时间的异常
				throw eo;					//把异常转抛给浏览器
		}
		//console.timeEnd("计时器2");
		// console.profileEnd();
		console.log("搜索结果：",maxDepth-1,m.space,m.side,f*m.side);
		return best;
	}

	function mtd(m,depth,f)		//MTD(f)算法
	{
		var lower = -Infinity;
		var upper = Infinity;
		do {
			var beta = (f==lower) ? f+1 : f;	// 确定试探值
			f = alphaBeta(m, depth, beta-1, beta);	// 进行零宽窗口试探
			if (f < beta)
				upper = f;
			else
				lower = f;
		} while (lower < upper);
		if (f < beta)	// 如果最后一次搜索得到的只是上限，需再搜索一次，确保获得正确的最佳棋步
			f = alphaBeta(m, depth, f-1, f);
		return f;
	}

	function alphaBeta(m,depth,alpha,beta)		//Alpha-beta剪枝
	{
		if ((new Date()).getTime() > outTime)		//判断是否到达限定的计算时间
			throw new Error("time out");		//用抛出异常方式直接从深层搜索中跳出来

		var hv = hash.get(m.key,depth,alpha,beta);
		if (hv !== false)
			return hv;

		if (m.space==0)			//棋盘子满
			return outcome(m);	//直接返回终局结果
		othe.findLocation(m);
		if (m.nextNum==0)		//判断无棋可走
		{
			if (m.prevNum==0)		//判断上一步也是无棋可走
				return outcome(m);		//直接返回终局结果
			othe.pass(m);
			return -alphaBeta(m, depth, -beta, -alpha);
		}
		if (depth<=0)			//搜索深度到达设置的极限
		{
			var e = evaluation(m);
			hash.set(m.key,e,depth,0,null);
			return e;
		}

		var hd = hash.getBest(m.key);
		if (hd!==null)
			moveToHead(m.nextIndex,hd);

		var hist = oo.history[m.side==1?0:1][m.space];
		var hashf = 1;				//最佳估值类型, 0为精确值, 1为<=alpha, 2为>=beta
		var bestVal = -Infinity;		//记录最佳估值
		var bestAct = null;				//记录最佳棋步
		for (var i=0; i<m.nextNum; i++)
		{
			var n = m.nextIndex[i];
			var v = -alphaBeta(othe.newMap(m,n), depth-1, -beta, -alpha);
			if (v > bestVal)
			{
				bestVal = v;
				bestAct = n;
				if (v > alpha)
				{
					alpha = v;
					hashf = 0;
					moveToUp(hist,n);
				}
				if (v >= beta)
				{
					hashf = 2;
					break;		//发生剪枝
				}
			}
		}
		moveToHead(hist,bestAct);
		hash.set(m.key,bestVal,depth,hashf,bestAct);
		return bestVal;
	}

	function moveToHead(arr,n)
	{
		if (arr[0]==n)
			return;
		var i = arr.indexOf(n);
		arr.splice(i,1);
		arr.unshift(n);
	}

	function moveToUp(arr,n)
	{
		if (arr[0]==n)
			return;
		var i = arr.indexOf(n);
		arr[i] = arr[i-1];
		arr[i-1] = n;
	}

}




function Transposition()
{
	var oo = this;

	var HASH_SIZE = (1 << 19) -1;		//置换单元数为 524287
	var data = new Array(HASH_SIZE+1);

	oo.set = function (key,eva,depth,flags,best)
	{
		var keyb = key[0]&HASH_SIZE;
		var phashe = data[keyb];
		if (!phashe)
			phashe = data[keyb] = {};
		else if (phashe.key == key[1] && phashe.depth > depth)		//局面相同 并且 记录比当前更深 则不替换
			return;
		phashe.key = key[1];
		phashe.eva = eva;
		phashe.depth = depth;
		phashe.flags = flags;
		phashe.best = best;
	}

	oo.get = function (key,depth,alpha,beta)
	{
		var phashe = data[key[0]&HASH_SIZE];
		if ((!phashe) || phashe.key != key[1] || phashe.depth < depth)
			return false;
		switch (phashe.flags)
		{
			case 0:
				return phashe.eva;
			case 1:
				if (phashe.eva <= alpha)
					return phashe.eva;
				return false;
			case 2:
				if (phashe.eva >= beta)
					return phashe.eva;
				return false;
		}
	}

	oo.getBest = function (key)
	{
		var phashe = data[key[0]&HASH_SIZE];
		if ((!phashe) || phashe.key != key[1])
			return null;
		return phashe.best;
	}


}


function Zobrist()
{
	var oo = this;

	var swapSide = [rnd(),rnd()];// 下棋方轮换的附加散列码
	var zarr = [[],[],[]];
	for (var pn=0; pn<64; pn++)
	{
		zarr[0][pn] = [rnd(),rnd()];// 各位置上出现黑棋时
		zarr[1][pn] = [rnd(),rnd()];// 各位置上出现白棋时
		zarr[2][pn] = [zarr[0][pn][0]^zarr[1][pn][0], zarr[0][pn][1]^zarr[1][pn][1]];// 各位置上翻棋时
	}

	function rnd()		//获取32位的随机数
	{
		return (Math.random()*0x100000000)>>0;
	}

	oo.swap = function (key)		//执棋方轮换
	{
		key[0] ^= swapSide[0];
		key[1] ^= swapSide[1];
	}

	oo.set = function (key,pc,pn)	//设置更新key
	{
		key[0] ^= zarr[pc][pn][0];
		key[1] ^= zarr[pc][pn][1];
	}
}



function Othello()
{
	var oo = this;

	var map = [];			//棋局数组
	var history = [];		//历史记录,用于悔棋操作

	var zobrist = new Zobrist();

	oo.aiSide = 0;	//1: 电脑为黑棋,  -1: 电脑为白棋,  0: 双人对战 2: 电脑自己对战


	var passObj = document.getElementById("pass");
	var timer;		//定时器id
	var passTimer;	//pass提示计时器

	oo.play = function ()	//开始新棋局
	{
		// 清除所有计时器
		clearTimeout(timer);
		if (passTimer) {
			clearTimeout(passTimer);
			passTimer = null;
		}
		console.clear();
		map = [];
		for (var i=0; i<64; i++)
			map[i] = 0;					//空格为 0
		map[28] = map[35] = 1;			//黑子为 1
		map[27] = map[36] = -1;			//白子为 -1
		map.black = map.white = 2;		//黑白棋子数目
		map.space = 60;		//空格数目
		map.frontier = [];	//周围有棋子的空格，用于加速查找可下棋步
		var tk = [18,19,20,21,26,29,34,37,42,43,44,45];
		for (var i=0; i<12; i++)
			map.frontier[tk[i]] = true;
		map.side = 1;		//当前执棋方
		map.newPos = -1;	//最新下子的位置
		map.newRev = [];	//最新反转棋子的位置
		map.nextIndex = [];	//下一步可走棋的位置
		map.next = {};		//下一步可走棋的反转棋子
		map.nextNum = 0;	//下一步可走棋的数目
		map.prevNum = 0;	//上一步可走棋的数目
		map.key = [0,0];	//用于置换表的键值
		history = [];
		update();
	}

	function update()	//
	{
		var aiAuto = oo.aiSide==map.side || oo.aiSide==2;
		oo.findLocation(map);
		
		// 先清除pass状态，避免与新的timer冲突
		setPassStatus(false);
		board.update(map, false); // 总是显示可下棋的提示点

		if (map.space==0 || map.nextNum==0 && map.prevNum==0)		//棋盘子满 或 双方都无棋可走
		{
			// 清除所有计时器，避免冲突
			clearTimeout(timer);
			timer = setTimeout(gameOver, 450);
			return;
		}
		if (map.nextNum==0)	//无棋可走pass
		{
			// 清除之前的timer，避免冲突
			clearTimeout(timer);
			timer = setTimeout(function() {

                oo.pass(map);
				// 先显示pass提示
				setPassStatus(true);
				// 延迟更新，确保pass提示显示完整的3秒
				timer = setTimeout(function() {
					update();
				}, 2000); // 给pass提示留出完整的3秒显示时间
			}, 450);
			return;
		}
		if (aiAuto)
		{
			// AI即将下棋时，隐藏提示点避免干扰
			board.update(map, true);
			// 清除之前的timer，避免冲突
			clearTimeout(timer);
			// 让机器等待500ms后再下棋
			timer = setTimeout(aiRun, 800);
		}
	}

	function aiRun()		//电脑走棋
	{
		try {
			// 检查是否有可走的棋
			if (map.nextNum == 0) {
				console.log('AI无棋可走，应该由update函数处理pass逻辑');
				return;
			}
			
			// 确保nextIndex数组有效
			if (!map.nextIndex || map.nextIndex.length == 0) {
				console.error('AI: nextIndex数组为空');
				return;
			}
			
			var moveIndex;
			if (map.nextNum == 1) {
				// 只有一步棋可走
				moveIndex = map.nextIndex[0];
			} else if (map.space <= 58) {
				// 使用AI搜索
				moveIndex = ai.startSearch(map);
			} else {
				// 开局阶段随机选择
				moveIndex = map.nextIndex[Math.floor(Math.random() * map.nextIndex.length)];
			}
			
			// 验证选择的位置是否有效
			if (moveIndex >= 0 && moveIndex < 64 && map.nextIndex.indexOf(moveIndex) !== -1) {
				oo.go(moveIndex);
			} else {
				console.error('AI选择了无效位置:', moveIndex);
				// fallback：选择第一个可用位置
				if (map.nextIndex.length > 0) {
					oo.go(map.nextIndex[0]);
				}
			}
		} catch(error) {
			console.error('AI运行错误:', error);
			// 错误处理：选择第一个可用位置
			if (map.nextIndex && map.nextIndex.length > 0) {
				oo.go(map.nextIndex[0]);
			}
		}
	}
	// document.getElementById("ai").onclick = aiRun;

	function gameOver()
	{
		// 清除所有计时器
		if (passTimer) {
			clearTimeout(passTimer);
			passTimer = null;
		}
		setPassStatus(false);
		
		// 优化游戏结束提示，更适合小学生
		var result = "";
		var icon = "";
		if (map.black == map.white) {
			result = "🤝 平局！真是势均力敌的对决！\n\n⚫ 黑棋: "+map.black+" 个\n⚪ 白棋: "+map.white+" 个";
			icon = "⚖️";
		} else if (map.black > map.white) {
			if (othe.aiSide == 1) {
				result = "🤖 电脑获胜！再接再厉哦！\n\n⚫ 黑棋: "+map.black+" 个\n⚪ 白棋: "+map.white+" 个";
				icon = "🤖";
			} else {
				showConfetti()
				result = "🎉 恭喜你获胜！太棒了！\n\n⚫ 黑棋: "+map.black+" 个\n⚪ 白棋: "+map.white+" 个";
				icon = "🏆";
			}
		} else {
			if (othe.aiSide == -1) {
				result = "🤖 电脑获胜！再接再厉哦！\n\n⚫ 黑棋: "+map.black+" 个\n⚪ 白棋: "+map.white+" 个";
				icon = "🤖";
			} else {
				showConfetti()
				result = "🎉 恭喜你获胜！太棒了！\n\n⚫ 黑棋: "+map.black+" 个\n⚪ 白棋: "+map.white+" 个";
				icon = "🏆";
			}
		}
		
		showCustomAlert(result, icon, "游戏结束");
	}

	oo.dire = (function(){				//获取某一棋盘格某一方向的格子.超过边界返回64
		var dr = [-8,-7,1,9,8,7,-1,-9];
		var bk = [8,0,0,0,8,7,7,7];
		return function(i,d)
		{
			i += dr[d];
			return (i&64)!=0 || (i&7)==bk[d] ? 64 : i;
		}
	})();

	oo.findLocation = function (m)		//查找可走棋的位置
	{
		function is(i,j)
		{
			var lk = 0;
			while ((i=oo.dire(i,j))!=64 && m[i]==-m.side)
			{
				ta[la++] = i;
				lk++;
			}
			if(i==64 || m[i]!=m.side)
				la -= lk;
		}
		
		// 重置可走棋位置
		m.nextIndex = [];
		m.next = {};
		
		var hist = ai.history[m.side==1?0:1][m.space];
		for(var i=0; i<60; i++)
		{
			var fi = hist[i];
			// 检查位置是否在边界内、是否为空、是否在前沿
			if (fi < 0 || fi >= 64 || !m.frontier[fi] || m[fi] !== 0)
				continue;
				
			var ta = [], la = 0;
			for (var j=0; j<8; j++)
				is(fi,j);
				
			if (la > 0)
			{
				// 确保数组长度正确
				if (la != ta.length)
			 		ta = ta.slice(0, la);
				m.next[fi] = ta;
				m.nextIndex.push(fi);
			}
		}
		m.nextNum = m.nextIndex.length;
	}

	oo.pass = function(m)			//一方无棋可走
	{
		m.side = -m.side;
		m.prevNum = m.nextNum;
		zobrist.swap(m.key);
	}

	oo.newMap = function(m,n)			//返回新的棋局
	{
		var nm = m.slice(0);		//复制数组
		nm[n] = m.side;				//把新下的棋子放到棋盘上

		nm.key = m.key.slice(0);		//复制数组
		zobrist.set(nm.key,m.side==1?0:1,n);

		nm.frontier = m.frontier.slice(0);		//复制数组
		nm.frontier[n] = false;
		for (var i=0; i<8; i++)
		{
			var k = oo.dire(n,i);
			if (k!=64 && nm[k]==0)
				nm.frontier[k] = true;
		}

		var ne = m.next[n];
		var l = ne.length;
		for(var i=0; i<l; i++)
		{
			nm[ne[i]] = m.side;		//反转的棋子
			zobrist.set(nm.key,2,ne[i]);
		}
		// 修复计数逻辑：确保计数正确
		if (m.side == 1) {
			// 黑棋下子：黑棋数量增加（新下的1个 + 翻转的l个），白棋数量减少（翻转的l个）
			nm.black = m.black + l + 1;
			nm.white = m.white - l;
		} else {
			// 白棋下子：白棋数量增加（新下的1个 + 翻转的l个），黑棋数量减少（翻转的l个）
			nm.white = m.white + l + 1;
			nm.black = m.black - l;
		}
		
		// 确保计数不会出现负数或超出范围
		nm.black = Math.max(0, Math.min(64, nm.black));
		nm.white = Math.max(0, Math.min(64, nm.white));
		nm.space = 64 - nm.black - nm.white;		//空格数目
		nm.side = -m.side;
		nm.prevNum = m.nextNum;
		zobrist.swap(nm.key);
		return nm;
	}


	oo.goChess = function (n)	//走棋
	{
		history.push(map);
		oo.go(n);
	}

	oo.go = function (n)	//走棋
	{

		var rev = map.next[n];
		map = oo.newMap(map,n);
		map.newRev = rev;
		map.newPos = n;
		// console.log(map.key);
		update();
	}

	oo.historyBack = function ()
	{
		if (history.length==0)
			return;
		
		// 清除所有计时器，包括pass提示计时器
		clearTimeout(timer);
		if (passTimer) {
			clearTimeout(passTimer);
			passTimer = null;
		}
		setPassStatus(false);
		
		// 优化：如果是人机对战，悔棋时应该退回两步（玩家和AI各一步）
		if (othe.aiSide !== 0 && history.length >= 2) {
			history.pop(); // 退回AI的一步
			if (history.length > 0) {
				map = history.pop(); // 退回玩家的一步
			} else {
				// 如果历史记录不够，重新开始游戏
				othe.play();
				return;
			}
		} else {
			map = history.pop();
		}
		update();
	}



	function setPassStatus(t)		//设置pass状态
	{
		// 只有在需要隐藏时才清除计时器，避免打断正在显示的提示
		if (!t && passTimer) {
			clearTimeout(passTimer);
			passTimer = null;
			passObj.style.display = "none";
			return;
		}
		
		if(t) {
			// 如果已经在显示pass提示，不要重复设置
			if (passTimer) {
				return;
			}
			
			// 更友好的提示信息
			if (map.side == 1) {
				passObj.innerHTML = "⚪ 无位置，⚫ 继续！";
			} else {
				passObj.innerHTML = "⚫ 无位置，⚪ 继续！";
			}
			
			passObj.style.display = "block";
			
			// 显示3秒，时间适中不会太长
			passTimer = setTimeout(function() {
				passObj.style.display = "none";
				passTimer = null;
			}, 3000);
		}
	}

}


var board = new Chessboard();
var ai = new AI();
var othe = new Othello();

// 本地存储管理
var StorageManager = {
	key: 'heibai_game_settings',
	
	// 保存设置
	save: function(settings) {
		try {
			localStorage.setItem(this.key, JSON.stringify(settings));
		} catch(e) {
			console.log('本地存储失败:', e);
		}
	},
	
	// 加载设置
	load: function() {
		try {
			var data = localStorage.getItem(this.key);
			return data ? JSON.parse(data) : null;
		} catch(e) {
			console.log('本地存储读取失败:', e);
			return null;
		}
	}
};

// 游戏状态管理
var GameManager = {
	gameStarted: false,
	defaultSettings: {
		difficulty: 0,  // 默认最简单难度
		gameMode: 'ai'  // 默认人机对战模式
	},
	
	// 难度配置
	difficulties: [
		{ time: 10, depth: 0, name: '新手' },
		{ time: 10, depth: 1, name: '普通' },
		{ time: 10, depth: 3, name: '困难' }
	],
	
	// 统一的事件处理器
	handlers: {
		play: function() {
			// 如果游戏已经开始，则重新开始游戏
			if (GameManager.gameStarted) {
				// 加载并应用保存的设置
				GameManager.loadSettings();
				GameManager.startQuickGame();
			} else {
				// 首次开始游戏，直接开始
				GameManager.startQuickGame();
			}
		},
		
		setting: function() {
			// 显示设置界面
			GameManager.loadSettings();
			document.getElementById("selectbox").style.display = "block";
		},
		
		back: function() {
			othe.historyBack();
		},
		
		ok: function() {
			document.getElementById("selectbox").style.display = "none";
			var inputs = document.getElementById("selectbox").getElementsByTagName("input");
			
			// 获取选中的游戏模式
			var gameMode = 'ai';
			var gameModeInputs = document.querySelectorAll('input[name="gameMode"]');
			for (var i = 0; i < gameModeInputs.length; i++) {
				if (gameModeInputs[i].checked) {
					gameMode = gameModeInputs[i].value;
					break;
				}
			}
			
			// 获取选中的难度
			var difficultyIndex = 0;
			var levelInputs = document.querySelectorAll('input[name="level"]');
			for (var i = 0; i < levelInputs.length; i++) {
				if (levelInputs[i].checked) {
					difficultyIndex = i;
					break;
				}
			}
			
			// 保存用户设置
			var settings = {
				difficulty: difficultyIndex,
				gameMode: gameMode
			};
			StorageManager.save(settings);
			
			// 根据游戏模式设置AI
			if (gameMode === 'ai') {
				// 人机对战模式：用户先下（AI为白棋）
				othe.aiSide = -1;
				var difficulty = GameManager.difficulties[difficultyIndex] || GameManager.difficulties[0];
				ai.calculateTime = difficulty.time;
				ai.outcomeDepth = difficulty.depth;
			} else {
				// 人人对战模式：禁用AI
				othe.aiSide = 0;
			}
			
			GameManager.gameStarted = true;
			othe.play();
			
			// 更新按钮文本
			GameManager.updatePlayButton();
		},

		chessboardClick: function(e) {
			// 如果游戏还没开始，则快速开始游戏
			if (!GameManager.gameStarted) {
				GameManager.startQuickGame();
			}
		}
	},
	
	// 加载保存的设置
	loadSettings: function() {
		var settings = StorageManager.load() || this.defaultSettings;
		
		// 应用设置到界面
		var selectbox = document.getElementById("selectbox");
		if (selectbox) {
			// 设置游戏模式选择
			var gameModeInputs = document.querySelectorAll('input[name="gameMode"]');
			for (var i = 0; i < gameModeInputs.length; i++) {
				gameModeInputs[i].checked = gameModeInputs[i].value === settings.gameMode;
			}
			
			// 设置难度选择
			var levelInputs = document.querySelectorAll('input[name="level"]');
			for (var i = 0; i < levelInputs.length; i++) {
				levelInputs[i].checked = i === settings.difficulty;
			}
			
			// 更新AI难度选项的显示状态
			toggleDifficultySection();
		}
	},
	
	// 快速开始游戏
	startQuickGame: function() {
		this.gameStarted = true;
		
		// 使用保存的设置或默认设置
		var settings = StorageManager.load() || this.defaultSettings;
		
		// 根据游戏模式设置AI
		if (settings.gameMode === 'ai') {
			// 人机对战模式：用户先下（AI为白棋）
			othe.aiSide = -1;
			var difficulty = this.difficulties[settings.difficulty] || this.difficulties[0];
			ai.calculateTime = difficulty.time;
			ai.outcomeDepth = difficulty.depth;
		} else {
			// 人人对战模式：禁用AI
			othe.aiSide = 0;
		}
		
		othe.play();
		
		// 更新按钮文本
		this.updatePlayButton();
	},
	
	// 更新开始/重开按钮文本
	updatePlayButton: function() {
		var playButton = document.getElementById("play");
		if (this.gameStarted) {
			playButton.innerHTML = "🔄 重开";
		} else {
			playButton.innerHTML = "🎮 开始";
		}
	},
	
	// 初始化事件监听器
	init: function() {
		// 绑定所有事件处理器
		document.getElementById("play").addEventListener('click', this.handlers.play);
		document.getElementById("setting").addEventListener('click', this.handlers.setting);
		document.getElementById("back").addEventListener('click', this.handlers.back);
		document.getElementById("ok").addEventListener('click', this.handlers.ok);
		
		// 棋盘点击事件
		var chessboard = document.getElementById('chessboard');
		if (chessboard) {
			chessboard.addEventListener('click', this.handlers.chessboardClick);
		}
		
		// 初始化按钮文本
		this.updatePlayButton();
	}
};

// 初始化
board.create();
board.toDown = othe.goChess;

// 页面加载完成后初始化事件管理器
document.addEventListener('DOMContentLoaded', function() {
	GameManager.init();
});

// 切换AI难度选项的显示/隐藏
function toggleDifficultySection() {
	var gameModeInputs = document.querySelectorAll('input[name="gameMode"]');
	var difficultySection = document.getElementById('difficulty-section');
	
	for (var i = 0; i < gameModeInputs.length; i++) {
		if (gameModeInputs[i].checked) {
			if (gameModeInputs[i].value === 'ai') {
				difficultySection.style.display = 'block';
			} else {
				difficultySection.style.display = 'none';
			}
			break;
		}
	}
}

// 自定义Alert函数
function showCustomAlert(message, icon = "🎯", title = "游戏提示") {
	var alertDiv = document.getElementById("custom-alert");
	var iconDiv = alertDiv.querySelector(".alert-icon");
	var titleDiv = alertDiv.querySelector(".alert-title");
	var messageDiv = alertDiv.querySelector(".alert-message");
	
	iconDiv.textContent = icon;
	titleDiv.textContent = title;
	messageDiv.textContent = message;
	
	alertDiv.style.display = "flex";
}

function closeCustomAlert() {
	document.getElementById("custom-alert").style.display = "none";
}
</script>
</body>
</html>