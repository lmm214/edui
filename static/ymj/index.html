<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>åœ†çš„é¢ç§¯</title>
  <style>
    body {
      background: #f0f8ff;
      font-family: "Comic Sans MS", cursive, sans-serif;
      text-align: center;
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
    }
    h1 {
      color: #ff4500;
      margin: 0;
      font-size: clamp(1.5rem, 2vw, 2rem);
    }
    #canvasContainer {
      flex: 1;
      position: relative;
      width: 98vw;
      margin: 0 auto;
      max-height: calc(100vh - 200px);
      min-height: 300px;
    }
    canvas {
      background: #f0f8ff;
      width: 100%;
      height: 100%;
      display: block;
    }
    .controls {
      margin: 0 auto;
      width: max-content;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
      z-index: 1000;
    }
    
    .controls label {
      color: #ff4500;
      font-weight: bold;
      font-size: clamp(14px, 2.5vw, 18px);
    }
    
    #segmentValue {
      color: #ff4500;
      font-weight: bold;
      font-size: clamp(16px, 3vw, 20px);
      background: #ffffff;
      border: 2px solid #ffa500;
      border-radius: 8px;
      padding: 4px 8px;
      min-width: 30px;
      text-align: center;
    }
    
    input[type=range] {
      width: clamp(100px, 55vw, 800px);
      height: 8px;
      border-radius: 5px;
      background: linear-gradient(to right, #ffa500, #ff6347);
      outline: none;
      -webkit-appearance: none;
      transition: all 0.3s ease;
    }
    
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #ff4500;
      cursor: pointer;
      border: 2px solid #ffffff;
      box-shadow: 0 2px 6px rgba(255, 69, 0, 0.3);
      transition: all 0.3s ease;
    }
    
    input[type=range]::-webkit-slider-thumb:hover {
      background: #ff6347;
      transform: scale(1.1);
      box-shadow: 0 4px 8px rgba(255, 69, 0, 0.4);
    }
    
    input[type=range]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #ff4500;
      cursor: pointer;
      border: 2px solid #ffffff;
      box-shadow: 0 2px 6px rgba(255, 69, 0, 0.3);
      transition: all 0.3s ease;
    }
    
    input[type=range]::-moz-range-thumb:hover {
      background: #ff6347;
      transform: scale(1.1);
      box-shadow: 0 4px 8px rgba(255, 69, 0, 0.4);
    }
    
    button {
      font-size: clamp(16px, 3vw, 20px);
      padding: 10px 20px;
      cursor: pointer;
      background: linear-gradient(135deg, #ff6347, #ff4500);
      color: white;
      border: none;
      border-radius: 25px;
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 4px 8px rgba(255, 69, 0, 0.3);
    }
    
    button:hover {
      background: linear-gradient(135deg, #ff4500, #ff6347);
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(255, 69, 0, 0.4);
    }
    
    button:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(255, 69, 0, 0.3);
    }
  </style>
</head>
<body>
  <a href="https://edui123.com/ymj2/"><h1>åœ†çš„é¢ç§¯ <span title="åˆ‡æ¢åˆ°åŒå¿ƒåœ†å±•å¼€æ¨¡å¼" style="cursor:pointer">ğŸ”</span></h1></a>
  <div id="canvasContainer">
    <canvas id="canvas" width="1200" height="800"></canvas>
  </div>
  <div class="controls">
    <span id="segmentValue">4</span>
    <!-- ä½¿ç”¨æ»‘å—æ›¿ä»£è¾“å…¥æ¡†ï¼ŒèŒƒå›´2-20ï¼Œæ­¥é•¿2 -->
    <input type="range" id="segmentCount" value="4" min="4" max="200" step="2">
    <button id="unfoldButton">å±•å¼€</button>
  </div>
  
  <script>
    /********** å…¨å±€å‚æ•° **********/
    let r = 150;      // åœ†çš„åŠå¾„ï¼Œç°åœ¨æ”¹ä¸ºåŠ¨æ€è®¡ç®—
    const T = 2000;   // åŠ¨ç”»æ€»æ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰
    
    let canvas, ctx;
    let animationRequest = null, animationStart = null;
    let polylineConfig = {}; // ä¿å­˜åœ†ã€é¡¶ç‚¹ã€é“¾ä¿¡æ¯
    
    // æ‹–æ‹½ç›¸å…³å…¨å±€å˜é‡
    let redOffset = { x: 0, y: 0 };
    let blueOffset = { x: 0, y: 0 };
    let dragEnabled = false;  // æ‰‡å½¢å±•å¼€å®Œæˆåå…è®¸æ‹–æ‹½
    let draggingGroup = null; // "red" æˆ– "blue"
    let lastDragPos = { x: 0, y: 0 };
    
    /********** è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æ‰‡å½¢åœ†å¿ƒ **********/
    // é‡æ–°è®¾è®¡ï¼šåŸºäºæ­£ç¡®çš„å‡ ä½•åŸç†
    // æ¯ä¸ªæ‰‡å½¢åº”è¯¥æœ‰ç›¸åŒçš„åœ†å¿ƒè§’ï¼Œæ‰‡å½¢åœ†å¿ƒä½ç½®ç”±å¼¦çš„å‚ç›´å¹³åˆ†çº¿ç¡®å®š
    function computeSectorCenter(P, Q, sectorColor) {
      // è®¡ç®—å¼¦çš„ä¸­ç‚¹
      let M = { x: (P.x + Q.x) / 2, y: (P.y + Q.y) / 2 };
      
      // è®¡ç®—å¼¦çš„é•¿åº¦
      let chordLength = Math.hypot(Q.x - P.x, Q.y - P.y);
      if (chordLength < 1e-6) return { x: polylineConfig.cx, y: polylineConfig.cy };
      
      // è®¡ç®—å¼¦å¿ƒè·ï¼ˆä»æ‰‡å½¢åœ†å¿ƒåˆ°å¼¦çš„è·ç¦»ï¼‰
      // ä½¿ç”¨å…¬å¼ï¼šå¼¦å¿ƒè· = sqrt(rÂ² - (å¼¦é•¿/2)Â²)
      let halfChord = chordLength / 2;
      if (halfChord > r) return null; // å¼¦é•¿ä¸èƒ½è¶…è¿‡ç›´å¾„
      
      let chordDistance = Math.sqrt(r * r - halfChord * halfChord);
      
      // è®¡ç®—å¼¦çš„å‚ç›´æ–¹å‘å•ä½å‘é‡
      let chordVector = { x: Q.x - P.x, y: Q.y - P.y };
      let perpVector = { x: -chordVector.y / chordLength, y: chordVector.x / chordLength };
      
      // æ ¹æ®æ‰‡å½¢é¢œè‰²ç¡®å®šåœ†å¿ƒä½ç½®ï¼ˆçº¢è‰²åœ¨ä¸Šæ–¹ï¼Œè“è‰²åœ¨ä¸‹æ–¹ï¼‰
      let direction = (sectorColor.indexOf("255,0,0") !== -1) ? 1 : -1;
      
      let sectorCenter = {
        x: M.x + direction * chordDistance * perpVector.x,
        y: M.y + direction * chordDistance * perpVector.y
      };
      
      return sectorCenter;
    }
    
    /********** è¾…åŠ©å‡½æ•°ï¼šç»˜åˆ¶æ‰‡å½¢ **********/
    // å‚æ•° P, Q ä¸ºæ‰‡å½¢å¼§çš„ä¸¤ç«¯ï¼›sectorColor ä¸ºåŸºç¡€é¢œè‰²å­—ç¬¦ä¸²ï¼ˆå¦‚ "255,0,0" æˆ– "0,0,255"ï¼‰
    function drawSector(P, Q, sectorColor) {
      // è®¡ç®—å¼¦é•¿ï¼Œå¦‚æœå¼¦é•¿å¤ªå°ï¼ˆæ¥è¿‘0ï¼‰ï¼Œè¯´æ˜è¿™æ˜¯ä¸€ä¸ªåŠå¾„çº¿æ‰‡å½¢ï¼Œä¸åº”è¯¥ç»˜åˆ¶
      let chordLength = Math.hypot(Q.x - P.x, Q.y - P.y);
      let minChordLength = r * 0.01; // è®¾ç½®æœ€å°å¼¦é•¿é˜ˆå€¼ä¸ºåŠå¾„çš„1%
      if (chordLength < minChordLength) {
        return; // è·³è¿‡ç»˜åˆ¶åŠå¾„çº¿æ‰‡å½¢
      }
      
      let center = computeSectorCenter(P, Q, sectorColor);
      if (!center) return;
      let startAngle = Math.atan2(P.y - center.y, P.x - center.x);
      let endAngle = Math.atan2(Q.y - center.y, Q.x - center.x);
      let delta = endAngle - startAngle;
      if (delta < 0) delta += 2 * Math.PI;
      let anticlockwise = (delta > Math.PI);
      
      ctx.beginPath();
      ctx.moveTo(center.x, center.y);
      ctx.arc(center.x, center.y, r, startAngle, endAngle, anticlockwise);
      ctx.closePath();
      ctx.fillStyle = "rgba(" + sectorColor + ",0.5)";
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(" + sectorColor + ",1)";
      ctx.stroke();
    }
    
    /********** è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­ç‚¹æ˜¯å¦åœ¨æ‰‡å½¢å†… **********/
    // æ ¹æ® P, Q åŠæ‰‡å½¢é¢œè‰²ç”Ÿæˆæ‰‡å½¢åŒºåŸŸï¼Œå¹¶æ£€æµ‹ç‚¹ pos æ˜¯å¦åœ¨è¯¥åŒºåŸŸå†…
    function isPointInSector(P, Q, sectorColor, pos) {
      // åŒæ ·éœ€è¦æ£€æŸ¥å¼¦é•¿ï¼Œé¿å…å¯¹åŠå¾„çº¿æ‰‡å½¢è¿›è¡Œç‚¹å‡»æ£€æµ‹
      let chordLength = Math.hypot(Q.x - P.x, Q.y - P.y);
      let minChordLength = r * 0.01; // è®¾ç½®æœ€å°å¼¦é•¿é˜ˆå€¼ä¸ºåŠå¾„çš„1%
      if (chordLength < minChordLength) {
        return false; // åŠå¾„çº¿æ‰‡å½¢ä¸å‚ä¸ç‚¹å‡»æ£€æµ‹
      }
      
      let center = computeSectorCenter(P, Q, sectorColor);
      if (!center) return false;
      let startAngle = Math.atan2(P.y - center.y, P.x - center.x);
      let endAngle = Math.atan2(Q.y - center.y, Q.x - center.x);
      let delta = endAngle - startAngle;
      if (delta < 0) delta += 2 * Math.PI;
      let anticlockwise = (delta > Math.PI);
      
      let path = new Path2D();
      path.moveTo(center.x, center.y);
      path.arc(center.x, center.y, r, startAngle, endAngle, anticlockwise);
      path.closePath();
      return ctx.isPointInPath(path, pos.x, pos.y);
    }
    
    /********** é…ç½®ç”Ÿæˆ **********/
    function generateConfig() {
      const input = document.getElementById("segmentCount");
      const val = parseInt(input.value);
      const N = val / 2;
      polylineConfig.N = N;
      
      // åŠ¨æ€è®¡ç®—åœ†çš„åŠå¾„ï¼Œå……åˆ†åˆ©ç”¨ç”»å¸ƒç©ºé—´
      // å–ç”»å¸ƒå®½åº¦å’Œé«˜åº¦çš„è¾ƒå°å€¼çš„35%ä½œä¸ºåŠå¾„ï¼Œç¡®ä¿åœ†èƒ½å®Œæ•´æ˜¾ç¤ºä¸”æœ‰è¶³å¤Ÿçš„å±•å¼€ç©ºé—´
      r = Math.min(canvas.width, canvas.height) * 0.4;
      
      // å›ºå®šåœ†çš„åœ†å¿ƒï¼šç”»å¸ƒä¸­å¿ƒ
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      polylineConfig.cx = cx;
      polylineConfig.cy = cy;
      polylineConfig.r = r;
      
      // åœ¨åœ†ä¸Šå– N+1 ä¸ªé¡¶ç‚¹ï¼šç¡®ä¿æ¯ä¸ªæ‰‡å½¢è§’åº¦ç›¸ç­‰
      // æ¯ä¸ªæ‰‡å½¢çš„è§’åº¦åº”è¯¥æ˜¯ Ï€/Nï¼ˆåŠåœ†å¹³å‡åˆ†æˆNä»½ï¼‰
      let V = [];
      for (let i = 0; i <= N; i++) {
        let theta = Math.PI - i * (Math.PI / N);
        let x = cx + r * Math.cos(theta);
        let y = cy - r * Math.sin(theta);
        V.push({ x: x, y: y });
      }
      polylineConfig.V = V;
      
      // æ ¹æ® N çš„å¥‡å¶æ€§æ„é€ ä¸¤æ¡é“¾ï¼šBé“¾ï¼ˆå·¦ä¾§ï¼‰å’Œ Aé“¾ï¼ˆå³ä¾§ï¼‰
      let Bchain = [], Achain = [];
      if (N % 2 === 0) {
        let j = N / 2;
        for (let i = 0; i <= j; i++) {
          Bchain.push(V[j - i]);
        }
        for (let i = 0; i <= N - j; i++) {
          Achain.push(V[j + i]);
        }
        polylineConfig.creaseType = "even";
      } else {
        let j = Math.floor(N / 2);
        for (let i = 0; i <= j; i++) {
          Bchain.push(V[j - i]);
        }
        for (let i = 0; i <= N - j - 1; i++) {
          Achain.push(V[j + 1 + i]);
        }
        polylineConfig.creaseType = "odd";
      }
      polylineConfig.Bchain = Bchain;
      polylineConfig.Achain = Achain;
      
      // è®¡ç®—å„é“¾ä¸­æ¯æ®µçš„é•¿åº¦ä¸åˆå§‹è§’åº¦
      let Bsegments = [];
      for (let i = 0; i < Bchain.length - 1; i++) {
        let p0 = Bchain[i], p1 = Bchain[i + 1];
        let dx = p1.x - p0.x, dy = p1.y - p0.y;
        let angle = Math.atan2(dy, dx);
        let len = Math.hypot(dx, dy);
        Bsegments.push({ len: len, initAngle: angle });
      }
      polylineConfig.Bsegments = Bsegments;
      
      let Asegments = [];
      for (let i = 0; i < Achain.length - 1; i++) {
        let p0 = Achain[i], p1 = Achain[i + 1];
        let dx = p1.x - p0.x, dy = p1.y - p0.y;
        let angle = Math.atan2(dy, dx);
        let len = Math.hypot(dx, dy);
        Asegments.push({ len: len, initAngle: angle });
      }
      polylineConfig.Asegments = Asegments;
    }
    
    /********** æ ¹æ®åŠ¨ç”»è¿›åº¦è®¡ç®—é“¾ä¸Šé¡¶ç‚¹ä½ç½® **********/
    function computeChainPositions(chain, segments, finalAngle, progress) {
      let pos = [];
      pos.push({ x: chain[0].x, y: chain[0].y });
      let current = { x: chain[0].x, y: chain[0].y };
      for (let i = 0; i < segments.length; i++) {
        let seg = segments[i];
        let curAngle = seg.initAngle + (finalAngle - seg.initAngle) * progress;
        current = {
          x: current.x + seg.len * Math.cos(curAngle),
          y: current.y + seg.len * Math.sin(curAngle)
        };
        pos.push(current);
      }
      return pos;
    }
    
    /********** ç»˜åˆ¶å·²å±•å¼€çŠ¶æ€ï¼ˆè¿›åº¦=1ï¼‰ï¼Œå¹¶åº”ç”¨æ‹–æ‹½åç§» **********/
    function drawExpanded() {
      let Bpos = computeChainPositions(polylineConfig.Bchain, polylineConfig.Bsegments, Math.PI, 1);
      let Apos = computeChainPositions(polylineConfig.Achain, polylineConfig.Asegments, 0, 1);
      let polyline = [];
      for (let i = Bpos.length - 1; i >= 0; i--) {
        polyline.push(Bpos[i]);
      }
      for (let i = 0; i < Apos.length; i++) {
        polyline.push(Apos[i]);
      }
      let mirror = polyline.map(p => ({ x: p.x, y: 2 * polylineConfig.cy - p.y }));
      
      // åº”ç”¨æ‹–æ‹½åç§»
      let redPolyline = polyline.map(p => ({ x: p.x + redOffset.x, y: p.y + redOffset.y }));
      let bluePolyline = mirror.map(p => ({ x: p.x + blueOffset.x, y: p.y + blueOffset.y }));
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      ctx.arc(polylineConfig.cx, polylineConfig.cy, r, 0, 2 * Math.PI);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.strokeStyle = "gray";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      for (let i = 0; i < redPolyline.length - 1; i++) {
        drawSector(redPolyline[i], redPolyline[i + 1], "255,0,0");
      }
      for (let i = 0; i < bluePolyline.length - 1; i++) {
        drawSector(bluePolyline[i], bluePolyline[i + 1], "0,0,255");
      }
    }
    
    /********** åŠ¨ç”» **********/
    function animate(timestamp) {
      if (!animationStart) animationStart = timestamp;
      let elapsed = timestamp - animationStart;
      let progress = Math.min(elapsed / T, 1);
      
      let Bpos = computeChainPositions(polylineConfig.Bchain, polylineConfig.Bsegments, Math.PI, progress);
      let Apos = computeChainPositions(polylineConfig.Achain, polylineConfig.Asegments, 0, progress);
      let polyline = [];
      for (let i = Bpos.length - 1; i >= 0; i--) {
        polyline.push(Bpos[i]);
      }
      for (let i = 0; i < Apos.length; i++) {
        polyline.push(Apos[i]);
      }
      let mirror = polyline.map(p => ({ x: p.x, y: 2 * polylineConfig.cy - p.y }));
      
      let redPolyline = polyline.map(p => ({ x: p.x + redOffset.x, y: p.y + redOffset.y }));
      let bluePolyline = mirror.map(p => ({ x: p.x + blueOffset.x, y: p.y + blueOffset.y }));
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      ctx.arc(polylineConfig.cx, polylineConfig.cy, r, 0, 2 * Math.PI);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.strokeStyle = "gray";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      for (let i = 0; i < redPolyline.length - 1; i++) {
        drawSector(redPolyline[i], redPolyline[i + 1], "255,0,0");
      }
      for (let i = 0; i < bluePolyline.length - 1; i++) {
        drawSector(bluePolyline[i], bluePolyline[i + 1], "0,0,255");
      }
      
      if (elapsed < T) {
        animationRequest = requestAnimationFrame(animate);
      } else {
        animationRequest = null;
        animationStart = null;
        dragEnabled = true;
        drawExpanded();
      }
    }
    
    /********** ç»˜åˆ¶åˆå§‹çŠ¶æ€ **********/
    function drawInitial() {
      let V = polylineConfig.V;
      let polyline;
      if (polylineConfig.creaseType === "even") {
        let B = polylineConfig.Bchain.slice();
        let A = polylineConfig.Achain.slice();
        B.reverse();
        if (Math.abs(B[B.length - 1].x - A[0].x) < 1e-6 &&
            Math.abs(B[B.length - 1].y - A[0].y) < 1e-6) {
          A.shift();
        }
        polyline = B.concat(A);
      } else {
        let B = polylineConfig.Bchain.slice();
        B.reverse();
        polyline = B.concat(polylineConfig.Achain);
      }
      let mirror = polyline.map(p => ({ x: p.x, y: 2 * polylineConfig.cy - p.y }));
      
      let redPolyline = polyline.map(p => ({ x: p.x + redOffset.x, y: p.y + redOffset.y }));
      let bluePolyline = mirror.map(p => ({ x: p.x + blueOffset.x, y: p.y + blueOffset.y }));
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      ctx.arc(polylineConfig.cx, polylineConfig.cy, r, 0, 2 * Math.PI);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.strokeStyle = "gray";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      for (let i = 0; i < redPolyline.length - 1; i++) {
        drawSector(redPolyline[i], redPolyline[i + 1], "255,0,0");
      }
      for (let i = 0; i < bluePolyline.length - 1; i++) {
        drawSector(bluePolyline[i], bluePolyline[i + 1], "0,0,255");
      }
    }
    
    /********** æ‹–æ‹½ç›¸å…³äº‹ä»¶å¤„ç† **********/
    function getEventPos(e) {
      let rect = canvas.getBoundingClientRect();
      if (e.touches && e.touches.length > 0) {
        return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
      } else {
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }
    }
    
    // æ‹–æ‹½å¼€å§‹æ—¶ï¼Œæ ¹æ®é¼ æ ‡ç‚¹å‡»ä½ç½®æ˜¯å¦è½åœ¨çº¢/è“æ‰‡å½¢å†…æ¥ç¡®å®šæ‹–æ‹½ç›®æ ‡
    function onDragStart(e) {
      if (!dragEnabled) return;
      e.preventDefault();
      let pos = getEventPos(e);
      
      // è®¡ç®—å½“å‰å±•å¼€çŠ¶æ€ï¼ˆprogress=1ï¼‰ä¸‹çš„çº¢è‰²å’Œè“è‰²æ‰‡å½¢ç»„çš„ä¸å¯è§æŠ˜çº¿
      let Bpos = computeChainPositions(polylineConfig.Bchain, polylineConfig.Bsegments, Math.PI, 1);
      let Apos = computeChainPositions(polylineConfig.Achain, polylineConfig.Asegments, 0, 1);
      let polyline = [];
      for (let i = Bpos.length - 1; i >= 0; i--) {
        polyline.push(Bpos[i]);
      }
      for (let i = 0; i < Apos.length; i++) {
        polyline.push(Apos[i]);
      }
      let mirror = polyline.map(p => ({ x: p.x, y: 2 * polylineConfig.cy - p.y }));
      let redPolyline = polyline.map(p => ({ x: p.x + redOffset.x, y: p.y + redOffset.y }));
      let bluePolyline = mirror.map(p => ({ x: p.x + blueOffset.x, y: p.y + blueOffset.y }));
      
      // æ£€æŸ¥ç‚¹å‡»ä½ç½®æ˜¯å¦è½åœ¨ä»»ä¸€çº¢è‰²æ‰‡å½¢å†…
      let targetGroup = null;
      for (let i = 0; i < redPolyline.length - 1; i++) {
        if (isPointInSector(redPolyline[i], redPolyline[i+1], "255,0,0", pos)) {
          targetGroup = "red";
          break;
        }
      }
      // å¦‚æœæ²¡æœ‰å‘½ä¸­çº¢è‰²ï¼Œå†æ£€æŸ¥è“è‰²
      if (!targetGroup) {
        for (let i = 0; i < bluePolyline.length - 1; i++) {
          if (isPointInSector(bluePolyline[i], bluePolyline[i+1], "0,0,255", pos)) {
            targetGroup = "blue";
            break;
          }
        }
      }
      
      // åªæœ‰ç‚¹å‡»å‘½ä¸­æŸä¸€æ‰‡å½¢æ—¶ï¼Œæ‰å¯åŠ¨æ‹–æ‹½
      if (targetGroup) {
        draggingGroup = targetGroup;
        lastDragPos = pos;
        if (e.type === "touchstart") {
          window.addEventListener("touchmove", onDragMove, { passive: false });
          window.addEventListener("touchend", onDragEnd);
        } else {
          window.addEventListener("mousemove", onDragMove);
          window.addEventListener("mouseup", onDragEnd);
        }
      }
    }
    
    function onDragMove(e) {
      if (!draggingGroup) return;
      e.preventDefault();
      let pos = getEventPos(e);
      let dx = pos.x - lastDragPos.x;
      let dy = pos.y - lastDragPos.y;
      
      // æ›´æ–°åç§»é‡
      if (draggingGroup === "red") {
        redOffset.x += dx;
        redOffset.y += dy;
      } else if (draggingGroup === "blue") {
        blueOffset.x += dx;
        blueOffset.y += dy;
      }
      
      // å¸é™„é€»è¾‘ï¼šé’ˆå¯¹æ‹–æ‹½ç»„ï¼Œå¯¹æ¯ä¸ªæ‰‡å½¢çš„åç«¯ç‚¹æ£€æŸ¥ï¼ˆåªæ£€æŸ¥ä¸€å¤„ï¼Œæ»¡è¶³æ¡ä»¶ç«‹å³è°ƒæ•´ï¼‰
      let Bpos = computeChainPositions(polylineConfig.Bchain, polylineConfig.Bsegments, Math.PI, 1);
      let Apos = computeChainPositions(polylineConfig.Achain, polylineConfig.Asegments, 0, 1);
      let polyline = [];
      for (let i = Bpos.length - 1; i >= 0; i--) {
        polyline.push(Bpos[i]);
      }
      for (let i = 0; i < Apos.length; i++) {
        polyline.push(Apos[i]);
      }
      let mirror = polyline.map(p => ({ x: p.x, y: 2 * polylineConfig.cy - p.y }));
      let redPolyline = polyline.map(p => ({ x: p.x + redOffset.x, y: p.y + redOffset.y }));
      let bluePolyline = mirror.map(p => ({ x: p.x + blueOffset.x, y: p.y + blueOffset.y }));
      
      if (draggingGroup === "red") {
        let snapped = false;
        // åŠ¨æ€å¸é™„èŒƒå›´ï¼šæ ¹æ®åœ†çš„åŠå¾„è°ƒæ•´ï¼Œæœ€å°30åƒç´ ï¼Œæœ€å¤§60åƒç´ 
        let snapDistance = Math.max(30, Math.min(60, r * 0.2));
        for (let i = 0; i < redPolyline.length - 1 && !snapped; i++) {
          let redEndpoint = redPolyline[i+1];
          for (let j = 0; j < bluePolyline.length - 1; j++) {
            let blueCenter = computeSectorCenter(bluePolyline[j], bluePolyline[j+1], "0,0,255");
            if (!blueCenter) continue;
            let dist = Math.hypot(redEndpoint.x - blueCenter.x, redEndpoint.y - blueCenter.y);
            if (dist < snapDistance) {
              redOffset.x += (blueCenter.x - redEndpoint.x);
              redOffset.y += (blueCenter.y - redEndpoint.y);
              snapped = true;
              break;
            }
          }
        }
      } else if (draggingGroup === "blue") {
        let snapped = false;
        // åŠ¨æ€å¸é™„èŒƒå›´ï¼šæ ¹æ®åœ†çš„åŠå¾„è°ƒæ•´ï¼Œæœ€å°30åƒç´ ï¼Œæœ€å¤§60åƒç´ 
        let snapDistance = Math.max(30, Math.min(60, r * 0.2));
        for (let i = 0; i < bluePolyline.length - 1 && !snapped; i++) {
          let blueEndpoint = bluePolyline[i+1];
          for (let j = 0; j < redPolyline.length - 1; j++) {
            let redCenter = computeSectorCenter(redPolyline[j], redPolyline[j+1], "255,0,0");
            if (!redCenter) continue;
            let dist = Math.hypot(blueEndpoint.x - redCenter.x, blueEndpoint.y - redCenter.y);
            if (dist < snapDistance) {
              blueOffset.x += (redCenter.x - blueEndpoint.x);
              blueOffset.y += (redCenter.y - blueEndpoint.y);
              snapped = true;
              break;
            }
          }
        }
      }
      
      lastDragPos = pos;
      drawExpanded();
    }
    
    function onDragEnd(e) {
      draggingGroup = null;
      if (e.type === "touchend") {
        window.removeEventListener("touchmove", onDragMove);
        window.removeEventListener("touchend", onDragEnd);
      } else {
        window.removeEventListener("mousemove", onDragMove);
        window.removeEventListener("mouseup", onDragEnd);
      }
    }
    
    /********** åˆå§‹åŒ–åŠäº‹ä»¶ç»‘å®š **********/
    
    // è°ƒæ•´ç”»å¸ƒå°ºå¯¸ä»¥é€‚åº”å®¹å™¨
    function resizeCanvas() {
      const container = document.getElementById("canvasContainer");
      const containerRect = container.getBoundingClientRect();
      const containerWidth = containerRect.width - 6; // å‡å»è¾¹æ¡†å®½åº¦
      const containerHeight = containerRect.height - 6;
      
      canvas.width = containerWidth;
      canvas.height = containerHeight;
      
      // é‡æ–°ç”Ÿæˆé…ç½®ä»¥é€‚åº”æ–°çš„ç”»å¸ƒå°ºå¯¸
      generateConfig();
      
      // é‡ç»˜å½“å‰çŠ¶æ€
      if (dragEnabled) {
        drawExpanded();
      } else {
        drawInitial();
      }
    }
    
    window.onload = function() {
      canvas = document.getElementById("canvas");
      ctx = canvas.getContext("2d");
      
      // åˆå§‹åŒ–ç”»å¸ƒå°ºå¯¸
      resizeCanvas();
      
      // ç›‘å¬çª—å£å¤§å°å˜åŒ–
      window.addEventListener('resize', function() {
        clearTimeout(window.resizeTimeout);
        window.resizeTimeout = setTimeout(resizeCanvas, 100);
      });
      
      document.getElementById("segmentCount").addEventListener("input", function() {
        let value = parseInt(this.value);
        
        // æ»‘å—å·²ç»ç¡®ä¿äº†å¶æ•°å€¼å’ŒèŒƒå›´é™åˆ¶ï¼Œç›´æ¥æ›´æ–°æ˜¾ç¤º
        document.getElementById("segmentValue").textContent = value;
        
        if (animationRequest) {
          cancelAnimationFrame(animationRequest);
          animationRequest = null;
          animationStart = null;
        }
        dragEnabled = false;
        redOffset = { x: 0, y: 0 };
        blueOffset = { x: 0, y: 0 };
        generateConfig();
        drawInitial();
      });
      
      document.getElementById("unfoldButton").addEventListener("click", function() {
        if (animationRequest) return;
        dragEnabled = false;
        animationStart = null;
        animationRequest = requestAnimationFrame(animate);
      });
      
      canvas.addEventListener("mousedown", onDragStart);
      canvas.addEventListener("touchstart", onDragStart, { passive: false });
    };
  </script>
</body>
</html>

